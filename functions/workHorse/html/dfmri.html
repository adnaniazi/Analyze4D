
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>dfmri</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-06-26"><meta name="DC.source" content="dfmri.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">plot ROI</a></li><li><a href="#4">Call plot</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> varargout = dfmri(varargin)
<span class="comment">% DFMRI MATLAB code for dfmri.fig</span>
<span class="comment">%      DFMRI, by itself, creates a new DFMRI or raises the existing</span>
<span class="comment">%      singleton*.</span>
<span class="comment">%</span>
<span class="comment">%      H = DFMRI returns the handle to a new DFMRI or the handle to</span>
<span class="comment">%      the existing singleton*.</span>
<span class="comment">%</span>
<span class="comment">%      DFMRI('CALLBACK',hObject,eventData,handles,...) calls the local</span>
<span class="comment">%      function named CALLBACK in DFMRI.M with the given input arguments.</span>
<span class="comment">%</span>
<span class="comment">%      DFMRI('Property','Value',...) creates a new DFMRI or raises the</span>
<span class="comment">%      existing singleton*.  Starting from the left, property value pairs are</span>
<span class="comment">%      applied to the GUI before dfmri_OpeningFcn gets called.  An</span>
<span class="comment">%      unrecognized property name or invalid value makes property application</span>
<span class="comment">%      stop.  All inputs are passed to dfmri_OpeningFcn via varargin.</span>
<span class="comment">%</span>
<span class="comment">%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one</span>
<span class="comment">%      instance to run (singleton)".</span>
<span class="comment">%</span>
<span class="comment">% See also: GUIDE, GUIDATA, GUIHANDLES</span>

<span class="comment">% Edit the above text to modify the response to help dfmri</span>

<span class="comment">% Last Modified by GUIDE v2.5 16-Jun-2012 09:33:37</span>
<span class="comment">% Begin initialization code - DO NOT EDIT</span>
gui_Singleton = 1;
gui_State = struct(<span class="string">'gui_Name'</span>,       mfilename, <span class="keyword">...</span>
                   <span class="string">'gui_Singleton'</span>,  gui_Singleton, <span class="keyword">...</span>
                   <span class="string">'gui_OpeningFcn'</span>, @dfmri_OpeningFcn, <span class="keyword">...</span>
                   <span class="string">'gui_OutputFcn'</span>,  @dfmri_OutputFcn, <span class="keyword">...</span>
                   <span class="string">'gui_LayoutFcn'</span>,  [] , <span class="keyword">...</span>
                   <span class="string">'gui_Callback'</span>,   []);
<span class="keyword">if</span> nargin &amp;&amp; ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
<span class="keyword">end</span>

<span class="keyword">if</span> nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
<span class="keyword">else</span>
    gui_mainfcn(gui_State, varargin{:});
<span class="keyword">end</span>
<span class="comment">% End initialization code - DO NOT EDIT</span>


<span class="comment">% --- Executes just before dfmri is made visible.</span>
<span class="keyword">function</span> dfmri_OpeningFcn(hObject, eventdata, handles, varargin)
<span class="comment">% This function has no output args, see OutputFcn.</span>
<span class="comment">% hObject    handle to figure</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% varargin   command line arguments to dfmri (see VARARGIN)</span>
<span class="comment">% Choose default command line output for dfmri</span>
<span class="comment">% global currentlyOpen;</span>
handles.vararginBackup = varargin;
handles.hObjectBackup = hObject;
handles.eventdataBackup = eventdata;
handles.handlesBackup = handles;

set(handles.goAbortRoiSelection,<span class="string">'Visible'</span>, <span class="string">'off'</span>);

set(handles. figure1, <span class="string">'Name'</span>, <span class="string">'Analyze4D'</span>);
handles.output = hObject;
<span class="comment">% add defaults at start%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
handles.scanData.data                           = [];
handles.scanData.header                         = [];
handles.displayProperties.view                  = 1;
handles.displayProperties.mosaicZoomOn          = 0;
handles.displayProperties.startPoint            = 1;
handles.displayProperties.endPoint              = 1;
handles.displayProperties.brightness            = 1000;
handles.displayProperties.contrast              = 0;
handles.displayProperties.mosaicColormap        = gray;
handles.displayProperties.gridColor             = [1 1 1]*1;
handles.displayProperties.tileLabelColor        = [1 1 1]*0.9;
handles.displayProperties.gridOn                = 1;
handles.displayProperties.tileLabelOn           = 1;
handles.displayProperties.interScanPause        = 0.001;
handles.designMatrix.onsets                     = [];
handles.designMatrix.durations                  = [];
handles.designMatrix.offset                     = 0;
handles.designMatrix.colormap                   = jet;
handles.designMatrix.conditionCount             = 0;
handles.designMatrix.minY                       = -1;
handles.designMatrix.maxY                       = 1;
handles.mosaicHandle                            = [];
handles.plotHandle                              = [];
handles.toolBoxOpenAlready                      = 1;
handles.roi.roiColor                            = [1 1 1];
handles.roi.roiData                             = []; <span class="comment">% contains mask</span>
handles.roi.roiHandle                           = [];
handles.roi.roiHandle.pAxial                    = [];
handles.roi.roiHandle.pCor                      = [];
handles.roi.roiHandle.pSag                      = [];
handles.roi.roiData.imgSag= [];
handles.roi.roiData.imgCor= [];
handles.roi.roiData.imgAxial= [];
handles.roi.roiMaskSag                          = [];
handles.roi.roiMaskCor                          = [];
handles.roi.roiMaskAxial                        = [];
handles.roi.plotDataMean                        = [];
handles.roi.plotData                            = [];
handles.roi.plotDataMeanDetrended               = [];
handles.roi.plotDataDetrended                   = [];
handles.roi.maxYDetrended                       = [];
handles.roi.minYDetrended                       = [];
handles.roi.maxY                                = [];
handles.roi.minY                                = [];
handles.img2Coords.axial                        = [];
handles.img2Coords.sagittal                     = [];
handles.img2Coords.coronal                      = [];
handles.maskData.data                           = [];
handles.motionRegressors                        = [];
handles.aalMask                                 = []; <span class="comment">%contains the entire aal Mask without any thresholding</span>
handles.aalMask.isActive                        = 0; <span class="comment">% a flag to indicate if the AAL mask is active</span>
handles.pauseButtonPressed                      = 0;
handles.mask.chosenTruecolorColormap            = <span class="string">'None'</span>;
<span class="keyword">global</span> lineWidth lineColor;
lineColor                                       = [1 1 1];
lineWidth                                       = 1.0;

axes(handles.mosaicAxes);
<span class="comment">% cla(handles.mosaicAxes);</span>
axes(handles.plotAxes);
<span class="comment">% cla(handles.plotAxes);</span>
<span class="comment">% plot(1:10,zeros(1,10));</span>
<span class="comment">% Define Globals pertaining to mosaic movie panel</span>
<span class="keyword">global</span> currentScan pauseData reset interScanPause playData firstScanLastScanOn;
playData                                       = 0;
currentScan                                    = 0;
reset                                          = 0;
pauseData                                      = 0;
interScanPause                                 = 0.00001;
firstScanLastScanOn                            = 0;
<span class="comment">% Define Globals pertaining to mosaic display properties panel</span>
<span class="keyword">global</span> tileLabelOn gridOn mosaicColormap brightness contrast brightnessContrastChanging;
tileLabelOn                                    = 1;
gridOn                                         = 1;
mosaicColormap                                 = jet;
brightness                                     = 1000;
contrast                                       = 0;
brightnessContrastChanging                     = 0;
<span class="keyword">global</span> xLimits yLimits
xLimits = [0 0];
yLimits = [0 0];

<span class="keyword">global</span> viewSwitching;
viewSwitching = [];

<span class="keyword">global</span> showSubtractionPlots;
showSubtractionPlots                            = 0;

<span class="keyword">global</span> overlayMask maskThreshold maskColor showMaskedVoxelsOnly;
maskThreshold                                   = 0.5;
maskColor                                       = [1 1 1];
showMaskedVoxelsOnly                            = 0;
overlayMask                                     = 0;

<span class="comment">%for Clickables legend</span>
<span class="keyword">global</span> plotAxesCl;
plotAxesCl = handles.plotAxes;

<span class="keyword">global</span> specialData; <span class="comment">% special data like tmaps and cmaps for which CLim should be set to auto</span>
specialData                                    = 0;

<span class="keyword">global</span> sliceLabelColor mosaicGridColor;
sliceLabelColor                                = [1 1 1];
mosaicGridColor                                = [1 1 1];

<span class="comment">% disable the visibity of certain items</span>
set(handles.selectNewAnatomicalRegions, <span class="string">'visible'</span>, <span class="string">'off'</span>);
set(handles.showMaskedVoxelsOnly, <span class="string">'Enable'</span>, <span class="string">'inactive'</span>);
set(handles.colormapTrueColorsStaticText, <span class="string">'visible'</span>, <span class="string">'off'</span>);
set(handles.colormapTrueColors, <span class="string">'visible'</span>, <span class="string">'off'</span>);
set(handles.trueColor, <span class="string">'Enable'</span>, <span class="string">'inactive'</span>, <span class="string">'ForegroundColor'</span>, [1 1 1]*0.7);

<span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>

<span class="comment">% Update handles structure</span>
guidata(hObject, handles);

<span class="comment">% change the software icon</span>
warning(<span class="string">'off'</span>,<span class="string">'MATLAB:HandleGraphics:ObsoletedProperty:JavaFrame'</span>);
jframe=get(handles.figure1,<span class="string">'javaframe'</span>);
st = dbstack(<span class="string">'-completenames'</span>);
path = st.file;
path = path(1:end-28);
jIcon=javax.swing.ImageIcon(fullfile(path,<span class="string">'assets'</span>,<span class="string">'a4d.png'</span>));
jframe.setFigureIcon(jIcon);

set(handles. statusString, <span class="string">'String'</span>, <span class="string">'Status: Please load data.....'</span>)

<span class="comment">% UIWAIT makes dfmri wait for user response (see UIRESUME)</span>
<span class="comment">% uiwait(handles.figure1);</span>

<span class="comment">% --- Outputs from this function are returned to the command line.</span>
<span class="keyword">function</span> varargout = dfmri_OutputFcn(hObject, eventdata, handles)
<span class="comment">% varargout  cell array for returning output args (see VARARGOUT);</span>
<span class="comment">% hObject    handle to figure</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Get default command line output from handles structure</span>
varargout{1} = handles.output;


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> importData_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to importData (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> dondersrtfMRI_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to dondersrtfMRI (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> rawDataBuffer_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to rawDataBuffer (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> pickMocoSeries_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to pickMocoSeries (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
[data, header]              = readFunctionalRealTimeMoco(1);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[data,m]        = prepareMosaicData(data, header);
<span class="comment">% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr</span>
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]<span class="keyword">...</span>
    = mosaic2VoxelsXScansVector(m);
<span class="comment">% data is the appended dataset</span>
<span class="comment">% m contains the location of annotations</span>
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,<span class="keyword">...</span>
    handles.mosaicAxes);
<span class="comment">% prepare to share the data among gui</span>
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
<span class="comment">%update data</span>
guidata(hObject, handles);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> pickPaceSeries_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to pickPaceSeries (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
[data, header]              = readFunctionalRealTimePace(1);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[data,m]        = prepareMosaicData(data, header);
<span class="comment">% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr</span>
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]<span class="keyword">...</span>
    = mosaic2VoxelsXScansVector(m)
<span class="comment">% data is the appended dataset</span>
<span class="comment">% m contains the location of annotations</span>
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,<span class="keyword">...</span>
    handles.mosaicAxes);
<span class="comment">% prepare to share the data among gui</span>
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
<span class="comment">%update data</span>
guidata(hObject, handles);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> pickAll_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to pickAll (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
[data, header]              = readFunctionalRealTimeUntouchedRaw(1);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[data,m]        = prepareMosaicData(data, header);
<span class="comment">% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr</span>
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]<span class="keyword">...</span>
    = mosaic2VoxelsXScansVector(m)
<span class="comment">% data is the appended dataset</span>
<span class="comment">% m contains the location of annotations</span>
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,<span class="keyword">...</span>
    handles.mosaicAxes);
<span class="comment">% prepare to share the data among gui</span>
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
<span class="comment">%update data</span>
guidata(hObject, handles);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> dicomFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to dicomFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> niftiFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to niftiFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> niftiFunctional3d_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to niftiFunctional3d (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% dfmri_OpeningFcn(handles.hObjectBackup, handles.eventdataBackup,...</span>
<span class="comment">%     handles.handlesBackup, handles.vararginBackup);</span>
<span class="comment">% hObject         = handles.hObjectBackup;</span>
<span class="comment">% eventdata       = handles.eventdataBackup;</span>
<span class="comment">% handles         = handles.handlesBackup;</span>

[data, header]              = readFunctionalNifti3d([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[data,m]        = prepareMosaicData(data, header);
<span class="comment">% data is the appended dataset</span>
<span class="comment">% m contains the location of annotations</span>
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,<span class="keyword">...</span>
    handles.mosaicAxes);
<span class="comment">% prepare to share the data among gui</span>
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
<span class="comment">%update data</span>
guidata(hObject, handles);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> niftiFunctional4d_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to niftiFunctional4d (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
[data, header]              = readFunctionalNifti4d([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[data,m]        = prepareMosaicData(data, header);
<span class="comment">% data is the appended dataset</span>
<span class="comment">% m contains the location of annotations</span>
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,<span class="keyword">...</span>
    handles.mosaicAxes);
<span class="comment">% prepare to share the data among gui</span>
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
<span class="comment">%update data</span>
guidata(hObject, handles);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> imaFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to imaFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% Read the data</span>
[data, header]              = readFunctionalIma([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[data,m]        = prepareMosaicData(data, header);
<span class="comment">% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr</span>
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]<span class="keyword">...</span>
    = mosaic2VoxelsXScansVector(m)
<span class="comment">% data is the appended dataset</span>
<span class="comment">% m contains the location of annotations</span>
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,<span class="keyword">...</span>
    handles.mosaicAxes);
<span class="comment">% prepare to share the data among gui</span>
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
<span class="comment">%update data</span>
guidata(hObject, handles);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> dcmFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to dcmFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> dicFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to dicFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> analyzeFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to analyzeFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
[data, header]              = readFunctionalAnalyze([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[data,m]        = prepareMosaicData(data, header);
<span class="comment">% data is the appended dataset</span>
<span class="comment">% m contains the location of annotations</span>
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,<span class="keyword">...</span>
    handles.mosaicAxes);
<span class="comment">% prepare to share the data among gui</span>
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
<span class="comment">%update data</span>
guidata(hObject, handles);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> brainVoyagerFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to brainVoyagerFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> afniFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to afniFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> mincFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to mincFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> Functional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to Functional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> specialData;
specialData                                    = 0; <span class="comment">% tmaps/ beta maps</span>



<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> anatomical_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to anatomical (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> maltabMatFunctional_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to maltabMatFunctional (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
[data, header]              = readFunctionalMatlab([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[data,m]        = prepareMosaicData(data, header);
<span class="comment">% data is the appended dataset</span>
<span class="comment">% m contains the location of annotations</span>
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,<span class="keyword">...</span>
    handles.mosaicAxes);
<span class="comment">% prepare to share the data among gui</span>
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
<span class="comment">%update data</span>
guidata(hObject, handles);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Functional data loaded'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> file_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to file (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> dicomAnatomical_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to dicomAnatomical (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> niftiAnatomical3d_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to niftiAnatomical3d (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> analyzeAnatomical_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to analyzeAnatomical (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> afniAnatomical_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to afniAnatomical (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> brainvoyagerAnatomical_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to brainvoyagerAnatomical (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> imaAnatomical_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to imaAnatomical (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> dcmAnatomical_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to dcmAnatomical (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> dicAnatomical_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to dicAnatomical (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> mask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to mask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> importMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to importMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> niftiMask3d_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to niftiMask3d (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> maskThreshold;
maskThreshold                   = 0.5;
set(handles.maskThresholdSlider,<span class="string">'Enable'</span>, <span class="string">'on'</span>);
set(handles.maskThresholdValue,<span class="string">'Enable'</span>, <span class="string">'on'</span>);
set(handles.maskThresholdSlider,<span class="string">'Value'</span>, maskThreshold);
set(handles.maskThresholdValue,<span class="string">'String'</span>, maskThreshold);
set(handles.selectNewAnatomicalRegions, <span class="string">'visible'</span>, <span class="string">'off'</span>);


<span class="keyword">if</span> isempty(handles.scanData.data)
    msgbox([<span class="string">'You must have the functional data loaded before you can load '</span><span class="keyword">...</span>
        <span class="string">'the mask. So first load the functional data and then load the '</span><span class="keyword">...</span>
        <span class="string">'mask data. Only then you will be able to see the mask overlayed '</span> <span class="keyword">...</span>
        <span class="string">'over your functional data. If you only want to view the mask data '</span><span class="keyword">...</span>
        <span class="string">'then load it as if it was a functional data. In that case, '</span> <span class="keyword">...</span>
        <span class="string">'just go to the File &gt; Import Data &gt; Functional ...'</span><span class="keyword">...</span>
        <span class="string">'and load it like you would do a regular functional scan. '</span><span class="keyword">...</span>
        <span class="string">'Pheew !!! That was a big warning.'</span>],<span class="keyword">...</span>
        <span class="string">'No functional data found'</span>, <span class="string">'warn'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
[maskData, maskHeader]      = readMaskNifti3d([]);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
<span class="comment">% prepare mask in all three views</span>
maskData(find(maskData== 0))= NaN;
mask                        = prepareMask(maskData, handles.m);
handles.maskData.data       = mask;
<span class="comment">% handles.maskData.header     = maskHeader;</span>
<span class="comment">% handles.maskm               = maskm;</span>
guidata(hObject, handles);

<span class="comment">% invoke overlay mask button</span>
set(handles.overlayMask, <span class="string">'Value'</span>, 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Mask loaded.'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> matlabMatMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to matlabMatMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> mask maskThreshold;
[a,b,mask,maskThreshold] = readMaskMatlab(1);
<span class="keyword">if</span> isempty(mask) <span class="comment">% if user has loaded a custom mask that he made himself then..</span>
    maskData = a;
    maskHeader = b;
    [maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
    maskData(find(maskData== 0))= NaN;

    <span class="comment">% prepare mask in all three views</span>
    mask                        = prepareMask(maskData, maskm);
    handles.maskData.data       = mask;
    maskThreshold               = 0.5;
    guidata(hObject, handles);

    <span class="comment">% invoke overlay mask button</span>
    set(handles.overlayMask, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.overlayMask;
    dfmri(<span class="string">'overlayMask_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Mask loaded.'</span>);

<span class="keyword">else</span>
    handles.maskData.data.maskAxial       = mask.maskAxial ;
    handles.maskData.data.maskSagittal       = mask.maskSagittal ;
    handles.maskData.data.maskCoronal       = mask.maskCoronal ;

    <span class="comment">% call overlay mask</span>
    set(handles.overlayMask, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.overlayMask;
    dfmri(<span class="string">'overlayMask_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));

    <span class="comment">% call slider threshold</span>
    set(handles.maskThresholdSlider, <span class="string">'Value'</span>, maskThreshold);
    guidata(hObject, handles);
    hObjectCall = handles.maskThresholdSlider;
    dfmri(<span class="string">'maskThresholdSlider_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Mask succesfully imported and applied.'</span>);
<span class="keyword">end</span>

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> afniMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to afniMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Mask loaded.'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> brainVoyagerMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to brainVoyagerMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Mask loaded.'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> exit_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to exit (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveDataMat_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveDataMat (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

d.header = handles.scanData.header;
numSlices = double(d.header.numSlices);
xRes      = double(d.header.xRes);
yRes      = double(d.header.yRes);
ending    = numSlices*xRes*yRes;
<span class="comment">%discard the zero padding</span>
d.data = handles.scanData.data(1 : ending, :);
<span class="comment">% desquarify</span>
<span class="keyword">if</span> exist(<span class="string">'handles.scanData.header.squarified'</span>,<span class="string">'var'</span>)
    <span class="keyword">if</span> handles.scanData.header.squarified
    d.data = desquarify(handles.scanData.header, d.data);
    <span class="keyword">end</span>
<span class="keyword">end</span>
[FileName,PathName,FilterIndex] = uiputfile(<span class="string">'*.mat'</span>);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Started saving masked ......Please be patient !!!!'</span>);


<span class="comment">% Construct a questdlg with three options</span>
choice = questdlg([<span class="string">'Do you want to save the header information as well '</span>,<span class="keyword">...</span>
    <span class="string">'alongwith the data? By saving header information, it will be easier '</span><span class="keyword">...</span>
    <span class="string">'for you to load the mask again in Analyze4D.'</span>], <span class="keyword">...</span>
    <span class="string">'Save options'</span>, <span class="keyword">...</span>
    <span class="string">'Yes, save the header information too (Recommended)'</span>,<span class="keyword">...</span>
    <span class="string">'No, just save the scan data. Don''t save the header information'</span>,<span class="keyword">...</span>
    <span class="string">'Yes, save the header information too (Recommended)'</span>);
<span class="comment">% Handle response</span>
<span class="keyword">switch</span> choice
    <span class="keyword">case</span> <span class="string">'Yes, save the header information too (Recommended)'</span>
        save(fullfile(PathName,FileName),<span class="string">'d'</span>);
    <span class="keyword">case</span> <span class="string">'No, just save the scan data. Don''t save the header information'</span>
        data = d.data;
        save(fullfile(PathName,FileName),<span class="string">'data'</span>);
<span class="keyword">end</span>



<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> print_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to print (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMatlabMatDataMasked_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMatlabMatDataMasked (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> mask;
<span class="keyword">if</span> isempty(mask)
    msgbox(<span class="string">'You must import a mask before you can save the functional data under the mask.'</span>, <span class="string">'No mask found !'</span>, <span class="string">'warn'</span>, <span class="string">'modal'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: '</span>);

<span class="comment">% if show maked voxels only is off, then turn it on to get the desired data</span>
<span class="comment">% and turn it off later</span>
showMaskedVoxelsOnlyStatus = get(handles.showMaskedVoxelsOnly, <span class="string">'Value'</span>);
<span class="keyword">if</span> showMaskedVoxelsOnlyStatus == 0
    set(handles.showMaskedVoxelsOnly, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.showMaskedVoxelsOnly;
    dfmri(<span class="string">'showMaskedVoxelsOnly_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>
<span class="comment">% convert the mask in the current views in binary</span>
<span class="keyword">if</span>  handles.displayProperties.view == 1
    binaryMask = mask.imgMaskedVoxelsOnlySagittal;
<span class="keyword">elseif</span>  handles.displayProperties.view == 2
    binaryMask = mask.imgMaskedVoxelsOnlyCoronal;
<span class="keyword">else</span>  <span class="comment">% handles.displayProperties.view == 3</span>
    binaryMask = mask.imgMaskedVoxelsOnlyAxial;
<span class="keyword">end</span>
    binaryMask(find(binaryMask)) = 1;
<span class="comment">% pick the ind of the masked voxels</span>
[handles.saveMaskedData.coordsSag handles.saveMaskedData.coordsCor handles.saveMaskedData.coordsAxial] = <span class="keyword">...</span>
    mosaic2VoxelsXScansVector(handles.m);
<span class="keyword">if</span>  handles.displayProperties.view == 1
    idx = handles.saveMaskedData.coordsSag(find(binaryMask));
<span class="keyword">elseif</span>  handles.displayProperties.view == 2
    idx = handles.saveMaskedData.coordsCor(find(binaryMask));
<span class="keyword">else</span>  <span class="comment">% handles.displayProperties.view == 3</span>
    idx = handles.saveMaskedData.coordsAxial(find(binaryMask));
<span class="keyword">end</span>
<span class="comment">% choose time courses of the masked voxels, set the rest to zero</span>
type = class(handles.scanData.data);
<span class="keyword">if</span> strcmp(type,<span class="string">'uint16'</span>)
    d.data = uint16(zeros(size(handles.scanData.data)));
<span class="keyword">else</span>
    d.data = single(zeros(size(handles.scanData.data)));
<span class="keyword">end</span>
d.data(idx,:) = handles.scanData.data(idx,:);
d.header = handles.scanData.header;

<span class="comment">%first discard the zero padded slices in the z-direction</span>
d.data = d.data(1 : d.header.numSlices * d.header.xRes * d.header.yRes, :);
<span class="keyword">if</span> handles.scanData.header.squarified
    d.data = desquarify(handles.scanData.header, d.data);
<span class="keyword">end</span>

[FileName,PathName,FilterIndex] = uiputfile(<span class="string">'*.mat'</span>);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Started saving masked data......Please be patient !!!!'</span>);
save(fullfile(PathName,FileName),<span class="string">'d'</span>);

<span class="comment">% return the show masked voxels only to its previous position</span>
<span class="keyword">if</span> showMaskedVoxelsOnlyStatus == 0
    set(handles.showMaskedVoxelsOnly, <span class="string">'Value'</span>, 0);
    guidata(hObject, handles);
    hObjectCall = handles.showMaskedVoxelsOnly;
    dfmri(<span class="string">'showMaskedVoxelsOnly_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Masked Functional Data has been successfully saved. !!!!'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> roi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to roi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveroi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveroi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> importRoi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to importRoi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> Movie_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to Movie (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> makeMosaicMovie_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to makeMosaicMovie (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> markers_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to markers (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> loadMarkers_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to loadMarkers (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMarkers_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMarkers (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMarkersToTextFile_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMarkersToTextFile (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMarkersToMatlabMatFile_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMarkersToMatlabMatFile (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> markersFromTextFile_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to markersFromTextFile (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> markersFromMatlabMat_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to markersFromMatlabMat (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> Untitled_1_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to Untitled_1 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> loadMotionRegressors_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to loadMotionRegressors (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% reads one motion regressor file</span>
handles.motionRegressors = readSPMStyledMotionRegressors(1);
guidata(hObject,handles);

<span class="comment">% plot motion regressors</span>
set(handles.plotMotionRegressors, <span class="string">'Value'</span>, 1);
guidata(hObject, handles);
hObject = handles.plotMotionRegressors;
dfmri(<span class="string">'plotMotionRegressors_Callback'</span>,hObject,eventdata,guidata(hObject));
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Motion regressors loaded.'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> Untitled_2_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to Untitled_2 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> detrendCurrentData_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to detrendCurrentData (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveDetrendedData_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveDetrendedData (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on slider movement.</span>
<span class="keyword">function</span> slider1_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to slider1 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'Value') returns position of slider</span>
<span class="comment">%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> slider1_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to slider1 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: slider controls usually have a light gray background.</span>
<span class="keyword">if</span> isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,[.9 .9 .9]);
<span class="keyword">end</span>


<span class="comment">% --- Executes on slider movement.</span>
<span class="keyword">function</span> contrastSlider_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to contrastSlider (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> contrast playData currentScan brightnessContrastChanging firstScanLastScanOn showSubtractionPlots;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
contrast = get(hObject, <span class="string">'Value'</span>);
brightnessContrastChanging = 1;
<span class="keyword">if</span> contrast == get(handles.contrastSlider,<span class="string">'Min'</span>);
    set(handles.contrastSlider,<span class="string">'Min'</span>, get(handles.contrastSlider,<span class="string">'Min'</span>)-500); <span class="comment">% double the limit if that doesnot help</span>
<span class="comment">%     msgbox('doubled the limmit');</span>
<span class="keyword">end</span>

set(handles.contrastValue,<span class="string">'String'</span>, num2str(contrast));
<span class="keyword">if</span> playData == 0 | ~firstScanLastScanOn;
    <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
        currentScan = 1;
    <span class="keyword">end</span>
    <span class="keyword">if</span> showSubtractionPlots
        handles.displayProperties. startPoint = currentScan-1;
        handles.displayProperties. endPoint = currentScan ;
    <span class="keyword">else</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    <span class="keyword">end</span>
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">end</span>
<span class="comment">% overlay ROI</span>
refreshROIOverlay(handles)

brightnessContrastChanging = 0;
<span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr the view changes</span>
interactivemouse <span class="string">off</span>;
interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>
<span class="comment">% Hints: get(hObject,'Value') returns position of slider</span>
<span class="comment">%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> contrastSlider_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to contrastSlider (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: slider controls usually have a light gray background.</span>
<span class="keyword">if</span> isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,[.9 .9 .9]);
<span class="keyword">end</span>



<span class="keyword">function</span> contrastValue_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to contrastValue (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> contrast currentScan playData;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
<span class="keyword">try</span>
    contrastValueFromUser = str2double(get(hObject,<span class="string">'String'</span>));
    contrast = contrastValueFromUser;
    <span class="keyword">if</span> playData == 0;
        <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
            currentScan = 1;
        <span class="keyword">end</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>
<span class="keyword">catch</span>
    msgbox(<span class="string">'Please enter a number'</span>);
<span class="keyword">end</span>
<span class="comment">% Hints: get(hObject,'String') returns contents of contrastValue as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of contrastValue as a double</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> contrastValue_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to contrastValue (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on slider movement.</span>
<span class="keyword">function</span> brightnessSlider_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to brightnessSlider (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> brightness playData currentScan brightnessContrastChanging firstScanLastScanOn showSubtractionPlots;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);

brightnessContrastChanging = 1; <span class="comment">% prevents the axis reset when brightness is changed</span>
brightness = get(hObject,<span class="string">'Value'</span>);
<span class="keyword">if</span> brightness == get(handles.brightnessSlider,<span class="string">'Max'</span>);
    set(handles.brightnessSlider,<span class="string">'Max'</span>, get(handles.brightnessSlider,<span class="string">'Max'</span>)+2000); <span class="comment">% double the limit if that doesnot help</span>
<span class="comment">%     msgbox('doubled the limmit');</span>
<span class="keyword">end</span>
set(handles.brightnessValue,<span class="string">'String'</span>, num2str(brightness));
<span class="keyword">if</span> playData == 0 | ~firstScanLastScanOn
    <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
        currentScan = 1;
    <span class="keyword">end</span>
    <span class="keyword">if</span> showSubtractionPlots
        handles.displayProperties. startPoint = currentScan-1;
        handles.displayProperties. endPoint = currentScan ;
    <span class="keyword">else</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    <span class="keyword">end</span>
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">end</span>
refreshROIOverlay(handles);
brightnessContrastChanging = 0;
<span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr the view changes</span>
interactivemouse <span class="string">off</span>;
interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>

<span class="comment">% Hints: get(hObject,'Value') returns position of slider</span>
<span class="comment">%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> brightnessSlider_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to brightnessSlider (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: slider controls usually have a light gray background.</span>
<span class="keyword">if</span> isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,[.9 .9 .9]);
<span class="keyword">end</span>



<span class="keyword">function</span> brightnessValue_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to brightnessValue (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> brightness playData currentScan;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
<span class="keyword">try</span>
brightnessValueFromUser = str2double(get(hObject,<span class="string">'String'</span>));
brightness = brightnessValueFromUser;
<span class="keyword">if</span> playData == 0;
    <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
        currentScan = 1;
    <span class="keyword">end</span>
    handles.displayProperties. startPoint = currentScan;
    handles.displayProperties. endPoint = currentScan;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">end</span>
<span class="keyword">catch</span>
    msgbox(<span class="string">'Please enter a number'</span>);
<span class="keyword">end</span>
<span class="comment">% Hints: get(hObject,'String') returns contents of brightnessValue as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of brightnessValue as a double</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> brightnessValue_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to brightnessValue (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in showMosaicGrid.</span>
<span class="keyword">function</span> showMosaicGrid_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to showMosaicGrid (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> gridOn currentScan playData;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
<span class="keyword">if</span> get(hObject,<span class="string">'Value'</span>) == 1
    gridOn = 1;
    <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
        currentScan = 1;
    <span class="keyword">end</span>
    <span class="keyword">if</span> playData == 0; <span class="comment">%if data is not playing then show the current scan only with toggle slice labels</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Mosiac grid is now ON'</span>);
<span class="keyword">else</span>
    gridOn = 0;
    <span class="keyword">if</span> playData == 0;
        <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
            currentScan = 1;
        <span class="keyword">end</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Mosiac grid is now OFF'</span>);
<span class="keyword">end</span>
refreshROIOverlay(handles);

<span class="comment">% invoke trueMaskcolor</span>
<span class="keyword">if</span> get(handles.overlayMask,<span class="string">'Value'</span>) &amp;&amp; get(handles.trueColor,<span class="string">'Value'</span>)
    set(handles.trueColor, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.trueColor;
    dfmri(<span class="string">'trueColor_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>

<span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>
guidata(hObject,handles);


<span class="comment">% --- Executes on button press in pushbutton1.</span>
<span class="keyword">function</span> pushbutton1_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to pushbutton1 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in customizeMosaicGridColor.</span>
<span class="keyword">function</span> customizeMosaicGridColor_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to customizeMosaicGridColor (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> mosaicGridColor currentScan playData;
mosaicGridColor = uicolorpicker;
set(handles.mosaicGridColorBox,<span class="string">'BackgroundColor'</span>,mosaicGridColor);
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
<span class="keyword">if</span> get(hObject,<span class="string">'Value'</span>) == 1
    gridOn = 1;
    <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
        currentScan = 1;
    <span class="keyword">end</span>
    <span class="keyword">if</span> playData == 0; <span class="comment">%if data is not playing then show the current scan only with toggle slice labels</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>
<span class="keyword">else</span>
    gridOn = 0;
    <span class="keyword">if</span> playData == 0;
        <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
            currentScan = 1;
        <span class="keyword">end</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>
<span class="keyword">end</span>
refreshROIOverlay(handles);
<span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>
guidata(hObject,handles);



<span class="comment">% --- Executes on button press in showSliceLabels.</span>
<span class="keyword">function</span> showSliceLabels_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to showSliceLabels (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of showSliceLabels</span>
<span class="keyword">global</span> tileLabelOn currentScan playData;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
<span class="keyword">if</span> get(hObject,<span class="string">'Value'</span>) == 1
    tileLabelOn = 1;
    <span class="keyword">if</span> playData == 0; <span class="comment">%if data is not playing then show the current scan only with toggle slice labels</span>
        <span class="keyword">if</span> currentScan == 0 <span class="comment">% handles the case when reset has been set and the currentScan is set to zero</span>
            currentScan = 1;
        <span class="keyword">end</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>
        set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Slice numbers are now visible on each slice'</span>);
<span class="keyword">else</span>
    tileLabelOn = 0;
    <span class="keyword">if</span> playData == 0;
        <span class="keyword">if</span> currentScan == 0
            currentScan = 1;
        <span class="keyword">end</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Slice numbering has been disabled'</span>);
<span class="keyword">end</span>
refreshROIOverlay(handles);

<span class="comment">% invoke trueMaskcolor</span>
<span class="keyword">if</span> get(handles.overlayMask,<span class="string">'Value'</span>) &amp;&amp; get(handles.trueColor,<span class="string">'Value'</span>)
    set(handles.trueColor, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.trueColor;
    dfmri(<span class="string">'trueColor_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>

<span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>

guidata(hObject,handles);

<span class="comment">% --- Executes on button press in customizeSliceLabelColor.</span>
<span class="keyword">function</span> customizeSliceLabelColor_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to customizeSliceLabelColor (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> sliceLabelColor currentScan playData;
sliceLabelColor = uicolorpicker;
set(handles.sliceLabelColorBox,<span class="string">'BackgroundColor'</span>,sliceLabelColor);
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
<span class="keyword">if</span> get(hObject,<span class="string">'Value'</span>) == 1
    gridOn = 1;
    <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
        currentScan = 1;
    <span class="keyword">end</span>
    <span class="keyword">if</span> playData == 0; <span class="comment">%if data is not playing then show the current scan only with toggle slice labels</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>
<span class="keyword">else</span>
    gridOn = 0;
    <span class="keyword">if</span> playData == 0;
        <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
            currentScan = 1;
        <span class="keyword">end</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>
<span class="keyword">end</span>
refreshROIOverlay(handles);
<span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>
guidata(hObject,handles);

<span class="comment">% --- Executes on button press in captureRestorePoint.</span>
<span class="keyword">function</span> captureRestorePoint_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to captureRestorePoint (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in pushbutton5.</span>
<span class="keyword">function</span> pushbutton5_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to pushbutton5 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in loadRestorePointMosaic.</span>
<span class="keyword">function</span> loadRestorePointMosaic_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to loadRestorePointMosaic (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
interactivemouse <span class="string">restore</span>;

<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in captureRestorePointPlot.</span>
<span class="keyword">function</span> captureRestorePointPlot_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to captureRestorePointPlot (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> axesNumber;
axesNumber = 1;
interactivemouse <span class="string">reset</span>;
<span class="comment">% --- Executes on button press in turnOnZoomAndPanMosaic.</span>
<span class="keyword">function</span> turnOnZoomAndPanMosaic_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to turnOnZoomAndPanMosaic (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% AXES(handles.mosaicHandle);</span>
<span class="comment">% interactivemouse(handles.mosaicHandle);</span>
<span class="comment">% set the current axes as the mosiac axes</span>
<span class="keyword">global</span> xLimits yLimits;
<span class="keyword">if</span> (get(hObject,<span class="string">'Value'</span>) == get(hObject,<span class="string">'Max'</span>))
    <span class="comment">% if no data is present then do not let user toggle the button</span>
    <span class="keyword">if</span> isempty(handles.scanData.data)
        msgbox(<span class="string">'Nothing to zoom into Your highness!!. Please first load any data by going to the File menu.'</span>,<span class="string">'Warning'</span>,<span class="string">'warn'</span>,<span class="string">'modal'</span>);
        set(handles.turnOnZoomAndPanMosaic, <span class="string">'Value'</span>, 0);
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    <span class="comment">% Turn off plot axes</span>
    set(handles.turnOnZoomAndPanPlot, <span class="string">'Value'</span>, 0);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri(<span class="string">'turnOnZoomAndPanPlot_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));

    <span class="comment">% turn on mosaic axes</span>
    set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
    set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
    guidata(hObject,handles);
    interactivemouse <span class="string">on</span> ;
    handles.displayProperties.mosaicZoomOn = 1; <span class="comment">% a hack to Keep interactivemouse on whenevr the view changes</span>

<span class="keyword">else</span>
    <span class="comment">% Checkbox is unchecked-take appropriate action</span>
    set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>); <span class="comment">% restore the other axes</span>
    set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>); <span class="comment">% restore the other axes</span>
    guidata(hObject,handles);
    <span class="keyword">try</span>
        interactivemouse <span class="string">off</span> ;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    handles.displayProperties.mosaicZoomOn          = 0; <span class="comment">% a hack to Keep interactivemouse on whenevr the view changes</span>
    set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>); <span class="comment">% restore the other axes</span>
    set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>); <span class="comment">% restore the other axes</span>
<span class="keyword">end</span>
<span class="comment">% Hint: get(hObject,'Value') returns toggle state of turnOnZoomAndPanMosaic</span>
guidata(hObject,handles);

<span class="comment">% --- Executes on button press in turnOnZoomAndPanPlot.</span>
<span class="keyword">function</span> turnOnZoomAndPanPlot_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to turnOnZoomAndPanPlot (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> xLimits yLimits;

<span class="keyword">if</span> (get(hObject,<span class="string">'Value'</span>) == get(hObject,<span class="string">'Max'</span>))
    <span class="comment">% if no data is present then do not let user toggle the button</span>
    <span class="keyword">if</span> isempty(handles.motionRegressors) &amp; isempty(handles.roi.plotData)
        msgbox(<span class="string">'Nothing to zoom into Your highness!!. Please select an ROI in the Spatio-Temporal Analysis panel or Load SPM motion regressors. '</span>,<span class="string">'Warning'</span>,<span class="string">'warn'</span>,<span class="string">'modal'</span>);
        set(handles.turnOnZoomAndPanPlot, <span class="string">'Value'</span>, 0);
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    <span class="comment">% Turn off plot axes</span>
    set(handles.turnOnZoomAndPanMosaic, <span class="string">'Value'</span>, 0);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanMosaic;
    dfmri(<span class="string">'turnOnZoomAndPanMosaic_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));

    <span class="comment">% turn on mosaic axes</span>
    set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
    set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
    guidata(hObject,handles);
    interactivemouse <span class="string">on</span> ;
    handles.displayProperties.plotZoomOn = 1; <span class="comment">% a hack to Keep interactivemouse on whenevr the view changes</span>

<span class="keyword">else</span>
    <span class="comment">% Checkbox is unchecked-take appropriate action</span>
    set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>); <span class="comment">% restore the other axes</span>
    set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>); <span class="comment">% restore the other axes</span>
    guidata(hObject,handles);
    <span class="keyword">try</span>
        interactivemouse <span class="string">off</span> ;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    handles.displayProperties.plotZoomOn          = 0; <span class="comment">% a hack to Keep interactivemouse on whenevr the view changes</span>
    set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>); <span class="comment">% restore the other axes</span>
    set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>); <span class="comment">% restore the other axes</span>
<span class="keyword">end</span>
<span class="comment">% Hint: get(hObject,'Value') returns toggle state of turnOnZoomAndPanMosaic</span>
guidata(hObject,handles);


<span class="comment">% --- Executes on button press in loadRestorePointPlot.</span>
<span class="keyword">function</span> loadRestorePointPlot_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to loadRestorePointPlot (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> axesNumber;
axesNumber = 1;
interactivemouse <span class="string">restore</span>;

<span class="comment">% --- Executes on button press in play.</span>
<span class="keyword">function</span> play_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to play (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> currentScan playData pauseData xLimits yLimits firstScanLastScanOn;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
<span class="comment">% Play the data from start it the all the scans have been played and the</span>
<span class="comment">% play button is pressed again</span>
firstScanLastScanOn = 0;
<span class="keyword">if</span> currentScan == handles.scanData.header.numScans;
    currentScan = 0;
<span class="keyword">end</span>
<span class="comment">% otherwise proceed as normal</span>
originalColor = [0.3490    0.2000    0.3294]; <span class="comment">%get(hObject, 'BackgroundColor');</span>
playData                                = 1;
set(hObject,<span class="string">'BackgroundColor'</span>, [0.5137    0.3804    0.4824]);
handles.displayProperties.startPoint    = currentScan + 1;
currentScan = currentScan + 1;
handles.displayProperties.endPoint      = handles.scanData.header.numScans;
guidata(hObject,handles);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Playing data..... Press Pause to stop playing.'</span>);
[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
    handles.displayProperties, handles.mosaicAxes);
playData                                = 0;
set(hObject, <span class="string">'BackgroundColor'</span>, originalColor);
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr the view changes</span>
    <span class="keyword">try</span>
        interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Done.'</span> );
refreshROIOverlay(handles);

<span class="comment">% --- Executes on button press in pause.</span>
<span class="keyword">function</span> pause_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to pause (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> pauseData playData;
<span class="keyword">if</span> playData <span class="comment">% if something is playing then pause it</span>
    set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
    set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
    pauseData = 1;
    playData  = 0;
    <span class="keyword">if</span> handles.displayProperties.mosaicZoomOn
        handles.displayProperties.mosaicZoomOn
        <span class="keyword">try</span>
            interactivemouse <span class="string">off</span>;
        <span class="keyword">catch</span>
        <span class="keyword">end</span>
        interactivemouse <span class="string">on</span>;
    <span class="keyword">end</span>
    guidata(hObject,handles)
<span class="keyword">else</span>
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Nothing to pause.'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
refreshROIOverlay(handles);

<span class="comment">% --- Executes on button press in reset.</span>
<span class="keyword">function</span> reset_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to reset (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> currentScan playData;
currentScan                             = 0;
playData                                = 0; <span class="comment">% pauseData if already running play</span>
handles.displayProperties.startPoint    = currentScan + 1;
handles.displayProperties.endPoint      = handles.displayProperties.startPoint;
guidata(hObject,handles);
[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
    handles.displayProperties, handles.mosaicAxes);
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Resetted to Volume 1.'</span>);
refreshROIOverlay(handles);

<span class="comment">% --- Executes on button press in firstScanLastScanLoop.</span>
<span class="keyword">function</span> firstScanLastScanLoop_Callback(hObject, eventdata, handles)
<span class="keyword">global</span> firstScanLastScanOn currentScan playData;
<span class="keyword">if</span> ~isempty(handles.scanData.data)
    button_state = get(hObject,<span class="string">'Value'</span>);
    originalColor = [0.3490    0.2000    0.3294];

    <span class="keyword">while</span> button_state == get(hObject,<span class="string">'Max'</span>)
        set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Playing the data in first Scan-last Scan loop.'</span>);
        set(hObject,<span class="string">'BackgroundColor'</span>,[0.5137    0.3804    0.4824] );
        <span class="comment">% Toggle button is pressed-take appropriate action</span>
        firstScanLastScanOn = 1;
        playData             = 1;
        firstScanLastScanData = handles.scanData.data(:,[1 end]);
        currentScan = 0;
        handles.displayProperties.startPoint    = currentScan + 1;
        handles.displayProperties.endPoint      = currentScan + 2;
        [mosaicHandle]  = mosaicLoop(firstScanLastScanData, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
        currentScan = 0;
        button_state = get(hObject,<span class="string">'Value'</span>);
    <span class="keyword">end</span>
    set(hObject,<span class="string">'BackgroundColor'</span>,originalColor);
    firstScanLastScanOn = 0;
    guidata(hObject,handles);
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Stopped first Scan-last Scan loop.'</span>);

    <span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
    <span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
        <span class="keyword">try</span>
            interactivemouse <span class="string">off</span>;
        <span class="keyword">catch</span>
        <span class="keyword">end</span>
        interactivemouse <span class="string">on</span>;
    <span class="keyword">end</span>
    refreshROIOverlay(handles);
<span class="keyword">else</span> <span class="comment">%if scanData is emtpy, then retun</span>
    set(handles.firstScanLastScanLoop, <span class="string">'Value'</span>, 0);
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: You must load at least two functional scans first for this option to work.'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>

<span class="comment">% --- Executes on selection change in interescanPauseIntervalPopupMenu.</span>
<span class="keyword">function</span> interescanPauseIntervalPopupMenu_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to interescanPauseIntervalPopupMenu (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% global interScanPause;</span>
<span class="comment">% contents            = cellstr(get(hObject,'String')) ;</span>
<span class="comment">% contents{get(hObject,'Value')}</span>
<span class="comment">% interScanPause      = contents;</span>
<span class="comment">% % hack to turn on the zoom functionality after this button is pressed</span>
<span class="comment">% if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed</span>
<span class="comment">%     try</span>
<span class="comment">%     interactivemouse off;</span>
<span class="comment">%     catch</span>
<span class="comment">%     end</span>
<span class="comment">%     interactivemouse on;</span>
<span class="comment">% end</span>
<span class="comment">% Hints: contents = cellstr(get(hObject,'String')) returns interescanPauseIntervalPopupMenu contents as cell array</span>
<span class="comment">%        contents{get(hObject,'Value')} returns selected item from interescanPauseIntervalPopupMenu</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> interescanPauseIntervalPopupMenu_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to interescanPauseIntervalPopupMenu (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: popupmenu controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in overlayMask.</span>
<span class="keyword">function</span> overlayMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to overlayMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> overlayMask mask currentScan showSubtractionPlots maskThreshold showMaskedVoxelsOnly;

<span class="keyword">if</span> isempty(handles.scanData.data) &amp; get(hObject, <span class="string">'Value'</span>)
    msgbox([<span class="string">'You must have functional data loaded before you can overlay '</span><span class="keyword">...</span>
        <span class="string">'mask over it. So first load the functional data and then load the '</span><span class="keyword">...</span>
        <span class="string">'mask data. Only then you will be able to see the mask overlayed '</span> <span class="keyword">...</span>
        <span class="string">'over your functional data.'</span>], <span class="string">'No functional data found'</span>, <span class="string">'warn'</span>);
    set(handles.overlayMask,<span class="string">'Value'</span>,0);
    <span class="keyword">return</span>;
<span class="keyword">end</span>

<span class="keyword">if</span> get(hObject, <span class="string">'Value'</span>) == 1

    <span class="comment">% turn the trueColor buttons on</span>
    set(handles.trueColor, <span class="string">'Enable'</span>, <span class="string">'on'</span>, <span class="string">'ForegroundColor'</span>, [1 1 1]);

    <span class="keyword">if</span> isempty(handles.maskData.data)
        msgbox([<span class="string">'No mask found. Please go the the Mask menu and load the mask '</span> <span class="keyword">...</span>
            <span class="string">'data. The mask should be in the same space as the data '</span> <span class="keyword">...</span>
            <span class="string">'itself. This means that if you have created Gray, White or CSF '</span><span class="keyword">...</span>
            <span class="string">'masks, then you need to reslice these masks to your functional '</span><span class="keyword">...</span>
            <span class="string">'data and then load them.'</span>], <span class="string">'Error'</span>, <span class="string">'warn'</span>);
        set(handles.overlayMask, <span class="string">'Value'</span>, 0);
        <span class="keyword">return</span>;
    <span class="keyword">else</span>
        mask = handles.maskData.data;
    <span class="keyword">end</span>
    overlayMask = 1;
    set(handles.showMaskedVoxelsOnly, <span class="string">'Enable'</span>, <span class="string">'on'</span>);
    set(handles.showMaskedVoxelsOnly, <span class="string">'ForegroundColor'</span>, [1 1 1]);

    set(handles.maskThresholdValue, <span class="string">'String'</span> , num2str(maskThreshold));
    <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
        currentScan = 1;
    <span class="keyword">end</span>
    <span class="keyword">if</span> showSubtractionPlots
<span class="comment">%         msgbox('turn off subtraction plots')</span>
        set(handles.showSubtractionPlots, <span class="string">'Value'</span>, 0);
        hObjectCall = handles.showSubtractionPlots;
        dfmri(<span class="string">'showSubtractionPlots_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall))
    <span class="keyword">else</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    <span class="keyword">end</span>
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="comment">%     if get(handles.trueColor, 'Value') % if true colors is on then</span>
<span class="comment">%         % invoke trueMaskcolor</span>
<span class="comment">%         set(handles.trueColor, 'Value', 1);</span>
<span class="comment">%         hObjectCall = handles.trueColor;</span>
<span class="comment">%         dfmri('trueColor_Callback',hObjectCall,eventdata,guidata(hObjectCall));</span>
<span class="comment">%     end</span>
<span class="keyword">else</span>
    overlayMask = 0;
    showMaskedVoxelsOnly = 0;
    mask = handles.maskData.data;
    <span class="comment">% turn off trueColor button</span>
    set(handles.trueColor, <span class="string">'Enable'</span>, <span class="string">'on'</span>,<span class="string">'Value'</span>,1, <span class="string">'ForegroundColor'</span>, [1 1 1]);

    <span class="comment">% disable control</span>
    set(handles.showMaskedVoxelsOnly, <span class="string">'ForegroundColor'</span>, [1 1 1]*0.7);
    set(handles.showMaskedVoxelsOnly, <span class="string">'Value'</span>, 0);
    set(handles.showMaskedVoxelsOnly, <span class="string">'Enable'</span>, <span class="string">'inactive'</span>);

    <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
        currentScan = 1;
    <span class="keyword">end</span>
    <span class="keyword">if</span> showSubtractionPlots
        <span class="comment">%msgbox('turn off subtraction plots');</span>
        set(handles.showSubtractionPlots, <span class="string">'Value'</span>, 0);
        hObjectCall = handles.showSubtractionPlots;
        dfmri(<span class="string">'showSubtractionPlots_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="comment">%         set(handles.showSubtractionPlots, 'Value', 0);</span>
    <span class="keyword">else</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    <span class="keyword">end</span>

    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">end</span>


<span class="comment">% overlay ROI</span>
<span class="keyword">if</span> ~isempty(handles.roi.roiData)
    <span class="keyword">if</span> handles.displayProperties.view == 1
        [posX posY] = find(handles.roi.roiData.imgSag);
        pSag = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">elseif</span> handles.displayProperties.view == 2
        [posX posY] = find(handles.roi.roiData.imgCor);
        pCor = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">else</span>
        [posX posY] = find(handles.roi.roiData.imgAxial);
        pAxial = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
        interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>

<span class="comment">% --- Executes on slider movement.</span>
<span class="keyword">function</span> maskThresholdSlider_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to maskThresholdSlider (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'Value') returns position of slider</span>
<span class="comment">%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider</span>
<span class="keyword">global</span> mask currentScan showSubtractionPlots maskThreshold;
<span class="keyword">if</span> get(handles.overlayMask, <span class="string">'Value'</span>) == 1
    <span class="comment">% if there is ROI data then clear it when the slider is moved</span>
    <span class="keyword">if</span> ~isempty(handles.roi.roiData)
        Object = handles.clearAllRois;
        dfmri(<span class="string">'clearAllRois_Callback'</span>,Object,eventdata,guidata(Object));
    <span class="keyword">end</span>

    maskThreshold = get(hObject,<span class="string">'Value'</span>) ;
    set(handles.maskThresholdValue, <span class="string">'String'</span> , num2str(maskThreshold));
    mask = handles.maskData.data;
    <span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
        currentScan = 1;
    <span class="keyword">end</span>
    <span class="keyword">if</span> showSubtractionPlots
        msgbox(<span class="string">'turn off subtraction plots'</span>)
    <span class="keyword">else</span>
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    <span class="keyword">end</span>
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
    <span class="comment">% invoke trueMaskcolor</span>
    <span class="keyword">if</span> get(handles.trueColor, <span class="string">'Value'</span>)
        hObjectCall = handles.trueColor;
        dfmri(<span class="string">'trueColor_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    <span class="keyword">end</span>
<span class="comment">%  refreshROIOverlay(handles);</span>
    <span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
        <span class="keyword">try</span>
            interactivemouse <span class="string">off</span>;
        <span class="keyword">catch</span>
        <span class="keyword">end</span>
        interactivemouse <span class="string">on</span>;
    <span class="keyword">end</span>
<span class="keyword">end</span>



<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> maskThresholdSlider_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to maskThresholdSlider (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: slider controls usually have a light gray background.</span>
<span class="keyword">if</span> isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,[.9 .9 .9]);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in customizeMaskColor.</span>
<span class="keyword">function</span> customizeMaskColor_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to customizeMaskColor (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="keyword">global</span> maskColor;
maskColor = uicolorpicker;
set(handles.maskColorBox, <span class="string">'BackgroundColor'</span>, maskColor);
dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
guidata(hObject,handles);

<span class="comment">% --- Executes on button press in showMaskedVoxelsOnly.</span>
<span class="keyword">function</span> showMaskedVoxelsOnly_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to showMaskedVoxelsOnly (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> showMaskedVoxelsOnly;

<span class="keyword">if</span> get(hObject,<span class="string">'Value'</span>) == 1
<span class="comment">%     if get(handles.overlayMask,'Value') == 1</span>
<span class="comment">%         set(handles.showMaskedVoxelsOnly, 'Enable', 'off');</span>
<span class="comment">%         return;</span>
<span class="comment">%     end</span>
    showMaskedVoxelsOnly = 1;
    dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
    set(handles.customizeMaskColor, <span class="string">'Enable'</span>,<span class="string">'inactive'</span>);
<span class="keyword">else</span>
    showMaskedVoxelsOnly = 0;
    hObject = handles.overlayMask;
    dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
    set(handles.customizeMaskColor, <span class="string">'Enable'</span>,<span class="string">'on'</span>);

<span class="keyword">end</span>
[x y] = getAxesLimits(handles.mosaicAxes);
setAxesLimits(handles.mosaicAxes, x, y);
<span class="comment">% Hint: get(hObject,'Value') returns toggle state of showMaskedVoxelsOnly</span>


<span class="comment">% --- Executes on button press in selectVovelsInARectangularRoi.</span>
<span class="keyword">function</span> selectVovelsInARectangularRoi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to selectVovelsInARectangularRoi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in selectOneVoxelAtATime.</span>
<span class="keyword">function</span> selectOneVoxelAtATime_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to selectOneVoxelAtATime (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in checkbox8.</span>
<span class="keyword">function</span> checkbox8_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to checkbox8 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of checkbox8</span>


<span class="comment">% --- Executes on selection change in listbox3.</span>
<span class="keyword">function</span> listbox3_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to listbox3 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: contents = cellstr(get(hObject,'String')) returns listbox3 contents as cell array</span>
<span class="comment">%        contents{get(hObject,'Value')} returns selected item from listbox3</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> listbox3_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to listbox3 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: listbox controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in radiobutton3.</span>
<span class="keyword">function</span> radiobutton3_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to radiobutton3 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of radiobutton3</span>


<span class="comment">% --- Executes on button press in radiobutton4.</span>
<span class="keyword">function</span> radiobutton4_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to radiobutton4 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of radiobutton4</span>


<span class="comment">% --- Executes on selection change in nVoxels.</span>
<span class="keyword">function</span> nVoxels_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to nVoxels (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: contents = cellstr(get(hObject,'String')) returns nVoxels contents as cell array</span>
<span class="comment">%        contents{get(hObject,'Value')} returns selected item from nVoxels</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> nVoxels_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to nVoxels (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: popupmenu controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in colorizeRoiVoxels.</span>
<span class="keyword">function</span> colorizeRoiVoxels_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to colorizeRoiVoxels (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% Hint: get(hObject,'Value') returns toggle state of colorizeRoiVoxels</span>


<span class="comment">% --- Executes on button press in clearAllRois.</span>
<span class="keyword">function</span> clearAllRois_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to clearAllRois (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> currentScan showSubtractionPlots xLimits yLimits;
handles.roi.roiHandle                           = [];
handles.roi.roiHandle.pSag                      = [];
handles.roi.roiHandle.pCor                      = [];
handles.roi.roiHandle.pAxial                    = [];
handles.roi.roiData.imgSag                      = [];
handles.roi.roiData.imgCor                      = [];
handles.roi.roiData.imgAxial                    = [];
handles.roi.roiMaskSag                         = [];
handles.roi.roiMaskCor                         = [];
handles.roi.roiMaskAxial                         = [];
handles.img2Coords.sagittal                     = [];
handles.img2Coords.coronal                      = [];
handles.img2Coords.axial                        = [];
handles.roi.plotDataMean                        = [];
handles.roi.plotData                            = [];
handles.roi.maxY                                = [];
handles.roi.minY                                = [];
handles.roi.roiData                             = [];
handles.roi.plotDataMeanDetrended               = [];
handles.roi.plotDataDetrended                   = [];
handles.roi.maxYDetrended                       = [];
handles.roi.minYDetrended                       = [];
guidata(hObject, handles);

<span class="keyword">if</span> get(handles.turnOnZoomAndPanPlot,<span class="string">'Value'</span>)
    set(handles.turnOnZoomAndPanPlot, <span class="string">'Value'</span>, 0);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri(<span class="string">'turnOnZoomAndPanPlot_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>

<span class="keyword">if</span> currentScan == 0 <span class="comment">% handle the situation when reset has been pressed and the currentScan =0</span>
    currentScan = 1;
<span class="keyword">end</span>
<span class="keyword">if</span> showSubtractionPlots
    msgbox(<span class="string">'turn off subtraction plots'</span>)
<span class="keyword">else</span>
    handles.displayProperties. startPoint = currentScan;
    handles.displayProperties. endPoint = currentScan;
<span class="keyword">end</span>


<span class="comment">% Clear the mosaic</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);


<span class="comment">%get the axis state</span>
xLimits = get(handles.mosaicAxes,<span class="string">'XLim'</span>); <span class="comment">% this prevent the zoom state of plot to be copied to the zoom state of mosiac</span>
yLimits = get(handles.mosaicAxes,<span class="string">'YLim'</span>);

[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
    handles.displayProperties, handles.mosaicAxes);

<span class="comment">% Clear the plot axes with previously plotted ROI time series</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
cla(handles.plotAxes);

set(handles.plotAxes, <span class="string">'XLim'</span>, [0,1]);<span class="comment">% prevent loss of display the user has cleared all th roi and proceeds to select a new one</span>
set(handles.plotAxes, <span class="string">'YLim'</span>, [0,1]);

<span class="comment">% restore the control to mosaic</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);

<span class="keyword">if</span> get(handles.trueColor,<span class="string">'Value'</span>)
    <span class="comment">% invoke trueMaskcolor</span>
    hObjectCall = handles.trueColor;
    dfmri(<span class="string">'trueColor_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Colormap for the mask changed!'</span>);
<span class="keyword">end</span>

<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
        interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>

set(handles.statusString,<span class="string">'String'</span>,<span class="string">'Status: All ROIs cleared.'</span>);
guidata(hObject, handles);

<span class="comment">% --- Executes on button press in plotMotionRegressors.</span>
<span class="keyword">function</span> plotMotionRegressors_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to plotMotionRegressors (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">if</span> isempty(handles.motionRegressors) &amp; get(handles.plotMotionRegressors, <span class="string">'Value'</span>)
    set(handles.plotMotionRegressors, <span class="string">'Value'</span>,0);
    msgbox(<span class="string">'You have not loaded any motions regressors. Please go to the Motion Regressors menu and load the motion regressors.'</span>,<span class="string">'Are you kidding me !!!'</span>, <span class="string">'warn'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>); <span class="comment">% so that plot is in the plot axes</span>
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);

<span class="keyword">if</span> get(hObject,<span class="string">'Value'</span>)
    time        = handles.motionRegressors.time;
    x           = handles.motionRegressors.x;
    y           = handles.motionRegressors.y;
    z           = handles.motionRegressors.z;
    yaw         = handles.motionRegressors.yaw;
    pitch       =  handles.motionRegressors.pitch;
    roll        = handles.motionRegressors.roll;
    h = plot(handles.plotAxes, time,x, time,y, time,z, time,yaw,<span class="keyword">...</span>
        time,pitch, time,roll,<span class="string">'LineSmoothing'</span>,<span class="string">'on'</span>);
    <span class="comment">%     draggable(h);</span>
    set(handles.plotAxes,<span class="string">'Color'</span>,[0 0 0]); <span class="comment">% change the plot background to black</span>
    set(handles.plotAxes,<span class="string">'XLim'</span>,[1 numel(time)+ floor(numel(time)/6.5)]); <span class="comment">% change the plot background to black</span>
    set(h,<span class="string">'uicontextmenu'</span>,linecmenu);
    clickableLegend(handles.plotAxes, {<span class="string">'X Translation'</span>,<span class="string">'Y Translation'</span>,<span class="string">'Z Translation'</span>,<span class="string">'Yaw'</span>,<span class="string">'Pitch'</span>, <span class="string">'Roll'</span>}, <span class="string">'Location'</span>, <span class="string">'east'</span>);
<span class="keyword">else</span>
<span class="comment">%     cla(handles.plotAxes);</span>
    delete(allchild(handles.plotAxes))
<span class="keyword">end</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>); <span class="comment">% so that plot is in the plot axes</span>
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);

<span class="comment">% --- Executes on button press in showSubtractionPlots.</span>
<span class="keyword">function</span> showSubtractionPlots_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to showSubtractionPlots (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> playData firstScanLastScanOn currentScan  brightnessContrastChanging;
<span class="keyword">global</span> showSubtractionPlots;
<span class="keyword">if</span> (isempty(handles.scanData.data))
    <span class="keyword">if</span> get(handles.showSubtractionPlots, <span class="string">'Value'</span>)
        msgbox([<span class="string">'A Subtraction Plot is the difference image of two consecutive '</span><span class="keyword">...</span>
            <span class="string">'functional scans and is used to assess how much motion occured between '</span><span class="keyword">...</span>
            <span class="string">'two consecutive scans. Therefore, it is necessary to have functional data '</span><span class="keyword">...</span>
            <span class="string">'available for this option to work. So please first load your functional '</span><span class="keyword">...</span>
            <span class="string">'scans by going to File &gt; Import Data &gt; Functional. Once you have done '</span><span class="keyword">...</span>
            <span class="string">'that, you can activate this option.'</span>], <span class="string">'No functional data found'</span>, <span class="string">'warn'</span>);
     set(handles.showSubtractionPlots, <span class="string">'Value'</span>, 0);
     guidata(hObject,handles);
    <span class="keyword">end</span>
    <span class="keyword">return</span>;
<span class="keyword">end</span>

<span class="keyword">if</span> get(hObject,<span class="string">'Value'</span>)
    showSubtractionPlots                            = 1;
    firstScanLastScanOn                             = 1;
    brightnessContrastChanging                      = 1;
    tmp = currentScan;

    <span class="keyword">if</span> ~playData &amp; firstScanLastScanOn
        <span class="keyword">if</span> currentScan==0
            currentScan = currentScan +2;
        <span class="keyword">end</span>
        handles.displayProperties. startPoint = currentScan-1;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
            handles.displayProperties, handles.mosaicAxes);
    <span class="keyword">end</span>

    firstScanLastScanOn                             = 0;
    brightnessContrastChanging                      = 0;
    currentScan                                     = tmp;
<span class="keyword">else</span>
    showSubtractionPlots                            = 0;
    tmp = currentScan;
    <span class="comment">% restore the normal plot if the button is unpressed</span>
    <span class="keyword">if</span> currentScan == handles.scanData.header.numScans
        currentScan = currentScan -1;
    <span class="keyword">end</span>
    handles.displayProperties. startPoint = currentScan+1;
    handles.displayProperties. endPoint = currentScan+1 ;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
    currentScan = tmp;
<span class="keyword">end</span>
<span class="comment">% restore the interactivemouse</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of showSubtractionPlots</span>


<span class="comment">% --- Executes on button press in Abort.</span>
<span class="keyword">function</span> Abort_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to Abort (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in captureRestorePointMosaic.</span>
<span class="keyword">function</span> captureRestorePointMosaic_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to captureRestorePointMosaic (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> axesNumber;
axesNumber = 2;
interactivemouse <span class="string">reset</span>;

<span class="comment">% --- Executes on button press in detrendBeforeDisplaying.</span>
<span class="keyword">function</span> detrendBeforeDisplaying_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to detrendBeforeDisplaying (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% Temporal filtering (niak_brick_time_filter)</span>
<span class="comment">% get the user setting for line thickness and width</span>
<span class="keyword">global</span> lineWidth lineColor;
<span class="keyword">if</span> ~isempty(findobj(handles.plotAxes, <span class="string">'Type'</span>, <span class="string">'Line'</span>))
lineColor = get(findobj(handles.plotAxes, <span class="string">'Type'</span>, <span class="string">'Line'</span>),<span class="string">'Color'</span>);
lineWidth = get(findobj(handles.plotAxes, <span class="string">'Type'</span>, <span class="string">'Line'</span>),<span class="string">'LineWidth'</span>);
<span class="keyword">end</span>

<span class="keyword">if</span> get(hObject,<span class="string">'Value'</span>) == 1
    <span class="keyword">if</span> isempty(handles.roi.plotData)
        <span class="keyword">return</span>;
    <span class="keyword">end</span>
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Busy detrending the data...'</span>);
    disp(<span class="string">'Runing Temporal High Pass Filtering.......................'</span>);
    opt.hp = 0.01; <span class="comment">% Apply a high-pass filter at cut-off frequency 0.01Hz (slow time drifts)</span>
    opt.lp = Inf;  <span class="comment">% Do not apply low-pass filter. Low-pass filter induce a big loss in degrees of freedom without sgnificantly improving the SNR.</span>
    <span class="keyword">if</span> isempty(handles.scanData.header.TR) <span class="comment">% if no TR info exist then explicitly get it from the user</span>
        prompt = {<span class="string">'Please specify TR in seconds'</span>};
        dlg_title = <span class="string">'TR'</span>;
        num_lines = 1;
        def = {<span class="string">'1.5'</span>};
        opt.tr = str2double(inputdlg(prompt,dlg_title,num_lines,def));
        handles.scanData.header.TR = opt.tr;
    <span class="keyword">else</span>
        opt.tr                      = handles.scanData.header.TR;
    <span class="keyword">end</span>
    [plotDataDetrended,extras]      = niak_filter_tseries(double(handles.roi.plotData'),opt);
    plotDataDetrended               = plotDataDetrended';
    plotDataMeanDetrended           = mean(plotDataDetrended,1);

    plot(handles.plotAxes, 1:numel(plotDataMeanDetrended), plotDataMeanDetrended,<span class="string">'LineSmoothing'</span>,<span class="string">'on'</span>, <span class="string">'LineWidth'</span>, lineWidth,<span class="string">'Color'</span>, lineColor);
    set(handles.plotAxes,<span class="string">'Color'</span>,[0 0 0]); <span class="comment">% change the plot background to black</span>

    handles.roi.plotDataMeanDetrended   = plotDataMeanDetrended;
    handles.roi.plotDataDetrended       = plotDataDetrended;
    handles.roi.maxYDetrended           = max(plotDataMeanDetrended);
    handles.roi.minYDetrended           = min(plotDataMeanDetrended);
    set(handles.plotAxes,<span class="string">'yLim'</span>,<span class="keyword">...</span>
        [handles.roi.minYDetrended handles.roi.maxYDetrended ]); <span class="comment">% chngle the y axis limit</span>
    set(handles.plotAxes,<span class="string">'xLim'</span>, [1 numel(plotDataMeanDetrended)]);
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Detrending Done.'</span>);
    guidata(hObject,handles);
<span class="keyword">else</span>
    <span class="keyword">if</span> ~isempty(handles.roi.plotDataMean)
        plot(handles.plotAxes, 1:numel(handles.roi.plotDataMean),  handles.roi.plotDataMean,<span class="string">'LineSmoothing'</span>,<span class="string">'on'</span>, <span class="string">'LineWidth'</span>, lineWidth,<span class="string">'Color'</span>, lineColor);
        set(handles.plotAxes,<span class="string">'Color'</span>,[0 0 0]); <span class="comment">% change the plot background to black</span>
        set(handles.plotAxes,<span class="string">'yLim'</span>,<span class="keyword">...</span>
            [handles.roi.minY handles.roi.maxY]);
        set(handles.plotAxes,<span class="string">'xLim'</span>, [1 numel(handles.roi.plotDataMean)]);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% if the user already input a design matrix, then plot it</span>
<span class="keyword">if</span> handles.designMatrix.conditionCount   ~= 0
    set(handles.okDesignMatrix, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.okDesignMatrix;
    dfmri(<span class="string">'okDesignMatrix_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of detrendBeforeDisplaying</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> preprocessedDataBuffer_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to preprocessedDataBuffer (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

[data, header]              = readFunctionalRealTimeUntouchedPreproc(1);
data = data * 100;
intializeBrigtnessContrast(handles,eventdata,hObject,data);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[data,m]        = prepareMosaicData(data, header);
<span class="comment">% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr</span>
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]<span class="keyword">...</span>
    = mosaic2VoxelsXScansVector(m)
<span class="comment">% data is the appended dataset</span>
<span class="comment">% m contains the location of annotations</span>
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,<span class="keyword">...</span>
    handles.mosaicAxes);
<span class="comment">% prepare to share the data among gui</span>
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
<span class="comment">%update data</span>
guidata(hObject, handles);

<span class="comment">% --- Executes on selection change in mosaicColormap.</span>
<span class="keyword">function</span> mosaicColormap_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to mosaicColormap (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: contents = cellstr(get(hObject,'String')) returns mosaicColormap contents as cell array</span>
<span class="comment">%        contents{get(hObject,'Value')} returns selected item from mosaicColormap</span>

<span class="keyword">global</span> currentScan mosaicColormap;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
numCbrewerColors = 8;
contents = cellstr(get(hObject,<span class="string">'String'</span>))
cm = contents{get(hObject,<span class="string">'Value'</span>)};
tmp = cm;
<span class="keyword">if</span> strcmp(cm,<span class="string">'IsoL'</span>)
    cm = pmkmp(256, <span class="string">'isol'</span>);
<span class="keyword">elseif</span> strcmp(cm,<span class="string">'CubicL'</span>)
    cm = pmkmp(256);
<span class="keyword">elseif</span> strcmp(cm,<span class="string">'Fire'</span>)
    cm = fire;
<span class="keyword">elseif</span> strcmp(cm, <span class="string">'Maximally Distinct'</span>)
    cm = distinguishable_colors(numCbrewerColors);
<span class="keyword">elseif</span> strcmp(cm, <span class="string">'Color Brewer Set1'</span>)
    cm = cbrewer(<span class="string">'qual'</span>, <span class="string">'Set1'</span>, numCbrewerColors);
<span class="keyword">elseif</span> strcmp(cm, <span class="string">'Color Brewer Set2'</span>)
    cm = cbrewer(<span class="string">'qual'</span>, <span class="string">'Set2'</span>, numCbrewerColors);
<span class="keyword">elseif</span> strcmp(cm, <span class="string">'Color Brewer Set3'</span>)
    cm = cbrewer(<span class="string">'qual'</span>, <span class="string">'Set3'</span>, numCbrewerColors);
<span class="keyword">elseif</span> strcmp(cm, <span class="string">'Color Brewer Paired'</span>)
    cm = cbrewer(<span class="string">'qual'</span>, <span class="string">'Paired'</span>,numCbrewerColors);
<span class="keyword">elseif</span> strcmp(cm, <span class="string">'Color Brewer Accent'</span>)
    cm = cbrewer(<span class="string">'qual'</span>, <span class="string">'Accent'</span>,numCbrewerColors);
<span class="keyword">elseif</span> strcmp(cm, <span class="string">'Color Brewer Dark'</span>)
    cm = cbrewer(<span class="string">'qual'</span>, <span class="string">'Dark2'</span>,numCbrewerColors);
<span class="keyword">elseif</span> strcmp(cm, <span class="string">'Color Brewer Pastel'</span>)
    cm = cbrewer(<span class="string">'qual'</span>, <span class="string">'Pastel2'</span>,numCbrewerColors);
<span class="keyword">end</span>
handles.displayProperties.mosaicColormap = cm;
mosaicColormap = cm;
<span class="keyword">if</span> handles.scanData.header.numScans == 1
    handles.displayProperties.startPoint = 1;
    handles.displayProperties.endPoint = 1;
<span class="keyword">elseif</span> currentScan == handles.scanData.header.numScans
    handles.displayProperties.startPoint = currentScan;
    handles.displayProperties.endPoint = currentScan;
<span class="keyword">else</span>
    handles.displayProperties.startPoint = currentScan+1;
    handles.displayProperties.endPoint = currentScan+1;
<span class="keyword">end</span>
[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
    handles.displayProperties, handles.mosaicAxes);
guidata(hObject,handles);
<span class="comment">% overlay ROI</span>
refreshROIOverlay(handles);

<span class="comment">% invoke trueMaskcolor</span>
<span class="keyword">if</span> get(handles.overlayMask,<span class="string">'Value'</span>) &amp;&amp; get(handles.trueColor,<span class="string">'Value'</span>)
    set(handles.trueColor, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.trueColor;
    dfmri(<span class="string">'trueColor_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>

<span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr the view changes</span>
interactivemouse <span class="string">off</span>;
interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>
set(handles.statusString, <span class="string">'String'</span>, strcat(<span class="string">'Status: Slice color map changed to'</span>, {<span class="string">' '''</span>}, tmp,{<span class="string">''''</span>}));

<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> mosaicColormap_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to mosaicColormap (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: popupmenu controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in resetViewMosaic.</span>
<span class="keyword">function</span> resetViewMosaic_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to resetViewMosaic (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> viewSwitching;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
<span class="keyword">if</span> handles.displayProperties.view == 3 <span class="comment">%just a hack to prevent the axes going beserk on pressing the reset button when the view is axial</span>
viewSwitching = 1;
[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">else</span>
axes(handles.mosaicAxes);
interactivemouse <span class="string">RESTORE_ORIG</span>;
<span class="keyword">end</span>

<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>

<span class="comment">% --- Executes on button press in ResetViewPlot.</span>
<span class="keyword">function</span> ResetViewPlot_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to ResetViewPlot (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> axesNumber;
axesNumber = 1;
<span class="comment">% axes(handles.mosaicAxes);</span>
interactivemouse <span class="string">restore_orig</span>;


<span class="comment">% --- Executes on selection change in popupmenu4.</span>
<span class="keyword">function</span> popupmenu4_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to popupmenu4 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: contents = cellstr(get(hObject,'String')) returns popupmenu4 contents as cell array</span>
<span class="comment">%        contents{get(hObject,'Value')} returns selected item from popupmenu4</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> popupmenu4_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to popupmenu4 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: popupmenu controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on selection change in view.</span>
<span class="keyword">function</span> view_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to view (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: contents = cellstr(get(hObject,'String')) returns view contents as cell array</span>
<span class="comment">%        contents{get(hObject,'Value')} returns selected item from view</span>
<span class="keyword">global</span> viewSwitching mask;

contents = cellstr(get(hObject,<span class="string">'String'</span>));
<span class="keyword">if</span> strcmp(contents{get(hObject,<span class="string">'Value'</span>)}, <span class="string">'Sagittal'</span>)
    handles.displayProperties.view = 1;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">elseif</span> strcmp(contents{get(hObject,<span class="string">'Value'</span>)}, <span class="string">'Coronal'</span>)
    handles.displayProperties.view = 2;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">elseif</span> strcmp(contents{get(hObject,<span class="string">'Value'</span>)}, <span class="string">'Axial'</span>)
    handles.displayProperties.view = 3;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">elseif</span> strcmp(contents{get(hObject,<span class="string">'Value'</span>)}, <span class="string">'Flattened 4D (Scans x Voxels)'</span>)
    handles.displayProperties.view = 4;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">elseif</span> strcmp(contents{get(hObject,<span class="string">'Value'</span>)}, <span class="string">'3D Orthogonal'</span>)
    handles.displayProperties.view = 5;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
<span class="keyword">else</span>
    handles.displayProperties.view = 6;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties,handles.mosaicAxes);
<span class="keyword">end</span>
guidata(hObject,handles);

<span class="comment">% if masked voxels only then</span>
<span class="keyword">if</span> get(handles.showMaskedVoxelsOnly, <span class="string">'Value'</span>) == 1
    <span class="keyword">try</span>
        handles.roi.roiData.imgSag = mask.imgMaskedVoxelsOnlySagittal &amp; handles.roi.roiData.imgSag;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    <span class="keyword">try</span>
        handles.roi.roiData.imgCor = mask.imgMaskedVoxelsOnlyCoronal &amp; handles.roi.roiData.imgCor;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    <span class="keyword">try</span>
        handles.roi.roiData.imgAxial = mask.imgMaskedVoxelsOnlyAxial &amp; handles.roi.roiData.imgAxial;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% update ROI Data if view switchsa</span>
<span class="comment">% if ~isempty(handles.roi.roiData.imgSag) | ~isempty(handles.roi.roiData.imgCor) | ~isempty(handles.roi.roiData.imgAxial)</span>
<span class="comment">% colorize ROI</span>
<span class="keyword">try</span>
    <span class="keyword">if</span> handles.displayProperties.view == 1
        [posX posY] = find(handles.roi.roiData.imgSag);
        pSag = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">elseif</span> handles.displayProperties.view == 2
        [posX posY] = find(handles.roi.roiData.imgCor);
        pCor = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">else</span>
        [posX posY] = find(handles.roi.roiData.imgAxial);
        pAxial = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">end</span>
<span class="keyword">catch</span>
<span class="keyword">end</span>
      <span class="keyword">if</span> get(handles.trueColor, <span class="string">'Value'</span>) <span class="comment">% if true colors is on then</span>
        <span class="comment">% invoke trueMaskcolor</span>
        set(handles.trueColor, <span class="string">'Value'</span>, 1);
        hObjectCall = handles.trueColor;
        dfmri(<span class="string">'trueColor_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    <span class="keyword">end</span>
<span class="comment">%     if handles.displayProperties.view == 1</span>
<span class="comment">%         if isempty(handles.roi.roiHandle.pSag)</span>
<span class="comment">%             handles.roi.roiHandle.pSag = pSag;</span>
<span class="comment">%         else</span>
<span class="comment">%             handles.roi.roiHandle.pSag = [handles.roi.roiHandle.pSag; reshape(pSag,[],1)];</span>
<span class="comment">%         end</span>
<span class="comment">%     elseif handles.displayProperties.view == 1</span>
<span class="comment">%         if isempty(handles.roi.roiHandle.pCor)</span>
<span class="comment">%             handles.roi.roiHandle.pCor = pCor;</span>
<span class="comment">%         else</span>
<span class="comment">%             handles.roi.roiHandle.pCor = [handles.roi.roiHandle.pCor; reshape(pCor,[],1)];</span>
<span class="comment">%         end</span>
<span class="comment">%     elseif handles.displayProperties.view == 1</span>
<span class="comment">%         if isempty(handles.roi.roiHandle.pAxial)</span>
<span class="comment">%             handles.roi.roiHandle.pAxial = pAxial;</span>
<span class="comment">%         else</span>
<span class="comment">%             handles.roi.roiHandle.pAxial = [handles.roi.roiHandle.pAxial; reshape(pAxial,[],1)];</span>
<span class="comment">%         end</span>
<span class="comment">%     end</span>
    guidata(hObject,handles);
<span class="comment">% end</span>


<span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr the view changes</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>

<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> view_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to view (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: popupmenu controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on selection change in roiVoxelsSelection.</span>
<span class="keyword">function</span> roiVoxelsSelection_Callback(hObject, eventdata, handles)
</pre><pre class="codeinput"><span class="comment">% hObject    handle to roiVoxelsSelection (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% make on the mosiac axes visible so that the use can select the voxels in</span>
<span class="comment">% the mosaic</span>
<span class="keyword">global</span> mask lineWidth lineColor;
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);

voxelSelectionMethod = 0;
contents = cellstr(get(hObject,<span class="string">'String'</span>))
method = contents{get(hObject,<span class="string">'Value'</span>)}
set( handles.figure1, <span class="string">'Pointer'</span>, <span class="string">'crosshair'</span> );
<span class="keyword">if</span> strcmp(method, <span class="string">'Rectangular'</span>)
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Drag a rectangle by clicking the left mouse button, dragging and then releasing the mouse button'</span>);
    k = waitforbuttonpress;
    point1 = get(gca,<span class="string">'CurrentPoint'</span>);    <span class="comment">% button down detected</span>
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Release the left mouse button to end ROI selection.'</span>);
    finalRect = rbbox;                   <span class="comment">% return figure units</span>
    point2 = get(gca,<span class="string">'CurrentPoint'</span>);    <span class="comment">% button up detected</span>

    point1 = point1(1,1:2);              <span class="comment">% extract x and y</span>
    point2 = point2(1,1:2);
    p1 = min(point1,point2);             <span class="comment">% calculate locations</span>
    offset = abs(point1-point2);         <span class="comment">% and dimensions</span>
    x = [p1(1) p1(1)+offset(1) p1(1)+offset(1) p1(1) p1(1)]- 0.5; <span class="comment">% -0.5 for imagesc start point</span>
    y = [p1(2) p1(2) p1(2)+offset(2) p1(2)+offset(2) p1(2)]- 0.5;
    x = round(x); y = round(y);
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Done'</span>);
<span class="keyword">elseif</span> strcmp(method, <span class="string">'Polygon'</span>)
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Press left mouse button for every edge of the polygon. Press right mouse button to finish the Polygon'</span>);
    [x,y] = GETLINE(<span class="string">'closed'</span>);
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Done'</span>)

    x = round(x-0.5); y = round(y-0.5);
<span class="keyword">else</span>
    x = [], y =[];
    <span class="keyword">while</span> ~(strcmp(get(handles.figure1,<span class="string">'SelectionType'</span>), <span class="string">'alt'</span>))
        set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Press left mouse button to select a voxel. Press right mouse button to end the selection'</span>);
        [x, y] = getpts(handles.mosaicAxes)
    <span class="keyword">end</span>
    voxelSelectionMethod = 3;
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Done'</span>);
<span class="keyword">end</span>

set( handles.figure1, <span class="string">'Pointer'</span>, <span class="string">'arrow'</span> );
</pre><h2>plot ROI<a name="3"></a></h2><pre class="codeinput"><span class="keyword">if</span> handles.displayProperties.view == 1 | handles.displayProperties.view == 2
    siz = [handles.m.mosaic^2*sqrt(handles.m.xyRes) handles.m.xyRes*sqrt(handles.m.xyRes)];
<span class="keyword">else</span>
    siz = [handles.m.xyRes*handles.m.mosaic handles.m.xyRes*handles.m.mosaic];
<span class="keyword">end</span>

<span class="comment">% make binary mask</span>
<span class="keyword">if</span> voxelSelectionMethod == 3;
    posX = round(y(1:end-1)); <span class="comment">% ignore the last sample corresponding to the selection END click</span>
    posY = round(x(1:end-1));
    roiMask = logical(zeros(siz(1),siz(2)));
    <span class="keyword">for</span> j = 1: numel(posX)
        roiMask(posX(j), posY(j)) = 1;
    <span class="keyword">end</span>
<span class="keyword">else</span>
    roiMask = poly2mask(x,y,siz(1),siz(2));
<span class="keyword">end</span>


<span class="comment">% OR the masks if there are more than one of them</span>
<span class="keyword">if</span>  handles.displayProperties.view == 1
    <span class="keyword">if</span> isempty(handles.roi.roiMaskSag)
        handles.roi.roiMaskSag = roiMask;
    <span class="keyword">else</span>
        handles.roi.roiMaskSag = handles.roi.roiMaskSag | roiMask;
    <span class="keyword">end</span>
<span class="keyword">elseif</span>  handles.displayProperties.view == 2
    <span class="keyword">if</span> isempty(handles.roi.roiMaskCor)
        handles.roi.roiMaskCor = roiMask;
    <span class="keyword">else</span>
        handles.roi.roiMaskCor = handles.roi.roiMaskCor | roiMask;
    <span class="keyword">end</span>
<span class="keyword">elseif</span>  handles.displayProperties.view == 3
    <span class="keyword">if</span> isempty(handles.roi.roiMaskAxial)
        handles.roi.roiMaskAxial = roiMask;
    <span class="keyword">else</span>
        handles.roi.roiMaskAxial = handles.roi.roiMaskAxial | roiMask;
    <span class="keyword">end</span>
<span class="keyword">end</span>



<span class="comment">% convert the mask in all three viewss</span>
[handles.img2Coords.roiMaskSagittal handles.img2Coords.roiMaskCoronal handles.img2Coords.roiMaskAxial] = <span class="keyword">...</span>
    mosaic2VoxelsXScansVector(handles.m);
<span class="keyword">if</span>  handles.displayProperties.view == 1
    roiPositionInData = handles.img2Coords.roiMaskSagittal(find(handles.roi.roiMaskSag));

<span class="keyword">elseif</span>  handles.displayProperties.view == 2
    roiPositionInData = handles.img2Coords.roiMaskCoronal(find(handles.roi.roiMaskCor));

<span class="keyword">else</span>  <span class="comment">% handles.displayProperties.view == 3</span>
    roiPositionInData = handles.img2Coords.roiMaskAxial(find(handles.roi.roiMaskAxial));

<span class="keyword">end</span>
numVoxelsIncludingPadding   = (handles.m.xyRes)^2 * (handles.m.mosaic)^2;
ind                         = uint32(zeros(1,numVoxelsIncludingPadding));
ind(roiPositionInData)= 1;
[handles.roi.roiData.imgSag handles.roi.roiData.imgCor handles.roi.roiData.imgAxial] =<span class="keyword">...</span>
    roiMosaic2VoxelsXScansVector(handles.m, ind);
<span class="comment">%update</span>
handles.roi.roiMaskSag = handles.roi.roiData.imgSag;
handles.roi.roiMaskCor = handles.roi.roiData.imgCor;
handles.roi.roiMaskAxial = handles.roi.roiData.imgAxial;

<span class="comment">%Or the ROI and anatomical masks</span>
<span class="keyword">if</span> get(handles.showMaskedVoxelsOnly, <span class="string">'Value'</span>) == 1
    <span class="keyword">try</span>
        handles.roi.roiData.imgSag = mask.imgMaskedVoxelsOnlySagittal &amp; handles.roi.roiData.imgSag;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    <span class="keyword">try</span>
        handles.roi.roiData.imgCor = mask.imgMaskedVoxelsOnlyCoronal &amp; handles.roi.roiData.imgCor;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    <span class="keyword">try</span>
        handles.roi.roiData.imgAxial = mask.imgMaskedVoxelsOnlyAxial &amp; handles.roi.roiData.imgAxial;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% colorize ROI</span>
<span class="keyword">if</span> handles.displayProperties.view == 1
    [posX posY] = find(handles.roi.roiData.imgSag);
    pSag = colorpixel(posY,posX,handles.roi.roiColor);
<span class="keyword">elseif</span> handles.displayProperties.view == 2
    [posX posY] = find(handles.roi.roiData.imgCor);
    pCor = colorpixel(posY,posX,handles.roi.roiColor);
<span class="keyword">else</span>
    [posX posY] = find(handles.roi.roiData.imgAxial);
    pAxial = colorpixel(posY,posX,handles.roi.roiColor);
<span class="keyword">end</span>


<span class="keyword">if</span> handles.displayProperties.view == 1
    <span class="keyword">if</span> isempty(handles.roi.roiHandle.pSag)
        handles.roi.roiHandle.pSag = pSag;
    <span class="keyword">else</span>
        handles.roi.roiHandle.pSag = [handles.roi.roiHandle.pSag; reshape(pSag,[],1)];
    <span class="keyword">end</span>
<span class="keyword">elseif</span> handles.displayProperties.view == 1
    <span class="keyword">if</span> isempty(handles.roi.roiHandle.pCor)
        handles.roi.roiHandle.pCor = pCor;
    <span class="keyword">else</span>
        handles.roi.roiHandle.pCor = [handles.roi.roiHandle.pCor; reshape(pCor,[],1)];
    <span class="keyword">end</span>
<span class="keyword">elseif</span> handles.displayProperties.view == 1
    <span class="keyword">if</span> isempty(handles.roi.roiHandle.pAxial)
        handles.roi.roiHandle.pAxial = pAxial;
    <span class="keyword">else</span>
        handles.roi.roiHandle.pAxial = [handles.roi.roiHandle.pAxial; reshape(pAxial,[],1)];
    <span class="keyword">end</span>
<span class="keyword">end</span>

guidata(hObject,handles);
</pre><h2>Call plot<a name="4"></a></h2><pre class="codeinput">[handles.img2Coords.sagittal handles.img2Coords.coronal handles.img2Coords.axial] = <span class="keyword">...</span>
    mosaic2VoxelsXScansVector(handles.m);

<span class="keyword">if</span> handles.displayProperties.view == 1
   plotData = handles.scanData.data(handles.img2Coords.sagittal(find(handles.roi.roiData.imgSag)), :);
   voxelLocation = handles.img2Coords.sagittal(find(handles.roi.roiData.imgSag))
<span class="keyword">elseif</span> handles.displayProperties.view == 2
   plotData = handles.scanData.data(handles.img2Coords.coronal(find(handles.roi.roiData.imgCor)), :);
<span class="keyword">else</span>
   plotData = handles.scanData.data(handles.img2Coords.axial(find(handles.roi.roiData.imgAxial)), :);
<span class="keyword">end</span>

plotDataMean = mean(plotData,1);
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>); <span class="comment">% so that plot is in the plot axes</span>
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);

handles.roi.plotDataMean    = plotDataMean;
handles.roi.plotData        = plotData;
handles.roi.maxY        	= max(plotDataMean);
handles.roi.minY            = min(plotDataMean);

xLimitPlot = get(handles.plotAxes, <span class="string">'XLim'</span>); <span class="comment">% get the limits beofre</span>
yLimitPlot = get(handles.plotAxes, <span class="string">'YLim'</span>);

<span class="comment">% get the user setting for line thickness and width</span>
<span class="keyword">if</span> ~isempty(findobj(handles.plotAxes, <span class="string">'Type'</span>, <span class="string">'Line'</span>))
lineColor = get(findobj(handles.plotAxes, <span class="string">'Type'</span>, <span class="string">'Line'</span>),<span class="string">'Color'</span>);
lineWidth = get(findobj(handles.plotAxes, <span class="string">'Type'</span>, <span class="string">'Line'</span>),<span class="string">'LineWidth'</span>);
<span class="keyword">end</span>

<span class="keyword">if</span> ~get(handles.detrendBeforeDisplaying, <span class="string">'Value'</span>) <span class="comment">%if the Detrend option is not on then display undetrended data</span>
    h = plot(handles.plotAxes, 1:numel(plotDataMean), plotDataMean,<span class="string">'LineSmoothing'</span>,<span class="string">'on'</span>, <span class="string">'LineWidth'</span>, lineWidth,<span class="string">'Color'</span>, lineColor);
    set(handles.plotAxes,<span class="string">'Color'</span>,[0 0 0]); <span class="comment">% change the plot background to black</span>
    set(h,<span class="string">'uicontextmenu'</span>,linecmenu);
    <span class="keyword">if</span> handles.roi.maxY ~= 0 &amp; handles.roi.minY ~= 0 <span class="comment">% avoid error when data is zero</span>
        <span class="keyword">try</span>
            set(handles.plotAxes,<span class="string">'yLim'</span>, [handles.roi.minY handles.roi.maxY]); <span class="comment">% change the plot background to black</span>
        <span class="keyword">catch</span> <span class="keyword">end</span>
    <span class="keyword">end</span>
    set(handles.plotAxes,<span class="string">'xLim'</span>, [1 numel(plotDataMean)]); <span class="comment">% change the plot background to black</span>
<span class="keyword">else</span> <span class="comment">% else display detrended data</span>
    disp(<span class="string">'Runing Temporal High Pass Filtering.......................'</span>);
    opt.hp = 0.01; <span class="comment">% Apply a high-pass filter at cut-off frequency 0.01Hz (slow time drifts)</span>
    opt.lp = Inf;  <span class="comment">% Do not apply low-pass filter. Low-pass filter induce a big loss in degrees of freedom without sgnificantly improving the SNR.</span>
    <span class="keyword">if</span> isempty(handles.scanData.header.TR) <span class="comment">% if no TR info exist then explicitly get it from the user</span>
        prompt = {<span class="string">'Please specify TR in seconds'</span>};
        dlg_title = <span class="string">'TR'</span>;
        num_lines = 1;
        def = {<span class="string">'1.5'</span>};
        opt.tr = str2double(inputdlg(prompt,dlg_title,num_lines,def));
        handles.scanData.header.TR = opt.tr;
    <span class="keyword">else</span>
        opt.tr                      = handles.scanData.header.TR;
    <span class="keyword">end</span>
    [plotDataDetrended,extras]      = niak_filter_tseries(double(plotData'),opt);
    plotDataDetrended               = plotDataDetrended';
    plotDataMeanDetrended           = mean(plotDataDetrended,1);

    plot(handles.plotAxes, 1:numel(plotDataMeanDetrended), plotDataMeanDetrended,<span class="string">'LineSmoothing'</span>,<span class="string">'on'</span>, <span class="string">'LineWidth'</span>, lineWidth,<span class="string">'Color'</span>, lineColor);
    set(handles.plotAxes,<span class="string">'Color'</span>,[0 0 0]); <span class="comment">% change the plot background to black</span>

    handles.roi.plotDataMeanDetrended   = plotDataMeanDetrended;
    handles.roi.plotDataDetrended       = plotDataDetrended;
    handles.roi.maxYDetrended           = max(plotDataMeanDetrended);
    handles.roi.minYDetrended           = min(plotDataMeanDetrended);
    set(handles.plotAxes,<span class="string">'yLim'</span>,<span class="keyword">...</span>
        [handles.roi.minYDetrended handles.roi.maxYDetrended ]); <span class="comment">% chngle the y axis limit</span>
    set(handles.plotAxes,<span class="string">'xLim'</span>, [1 numel(plotDataMeanDetrended)]);
<span class="keyword">end</span>

set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>); <span class="comment">% so that control falls back to the mosiac axes</span>
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
guidata(hObject,handles);

<span class="comment">% if the user already input a design matrix, then plot it</span>
<span class="keyword">if</span> handles.designMatrix.conditionCount   ~= 0
    set(handles.okDesignMatrix, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.okDesignMatrix;
    dfmri(<span class="string">'okDesignMatrix_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>

<span class="keyword">if</span> ~(xLimitPlot(1) == 0 &amp;&amp; xLimitPlot(2) == 1)<span class="comment">% &amp; ~yLimitPlot == [0 1] %only do it after the zoom has been done</span>
set(handles.plotAxes, <span class="string">'XLim'</span>,xLimitPlot); <span class="comment">% get the limits beofre</span>
set(handles.plotAxes, <span class="string">'YLim'</span>,yLimitPlot);
<span class="keyword">end</span>

<span class="comment">% enable the Go again button</span>
set(handles.goAbortRoiSelection,<span class="string">'String'</span>, <span class="string">'Go Again'</span>);
set(handles.goAbortRoiSelection,<span class="string">'Visible'</span>, <span class="string">'on'</span>);

set(handles.statusString, <span class="string">'String'</span>,<span class="string">'Status: Added a new ROI'</span>);
</pre><pre class="codeinput"><span class="keyword">function</span> roiVoxelsSelection_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to roiVoxelsSelection (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: popupmenu controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in displayDualCursors.</span>
<span class="keyword">function</span> displayDualCursors_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to displayDualCursors (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% if no data exists then return</span>
<span class="keyword">if</span>  isempty(handles.roi.plotData) &amp; isempty(handles.motionRegressors)
    set(handles.displayDualCursors, <span class="string">'Value'</span>, 0);
    msgbox(<span class="string">'No data exists to be measured with the dual cursor. First plot the time course of an ROI and then choose this option.'</span>, <span class="string">'OOPS'</span>,<span class="string">'warn'</span>,<span class="string">'modal'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
<span class="keyword">if</span> get(hObject,<span class="string">'Value'</span>) == 1
   dualcursor <span class="string">on</span>;
   [x1x2] = dualcursor(handles.plotAxes);
   dualcursor([4 8],[.05 1.05; .25 1.05],<span class="string">'gs'</span>);

<span class="keyword">else</span>
    dualcursor <span class="string">off</span>;
<span class="keyword">end</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
guidata(hObject, handles);
<span class="comment">% Hint: get(hObject,'Value') returns toggle state of displayDualCursors</span>

<span class="comment">% --- Executes on button press in plotStandardDeviation.</span>
<span class="keyword">function</span> plotStandardDeviation_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to plotStandardDeviation (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of plotStandardDeviation</span>



<span class="keyword">function</span> zLocation_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to zLocation (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'String') returns contents of zLocation as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of zLocation as a double</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> zLocation_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to zLocation (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>



<span class="keyword">function</span> yLocation_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to yLocation (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'String') returns contents of yLocation as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of yLocation as a double</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> yLocation_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to yLocation (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>



<span class="keyword">function</span> xLocation_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to xLocation (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'String') returns contents of xLocation as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of xLocation as a double</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> xLocation_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to xLocation (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in deleteLastCondition.</span>
<span class="keyword">function</span> deleteLastCondition_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to deleteLastCondition (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);

<span class="keyword">if</span> handles.designMatrix.conditionCount == 0
    msgbox(<span class="string">'Your highness! There is nothing left to delete. You will crash me if you continue like this.'</span>,<span class="string">'Warning'</span>, <span class="string">'warn'</span>);
    <span class="keyword">return</span>
<span class="keyword">end</span>
[x y] = getAxesLimits(handles.plotAxes);

<span class="keyword">if</span> get(handles.plotMotionRegressors, <span class="string">'Value'</span>) <span class="comment">% if motion regressors is on then plot the design matrix over motion regressors</span>
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,<span class="keyword">...</span>
        handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
        handles.designMatrix.offset, 0, 1, 0,<span class="keyword">...</span>
        minY, maxY,<span class="keyword">...</span>
        handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
        []);
    hold <span class="string">on</span>; <span class="comment">% holds the design matrix plot to overlay additional information over it</span>
    <span class="comment">% call plot motion regressor again to overlay the motion regressor over</span>
    <span class="comment">% the design matrix</span>
    set(handles.plotMotionRegressors, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri(<span class="string">'plotMotionRegressors_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    hold <span class="string">off</span>;
<span class="keyword">else</span>
    <span class="keyword">if</span> handles.designMatrix.conditionCount &gt;= 1
        <span class="keyword">if</span> get(handles.detrendBeforeDisplaying, <span class="string">'Value'</span>) == 0 <span class="comment">% then plot non- detreded data</span>
            makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
                handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
                handles.designMatrix.offset, 0, 1, 0,<span class="keyword">...</span>
                handles.roi.minY, handles.roi.maxY,<span class="keyword">...</span>
                handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
                handles.roi.plotData);
        <span class="keyword">else</span> <span class="comment">% otherwise plot detrended data</span>
            makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
                handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
                handles.designMatrix.offset, 0, 1, 0,<span class="keyword">...</span>
                handles.roi.minYDetrended, handles.roi.maxYDetrended,<span class="keyword">...</span>
                handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
                handles.roi.plotDataDetrended);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% update the data structure as well</span>
handles.designMatrix.onsets(end) = [];
handles.designMatrix.durations(end) = [];
<span class="comment">% decrement the condition counter as well</span>
handles.designMatrix.conditionCount = handles.designMatrix.conditionCount -1;
guidata(hObject,handles);
<span class="comment">% if zoom is on, keep it on</span>
<span class="keyword">if</span> get(handles.turnOnZoomAndPanPlot,<span class="string">'Value'</span>) == 1
    set(handles.turnOnZoomAndPanPlot, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri(<span class="string">'turnOnZoomAndPanPlot_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.statusString, <span class="string">'String'</span>, strcat(<span class="string">'Status: '</span>,<span class="keyword">...</span>
    <span class="string">' Deleted the last condition. You have a total of '</span>,{<span class="string">' '</span>},<span class="keyword">...</span>
    num2str(handles.designMatrix.conditionCount), <span class="string">' condition(s) remaining'</span>));

setAxesLimits(handles.plotAxes, x, y);

<span class="comment">% --- Executes on button press in deleteAllConditions.</span>
<span class="keyword">function</span> deleteAllConditions_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to deleteAllConditions (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
[x y] = getAxesLimits(handles.plotAxes);
<span class="keyword">if</span> get(handles.plotMotionRegressors, <span class="string">'Value'</span>) <span class="comment">% if motion regressors is on then plot the design matrix over motion regressors</span>
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,<span class="keyword">...</span>
        handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
        handles.designMatrix.offset, 0, 0, 1,<span class="keyword">...</span>
        minY, maxY,<span class="keyword">...</span>
        handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
        []);
    hold <span class="string">on</span>; <span class="comment">% holds the design matrix plot to overlay additional information over it</span>
    <span class="comment">% call plot motion regressor again to overlay the motion regressor over</span>
    <span class="comment">% the design matrix</span>
    set(handles.plotMotionRegressors, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri(<span class="string">'plotMotionRegressors_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    hold <span class="string">off</span>;
<span class="keyword">else</span>
    <span class="keyword">if</span> get(handles.detrendBeforeDisplaying, <span class="string">'Value'</span>) == 0 <span class="comment">% then plot non- detreded data</span>
        makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
            handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
            handles.designMatrix.offset, 0, 0, 1,<span class="keyword">...</span>
            handles.roi.minY, handles.roi.maxY,<span class="keyword">...</span>
            handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
            handles.roi.plotData);
    <span class="keyword">else</span> <span class="comment">% otherwise plot detrended data</span>
        makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
            handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
            handles.designMatrix.offset, 0, 0, 1,<span class="keyword">...</span>
            handles.roi.minYDetrended, handles.roi.maxYDetrended,<span class="keyword">...</span>
            handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
            handles.roi.plotDataDetrended);
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% update the data structure as well</span>
    handles.designMatrix.onsets         = [];
    handles.designMatrix.durations      = [];
    handles.designMatrix.conditionCount     = 0;
guidata(hObject,handles);
<span class="comment">% if zoom is on, keep it on</span>
<span class="keyword">if</span> get(handles.turnOnZoomAndPanPlot,<span class="string">'Value'</span>) == 1
    set(handles.turnOnZoomAndPanPlot, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri(<span class="string">'turnOnZoomAndPanPlot_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.statusString, <span class="string">'String'</span>, strcat(<span class="string">'Status: '</span>,<span class="keyword">...</span>
    <span class="string">' Deleted all conditions. You have 0 conditions currently defined.'</span>));
setAxesLimits(handles.plotAxes, x, y);

<span class="comment">% --- Executes on button press in addANewCondition.</span>
<span class="keyword">function</span> addANewCondition_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to addANewCondition (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in okDesignMatrix.</span>
<span class="keyword">function</span> okDesignMatrix_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to okDesignMatrix (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> lineWidth lineColor;
[x y] = getAxesLimits(handles.plotAxes);
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
onsets      = get(handles.specifyOnsets2,<span class="string">'String'</span>);
onsets      = eval(onsets);
durations   = get(handles.specifyDuration,<span class="string">'String'</span>);
durations   = eval(durations);

<span class="keyword">if</span> handles.designMatrix.conditionCount &gt;= 1 <span class="comment">% prevents adding a new condition every time an ROI is added: reffresh</span>
    <span class="keyword">if</span> ~(isequal(onsets,handles.designMatrix.onsets{1,end}) &amp;&amp; isequal(durations,handles.designMatrix.durations{1,end}))
        handles.designMatrix.conditionCount     =<span class="keyword">...</span>
            handles.designMatrix.conditionCount + 1;
        guidata(hObject,handles);
        handles.designMatrix.onsets{1,handles.designMatrix.conditionCount}= onsets;
        handles.designMatrix.durations{1,handles.designMatrix.conditionCount}= durations;
    <span class="keyword">end</span>
<span class="keyword">else</span>
    handles.designMatrix.conditionCount     =<span class="keyword">...</span>
        handles.designMatrix.conditionCount + 1;
    guidata(hObject,handles);
    handles.designMatrix.onsets{1,handles.designMatrix.conditionCount}= onsets;
    handles.designMatrix.durations{1,handles.designMatrix.conditionCount}= durations;
<span class="keyword">end</span>
guidata(hObject,handles);
<span class="comment">% function makeDesignMatrixBars(numScans, onsets, durations, offset, okAddACondition, deleteLastCondition, deleteAllConditions, minY, maxY, colormap,axesHandle)</span>
<span class="comment">% handles.designMatrix.maxY = handles.roi.maxY;</span>
<span class="comment">% handles.designMatrix.minY = handles.roi.minY;</span>
<span class="keyword">if</span> get(handles.plotMotionRegressors, <span class="string">'Value'</span>) <span class="comment">% if motion regressors is on then plot the design matrix over motion regressors</span>
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,<span class="keyword">...</span>
        handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
        handles.designMatrix.offset, 1, 0, 0,<span class="keyword">...</span>
        minY, maxY,<span class="keyword">...</span>
        handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
        []);
    hold <span class="string">on</span>; <span class="comment">% holds the design matrix plot to overlay additional information over it</span>
    <span class="comment">% call plot motion regressor again to overlay the motion regressor over</span>
    <span class="comment">% the design matrix</span>
    set(handles.plotMotionRegressors, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri(<span class="string">'plotMotionRegressors_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    hold <span class="string">off</span>;
<span class="keyword">else</span>
<span class="comment">% plot design matrix over time courses</span>
    <span class="keyword">if</span> get(handles.detrendBeforeDisplaying, <span class="string">'Value'</span>) == 0 <span class="comment">% then plot non- detreded data</span>
        makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
            handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
            handles.designMatrix.offset, 1, 0, 0,<span class="keyword">...</span>
            handles.roi.minY, handles.roi.maxY,<span class="keyword">...</span>
            handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
            handles.roi.plotData);
    <span class="keyword">else</span> <span class="comment">% otherwise plot detrended data</span>
        makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
            handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
            handles.designMatrix.offset, 1, 0, 0,<span class="keyword">...</span>
            handles.roi.minYDetrended, handles.roi.maxYDetrended,<span class="keyword">...</span>
            handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
            handles.roi.plotDataDetrended);
    <span class="keyword">end</span>
<span class="keyword">end</span>
guidata(hObject, handles);
<span class="comment">% if zoom is on, keep it on</span>
<span class="keyword">if</span> get(handles.turnOnZoomAndPanPlot,<span class="string">'Value'</span>) == 1
    set(handles.turnOnZoomAndPanPlot, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri(<span class="string">'turnOnZoomAndPanPlot_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.statusString, <span class="string">'String'</span>, strcat(<span class="string">'Status: '</span>,<span class="keyword">...</span>
    <span class="string">' Added a new condition. You currently have a total of '</span>,{<span class="string">' '</span>},<span class="keyword">...</span>
    num2str(handles.designMatrix.conditionCount), <span class="string">' condition(s) defined.'</span>));

setAxesLimits(handles.plotAxes, x,y);



<span class="comment">% --- Executes on selection change in listbox5.</span>
<span class="keyword">function</span> listbox5_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to listbox5 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: contents = cellstr(get(hObject,'String')) returns listbox5 contents as cell array</span>
<span class="comment">%        contents{get(hObject,'Value')} returns selected item from listbox5</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> listbox5_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to listbox5 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: listbox controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on key press with focus on listbox5 and none of its controls.</span>
<span class="keyword">function</span> listbox5_KeyPressFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to listbox5 (see GCBO)</span>
<span class="comment">% eventdata  structure with the following fields (see UICONTROL)</span>
<span class="comment">%	Key: name of the key that was pressed, in lower case</span>
<span class="comment">%	Character: character interpretation of the key(s) that was pressed</span>
<span class="comment">%	Modifier: name(s) of the modifier key(s) (i.e., control, shift) pressed</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>



<span class="keyword">function</span> goToScanNumber_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to goToScanNumber (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'String') returns contents of goToScanNumber as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of goToScanNumber as a double</span>



<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> goToScanNumber_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to goToScanNumber (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in jumpToScan.</span>
<span class="keyword">function</span> jumpToScan_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to jumpToScan (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> currentScan;
stringEntered = eval(get(handles.goToScanNumber, <span class="string">'String'</span>));
 handles.displayProperties.startPoint = stringEntered;
  handles.displayProperties.endPoint = stringEntered;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,<span class="keyword">...</span>
        handles.displayProperties, handles.mosaicAxes);
 currentScan =   stringEntered;

 <span class="comment">% hack to turn on the zoom functionality after this button is pressed</span>
<span class="keyword">if</span> handles.displayProperties.mosaicZoomOn <span class="comment">% a hack to Keep interactivemouse on whenevr a button is pressed</span>
    <span class="keyword">try</span>
    interactivemouse <span class="string">off</span>;
    <span class="keyword">catch</span>
    <span class="keyword">end</span>
    interactivemouse <span class="string">on</span>;
<span class="keyword">end</span>
guidata(hObject,handles);

<span class="keyword">function</span> offset_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to offset (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> offset_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to offset (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in addOffset.</span>
<span class="keyword">function</span> addOffset_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to addOffset (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
[x y] = getAxesLimits(handles.plotAxes);
offset      = get(handles.offset,<span class="string">'String'</span>);
offset      = eval(offset);
handles.designMatrix.offset = offset;
guidata(hObject, handles);
<span class="keyword">if</span> get(handles.plotMotionRegressors, <span class="string">'Value'</span>) <span class="comment">% if motion regressors is on then plot the design matrix over motion regressors</span>
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,<span class="keyword">...</span>
        handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
        handles.designMatrix.offset, 0, 0, 0,<span class="keyword">...</span>
        minY, maxY,<span class="keyword">...</span>
        handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
        []);
    hold <span class="string">on</span>; <span class="comment">% holds the design matrix plot to overlay additional information over it</span>
    <span class="comment">% call plot motion regressor again to overlay the motion regressor over</span>
    <span class="comment">% the design matrix</span>
    set(handles.plotMotionRegressors, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri(<span class="string">'plotMotionRegressors_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    hold <span class="string">off</span>;
<span class="keyword">else</span>
<span class="keyword">if</span> get(handles.detrendBeforeDisplaying, <span class="string">'Value'</span>) == 0 <span class="comment">% then plot non- detreded data</span>
    makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
        handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
        handles.designMatrix.offset, 0, 0, 0,<span class="keyword">...</span>
        handles.roi.minY, handles.roi.maxY,<span class="keyword">...</span>
        handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
        handles.roi.plotData);
<span class="keyword">else</span> <span class="comment">% otherwise plot detrended data</span>
    makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
        handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
        handles.designMatrix.offset, 0, 0, 0,<span class="keyword">...</span>
        handles.roi.minYDetrended, handles.roi.maxYDetrended,<span class="keyword">...</span>
        handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
        handles.roi.plotDataDetrended);
<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% if zoom is on, keep it on</span>
<span class="keyword">if</span> get(handles.turnOnZoomAndPanPlot,<span class="string">'Value'</span>) == 1
    set(handles.turnOnZoomAndPanPlot, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri(<span class="string">'turnOnZoomAndPanPlot_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
guidata(hObject,handles);
set(handles.statusString, <span class="string">'String'</span>, strcat(<span class="string">'Status: '</span>,<span class="keyword">...</span>
    <span class="string">' Shifted '</span>, {<span class="string">' '</span>},<span class="keyword">...</span>
    num2str(handles.designMatrix.conditionCount), {<span class="string">' '</span>},<span class="keyword">...</span>
    <span class="string">'condition(s) by an offset of'</span>,{<span class="string">' '</span>},<span class="keyword">...</span>
    num2str(offset)));

setAxesLimits(handles.plotAxes, x, y);

<span class="keyword">function</span> specifyOnsets2_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to specifyOnsets2 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% s = get(hObject,'String');</span>
<span class="comment">% eval(s)</span>
<span class="comment">% handles.designMatirx.onsets{end+1} = eval(s);</span>
<span class="comment">% % Hints: get(hObject,'String') returns contents of specifyOnsets2 as text</span>
<span class="comment">% %        str2double(get(hObject,'String')) returns contents of specifyOnsets2 as a double</span>
<span class="comment">% guidata(hObject,handles);</span>

<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> specifyOnsets2_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to specifyOnsets2 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> designMatrix_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to designMatrix (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> Untitled_4_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to Untitled_4 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveDesignMatrix_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveDesignMatrix (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in goToCursorLocation.</span>
<span class="keyword">function</span> goToCursorLocation_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to goToCursorLocation (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in helpButton.</span>
<span class="keyword">function</span> helpButton_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to helpButton (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of helpButton</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> help_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to help (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> tutorial_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to tutorial (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> displayHelpWhenIClickAnyting_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to displayHelpWhenIClickAnyting (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> detailedDocumentation_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to detailedDocumentation (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- If Enable == 'on', executes on mouse press in 5 pixel border.</span>
<span class="comment">% --- Otherwise, executes on mouse press in 5 pixel border or over turnOnZoomAndPanMosaic.</span>
<span class="keyword">function</span> turnOnZoomAndPanMosaic_ButtonDownFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to turnOnZoomAndPanMosaic (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --- Executes on button press in cap.</span>
<span class="keyword">function</span> cap_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to cap (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> axesNumber;
axesNumber = 2;
interactivemouse <span class="string">reset</span>;


<span class="comment">% --- Executes on selection change in designMatrixColormap.</span>
<span class="keyword">function</span> designMatrixColormap_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to designMatrixColormap (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
[x y] = getAxesLimits(handles.plotAxes);

contents = cellstr(get(hObject,<span class="string">'String'</span>));
cm = contents{get(hObject,<span class="string">'Value'</span>)};
handles.designMatrix.colormap = cm;
guidata(hObject,handles);
<span class="comment">% function makeDesignMatrixBars(numScans, onsets, durations, offset, okAddACondition, deleteLastCondition, deleteAllConditions, minY, maxY, colormap,axesHandle)</span>
<span class="comment">% makeDesignMatrixBars(handles.scanData.header.numScans,...</span>
<span class="comment">%     handles.designMatrix.onsets,handles.designMatrix.durations,...</span>
<span class="comment">%     handles.designMatrix.offset, 0, 0, 0,...</span>
<span class="comment">%     handles.roi.minY, handles.roi.maxY,...</span>
<span class="comment">%     handles.designMatrix.colormap, handles.plotAxes, handles.roi.plotData);</span>
<span class="keyword">if</span> get(handles.plotMotionRegressors, <span class="string">'Value'</span>) <span class="comment">% if motion regressors is on then plot the design matrix over motion regressors</span>
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,<span class="keyword">...</span>
        handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
        handles.designMatrix.offset, 0, 0, 0,<span class="keyword">...</span>
        minY, maxY,<span class="keyword">...</span>
        handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
        []);
    hold <span class="string">on</span>; <span class="comment">% holds the design matrix plot to overlay additional information over it</span>
    <span class="comment">% call plot motion regressor again to overlay the motion regressor over</span>
    <span class="comment">% the design matrix</span>
    set(handles.plotMotionRegressors, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri(<span class="string">'plotMotionRegressors_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
    hold <span class="string">off</span>;
<span class="keyword">else</span>
<span class="keyword">if</span> get(handles.detrendBeforeDisplaying, <span class="string">'Value'</span>) == 0 <span class="comment">% then plot non- detreded data</span>
    makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
        handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
        handles.designMatrix.offset, 0, 0, 0,<span class="keyword">...</span>
        handles.roi.minY, handles.roi.maxY,<span class="keyword">...</span>
        handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
        handles.roi.plotData);
<span class="keyword">else</span> <span class="comment">% otherwise plot detrended data</span>
    makeDesignMatrixBars(handles.scanData.header.numScans,<span class="keyword">...</span>
        handles.designMatrix.onsets,handles.designMatrix.durations,<span class="keyword">...</span>
        handles.designMatrix.offset, 0, 0, 0,<span class="keyword">...</span>
        handles.roi.minYDetrended, handles.roi.maxYDetrended,<span class="keyword">...</span>
        handles.designMatrix.colormap, handles.plotAxes,<span class="keyword">...</span>
        handles.roi.plotDataDetrended);
<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">% if zoom is on, keep it on</span>
<span class="keyword">if</span> get(handles.turnOnZoomAndPanPlot,<span class="string">'Value'</span>) == 1
    set(handles.turnOnZoomAndPanPlot, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri(<span class="string">'turnOnZoomAndPanPlot_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>
set(handles.plotAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'off'</span>);
set(handles.mosaicAxes, <span class="string">'HandleVisibility'</span> , <span class="string">'on'</span>);
set(handles.statusString, <span class="string">'String'</span>,<span class="keyword">...</span>
    strcat(<span class="string">'Status: Design matrix color map changed to'</span>, {<span class="string">' '''</span>}, handles.designMatrix.colormap,{<span class="string">''''</span>}));
setAxesLimits(handles.plotAxes, x, y);

<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> designMatrixColormap_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to designMatrixColormap (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: popupmenu controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on mouse press over axes background.</span>
<span class="keyword">function</span> mosaicAxes_ButtonDownFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to mosaicAxes (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% if plot zoom is on, turn it off</span>

<span class="comment">%      import java.awt.*;</span>
<span class="comment">%      import java.awt.event.*;</span>
<span class="comment">%      rob=Robot;</span>
<span class="comment">%      rob.mousePress(InputEvent.BUTTON1_MASK);</span>
<span class="comment">%      rob.mouseRelease(InputEvent.BUTTON1_MASK);</span>
<span class="comment">% interactivemouse on;</span>

<span class="comment">%     set(handles.plotAxes, 'HandleVisibility' , 'off');</span>
<span class="comment">%     set(handles.mosaicAxes, 'HandleVisibility' , 'on');</span>
<span class="comment">%     guidata(hObject,handles);</span>
<span class="comment">%     interactivemouse on ;</span>
<span class="comment">%     handles.displayProperties.mosaicZoomOn = 1; % a hack to Keep interactivemouse on whenevr the view changes</span>

<span class="comment">% if get(handles.turnOnZoomAndPanPlot,'Value') == 1</span>
<span class="comment">%     set(handles.turnOnZoomAndPanPlot, 'Value', 0);</span>
<span class="comment">%     guidata(hObject, handles);</span>
<span class="comment">%     hObjectCall = handles.turnOnZoomAndPanPlot;</span>
<span class="comment">%     dfmri('turnOnZoomAndPanPlot_Callback',hObjectCall,eventdata,guidata(hObjectCall));</span>
<span class="comment">% end</span>
<span class="comment">% if plot mosaic is off, turn it on</span>
<span class="comment">% if get(handles.turnOnZoomAndPanMosaic,'Value') == 0</span>
<span class="comment">%     set(handles.turnOnZoomAndPanMosaic, 'Value', 1);</span>
<span class="comment">%     guidata(hObject, handles);</span>
<span class="comment">%     hObjectCall = handles.turnOnZoomAndPanMosaic;</span>
<span class="comment">%     dfmri('turnOnZoomAndPanMosaic_Callback',hObjectCall,eventdata,guidata(hObjectCall));</span>
<span class="comment">% end</span>
<span class="comment">% interactivemouse off;</span>

<span class="keyword">function</span> maskThresholdValue_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to maskThresholdValue (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'String') returns contents of maskThresholdValue as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of maskThresholdValue as a double</span>
<span class="keyword">global</span> maskThreshold;
valueEntered = str2double(get(hObject,<span class="string">'String'</span>));
maskThreshold = valueEntered;
hObject = handles.overlayMask;
dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> maskThresholdValue_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to maskThresholdValue (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in goAbortRoiSelection.</span>
<span class="keyword">function</span> goAbortRoiSelection_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to goAbortRoiSelection (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
selectionMethod = get(handles.roiVoxelsSelection,<span class="string">'Value'</span>);
<span class="keyword">if</span> selectionMethod == 1
    roiVoxelsSelection = <span class="string">'Rectangular'</span>;
<span class="keyword">elseif</span> selectionMethod == 2
    roiVoxelsSelection = <span class="string">'Polygon'</span>;
<span class="keyword">else</span>
    roiVoxelsSelection = <span class="string">'One Voxel at a time'</span>;
<span class="keyword">end</span>

<span class="comment">% Turn off plot axes</span>
set(handles.roiVoxelsSelection, <span class="string">'Value'</span>, selectionMethod);
guidata(hObject, handles);
hObjectCall = handles.roiVoxelsSelection;
dfmri(<span class="string">'roiVoxelsSelection_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));

<span class="comment">% --- Executes on button press in customizeRoiColor.</span>
<span class="keyword">function</span> customizeRoiColor_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to customizeRoiColor (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
set(handles. statusString, <span class="string">'String'</span>, <span class="string">'Status: Please pick a color for the ROI.'</span>);
roiColor = uicolorpicker;
handles.roi.roiColor = roiColor;

    <span class="keyword">if</span> handles.displayProperties.view == 1
        [posX posY] = find(handles.roi.roiData.imgSag);
        pSag = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">elseif</span> handles.displayProperties.view == 2
        [posX posY] = find(handles.roi.roiData.imgCor);
        pCor = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">else</span>
        [posX posY] = find(handles.roi.roiData.imgAxial);
        pAxial = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">end</span>
set(handles.roiColorBox, <span class="string">'BackgroundColor'</span>,handles.roi.roiColor);

<span class="comment">% if handles.displayProperties.view == 1</span>
<span class="comment">%     set(handles.roi.roiHandle.pSag, 'FaceColor', roiColor);</span>
<span class="comment">% elseif handles.displayProperties.view == 2</span>
<span class="comment">%     set(handles.roi.roiHandle.pCor, 'FaceColor', roiColor);</span>
<span class="comment">% else</span>
<span class="comment">%     set(handles.roi.roiHandle.pAxial, 'FaceColor', roiColor);</span>
<span class="comment">% end</span>

guidata(hObject,handles);
set(handles. statusString, <span class="string">'String'</span>, <span class="string">'Status: ROI color changed.'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> specialMasks_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to specialMasks (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> aalMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to aalMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> maskThreshold;

<span class="keyword">if</span> isempty(handles.scanData.data)
    msgbox([<span class="string">'You must have the functional data loaded before you can load '</span><span class="keyword">...</span>
        <span class="string">'the mask. So first load the functional data and then load the '</span><span class="keyword">...</span>
        <span class="string">'mask data. Only then you will be able to see the mask overlayed '</span> <span class="keyword">...</span>
        <span class="string">'over your functional data. If you only want to view the mask data '</span><span class="keyword">...</span>
        <span class="string">'then load it as if it was a functional data. In that case, '</span> <span class="keyword">...</span>
        <span class="string">'just go to the File &gt; Import Data &gt; Functional ...'</span><span class="keyword">...</span>
        <span class="string">'and load it like you would do a regular functional scan. '</span><span class="keyword">...</span>
        <span class="string">'Pheew !!! That was a big warning.'</span>],<span class="keyword">...</span>
        <span class="string">'No functional data found'</span>, <span class="string">'warn'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
path = mfilename(<span class="string">'fullpath'</span>);
path = path(1:end-numel(<span class="string">'\functions\workHorse\dfmri.m'</span>)+2);
pathToAALToolbox = fullfile(path, <span class="string">'toolboxes'</span>, <span class="string">'3aal_for_spm8'</span>);
<span class="comment">% % Construct a questdlg to ascertain if the data is in MNI space</span>
<span class="comment">% choice = questdlg('Is your functional data in MNI sapce?', ...</span>
<span class="comment">%     'Functional Data''s space', ...</span>
<span class="comment">%     'Yes','No','No');</span>
<span class="comment">% % Handle response</span>
<span class="comment">% switch choice</span>
<span class="comment">%     case 'Yes'</span>
<span class="comment">%         [maskData, maskHeader]      = readAALMaskNifti3d(pathToAALToolbox, 'ROI_MNI_V4.nii');</span>
<span class="comment">%</span>
<span class="comment">%     case 'No'</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Coregistering AAL mask to the functional data. This may take a while...Please be patient'</span>);
        coregisterAALMaskToFunctionalData(pathToAALToolbox); pause(0.5);
        [maskData, maskHeader]      = readAALMaskNifti3d(pathToAALToolbox, <span class="string">'rROI_MNI_V4.nii'</span>);
<span class="comment">% end</span>

<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
maskData(find(maskData== 0))= NaN;
<span class="comment">% prepare mask in all three views</span>
mask                        = prepareMask(maskData, handles.m);
handles.aalMask             = mask;
guidata(hObject, handles);
<span class="comment">% Apply region selection</span>
<span class="comment">%prompt the user to slect the regions</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Please select anatomical regions to mask.'</span>);
regions = selectAnatomicalRegions();
numRegions = numel(regions);
mask.maskAxial = handles.aalMask.maskAxial;
mask.maskSagittal = handles.aalMask.maskSagittal;
mask.maskCoronal = handles.aalMask.maskCoronal;
idxMaskAxial = [];
idxMaskSagittal = [];
idxMaskCoronal = [];
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Masking selected anatomical regions....'</span>);
<span class="comment">% read all the user selected regions and make a mask</span>
<span class="keyword">for</span> i = 1 : numRegions
        idxAxial = find(mask.maskAxial == regions(i));
        idxSagittal = find(mask.maskSagittal == regions(i));
        idxCoronal = find(mask.maskCoronal == regions(i));
        idxMaskAxial = [idxMaskAxial;  idxAxial];
        idxMaskSagittal = [idxMaskSagittal;  idxSagittal];
        idxMaskCoronal = [idxMaskCoronal;  idxCoronal];
<span class="keyword">end</span>

maskAxial       = single(nan(size(mask.maskAxial)));
maskSagittal    = single(nan(size(mask.maskSagittal)));
maskCoronal     = single(nan(size(mask.maskCoronal)));

maskAxial(idxMaskAxial)         = mask.maskAxial(idxMaskAxial);
maskSagittal(idxMaskSagittal)   = mask.maskSagittal(idxMaskSagittal);
maskCoronal(idxMaskCoronal)     = mask.maskCoronal(idxMaskCoronal) ;

mask.maskAxial      = maskAxial;
mask.maskSagittal   = maskSagittal;
mask.maskCoronal    = maskCoronal;

<span class="comment">% set the controls, disable the threshold slider</span>
maskThreshold                   = 0.0;
set(handles.maskThresholdSlider,<span class="string">'Value'</span>, 0);
set(handles.maskThresholdSlider,<span class="string">'Enable'</span>, <span class="string">'inactive'</span>);
set(handles.maskThresholdValue,<span class="string">'String'</span>, 0);
set(handles.maskThresholdValue,<span class="string">'Enable'</span>, <span class="string">'inactive'</span>);
set(handles.selectNewAnatomicalRegions, <span class="string">'visible'</span>, <span class="string">'on'</span>);

handles.maskData.data   = mask;
guidata(hObject, handles);

<span class="comment">% invoke overlay mask button</span>
set(handles.overlayMask, <span class="string">'Value'</span>, 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: AAL mask overlayed onto the functional'</span>);

<span class="comment">% --- Executes on button press in selectNewAnatomicalRegions.</span>
<span class="keyword">function</span> selectNewAnatomicalRegions_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to selectNewAnatomicalRegions (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

regions = selectAnatomicalRegions();
numRegions = numel(regions);
mask.maskAxial = handles.aalMask.maskAxial;
mask.maskSagittal = handles.aalMask.maskSagittal;
mask.maskCoronal = handles.aalMask.maskCoronal;
idxMaskAxial = [];
idxMaskSagittal = [];
idxMaskCoronal = [];
<span class="comment">% read all the user selected regions and make a mask</span>
<span class="keyword">for</span> i = 1 : numRegions
        idxAxial = find(mask.maskAxial == regions(i));
        idxSagittal = find(mask.maskSagittal == regions(i));
        idxCoronal = find(mask.maskCoronal == regions(i));
        idxMaskAxial = [idxMaskAxial;  idxAxial];
        idxMaskSagittal = [idxMaskSagittal;  idxSagittal];
        idxMaskCoronal = [idxMaskCoronal;  idxCoronal];
<span class="keyword">end</span>

maskAxial       = single(nan(size(mask.maskAxial)));
maskSagittal    = single(nan(size(mask.maskSagittal)));
maskCoronal     = single(nan(size(mask.maskCoronal)));

maskAxial(idxMaskAxial)         = mask.maskAxial(idxMaskAxial);
maskSagittal(idxMaskSagittal)   = mask.maskSagittal(idxMaskSagittal);
maskCoronal(idxMaskCoronal)     = mask.maskCoronal(idxMaskCoronal) ;

mask.maskAxial      = maskAxial;
mask.maskSagittal   = maskSagittal;
mask.maskCoronal    = maskCoronal;

handles.maskData.data   = mask;
guidata(hObject, handles);

<span class="comment">% invoke overlay mask button</span>
set(handles.overlayMask, <span class="string">'Value'</span>, 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));


<span class="keyword">function</span> intializeBrigtnessContrast(handles,eventdata,hObject,data)
<span class="keyword">global</span> brightness contrast;
<span class="comment">% get brightness contrast value so that the image is always visible</span>

brightness = max(max(data));
contrast   = min(min(data));

set(handles.contrastSlider, <span class="string">'Min'</span>, contrast - 100);
set(handles.contrastSlider, <span class="string">'Max'</span>, brightness-1);
set(handles.brightnessSlider, <span class="string">'Min'</span>, brightness);
set(handles.brightnessSlider, <span class="string">'Max'</span>, brightness + 1000);
set(handles.brightnessSlider, <span class="string">'Value'</span>, brightness);
set(handles.contrastSlider, <span class="string">'Value'</span>, contrast);
set(handles.brightnessValue, <span class="string">'String'</span>, num2str(brightness));
set(handles.contrastValue, <span class="string">'String'</span>, num2str(contrast));
guidata(hObject,handles);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> Maps_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to Maps (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> specialData;
specialData                                    = 1;

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> tmap_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to tmap (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> tmapNifti3D_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to tmapNifti3D (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
niftiFunctional3d_Callback(hObject, eventdata, handles)

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> tmapAnalyze_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to tmapAnalyze (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
analyzeFunctional_Callback(hObject, eventdata, handles)

<span class="keyword">function</span> refreshROIOverlay(handles)
<span class="comment">% overlay ROI</span>
<span class="keyword">if</span> ~isempty(handles.roi.roiData)
    <span class="keyword">if</span> handles.displayProperties.view == 1
        [posX posY] = find(handles.roi.roiData.imgSag);
        pSag = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">elseif</span> handles.displayProperties.view == 2
        [posX posY] = find(handles.roi.roiData.imgCor);
        pCor = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">else</span>
        [posX posY] = find(handles.roi.roiData.imgAxial);
        pAxial = colorpixel(posY,posX,handles.roi.roiColor);
    <span class="keyword">end</span>
<span class="keyword">end</span>



<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMaskedFunctionalData_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMaskedFunctionalData (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveNifti3dDataMasked_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveNifti3dDataMasked (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveAnalyzeDataMasked_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveAnalyzeDataMasked (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMatlabMatMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMatlabMatMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> mask maskThreshold;
<span class="keyword">if</span> isempty(mask)
    msgbox(<span class="string">'You must import a mask before you can save it'</span>, <span class="string">'No mask found !'</span>, <span class="string">'warn'</span>, <span class="string">'modal'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: '</span>);

<span class="comment">% if show maked voxels only is off, then turn it on to get the desired data</span>
<span class="comment">% and turn it off later</span>
showMaskedVoxelsOnlyStatus = get(handles.showMaskedVoxelsOnly, <span class="string">'Value'</span>);
<span class="keyword">if</span> showMaskedVoxelsOnlyStatus == 0
    set(handles.showMaskedVoxelsOnly, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObjectCall = handles.showMaskedVoxelsOnly;
    dfmri(<span class="string">'showMaskedVoxelsOnly_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>

<span class="comment">% convert the mask in the current views in binary</span>
<span class="keyword">if</span>  handles.displayProperties.view == 1
    binaryMask = mask.imgMaskedVoxelsOnlySagittal;
<span class="keyword">elseif</span>  handles.displayProperties.view == 2
    binaryMask = mask.imgMaskedVoxelsOnlyCoronal;
<span class="keyword">else</span>  <span class="comment">% handles.displayProperties.view == 3</span>
    binaryMask = mask.imgMaskedVoxelsOnlyAxial;
<span class="keyword">end</span>
    binaryMask(find(binaryMask)) = 1;

<span class="comment">% pick the ind of the masked voxels</span>
[handles.saveMaskedData.coordsSag handles.saveMaskedData.coordsCor handles.saveMaskedData.coordsAxial] = <span class="keyword">...</span>
    mosaic2VoxelsXScansVector(handles.m);
<span class="keyword">if</span>  handles.displayProperties.view == 1
    idx = handles.saveMaskedData.coordsSag(find(binaryMask));
<span class="keyword">elseif</span>  handles.displayProperties.view == 2
    idx = handles.saveMaskedData.coordsCor(find(binaryMask));
<span class="keyword">else</span>  <span class="comment">% handles.displayProperties.view == 3</span>
    idx = handles.saveMaskedData.coordsAxial(find(binaryMask));
<span class="keyword">end</span>

<span class="comment">% choose masked voxels, set the rest to zero</span>
d.data = single(zeros(numel(binaryMask),1));
d.data(idx,:) = 1;
d.header = handles.scanData.header;
<span class="comment">%discard the zero padding</span>
d.data = d.data(1 : d.header.numSlices * d.header.xRes * d.header.yRes ,:);
<span class="comment">% desquarify</span>
<span class="keyword">if</span> exist(<span class="string">'handles.scanData.header.squarified'</span>,<span class="string">'var'</span>)
    <span class="keyword">if</span> handles.scanData.header.squarified
    d.data = desquarify(handles.scanData.header, d.data);
    <span class="keyword">end</span>
<span class="keyword">end</span>
[FileName,PathName,FilterIndex] = uiputfile(<span class="string">'*.mat'</span>);
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Started saving masked ......Please be patient !!!!'</span>);


d.mask              = mask;
d.maskThreshold     = maskThreshold;
d.binary_mask       = d.data;  <span class="comment">% this is the data user can use later on</span>


<span class="comment">% Construct a questdlg with three options</span>
choice = questdlg([<span class="string">'Do you want to save the header information as well '</span>,<span class="keyword">...</span>
    <span class="string">'alongwith the binary mask? By saving header information, it will be easier '</span><span class="keyword">...</span>
    <span class="string">'for you to load the mask again in Analyze4D.'</span>], <span class="keyword">...</span>
    <span class="string">'Save options'</span>, <span class="keyword">...</span>
    <span class="string">'Yes, save the header information too (Recommended)'</span>,<span class="keyword">...</span>
    <span class="string">'No, just save the binary mask. Don''t save the header information'</span>,<span class="keyword">...</span>
    <span class="string">'Yes, save the header information too (Recommended)'</span>);
<span class="comment">% Handle response</span>
<span class="keyword">switch</span> choice
    <span class="keyword">case</span> <span class="string">'Yes, save the header information too (Recommended)'</span>
        save(fullfile(PathName,FileName),<span class="string">'d'</span>);
    <span class="keyword">case</span> <span class="string">'No, just save the binary mask. Don''t save the header information'</span>
        binary_mask = d.binary_mask;
        save(fullfile(PathName,FileName),<span class="string">'binary_mask'</span>);
<span class="keyword">end</span>


<span class="comment">% return the show masked voxels only to its previous position</span>
<span class="keyword">if</span> showMaskedVoxelsOnlyStatus == 0
    set(handles.showMaskedVoxelsOnly, <span class="string">'Value'</span>, 0);
    guidata(hObject, handles);
    hObjectCall = handles.showMaskedVoxelsOnly;
    dfmri(<span class="string">'showMaskedVoxelsOnly_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
<span class="keyword">end</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: The current mask has been successfully saved. !!!!'</span>);

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveNifti3DMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveNifti3DMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveAnalyzeMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveAnalyzeMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> analyzeMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to analyzeMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> maskThreshold;
maskThreshold                   = 0.5;
set(handles.maskThresholdSlider,<span class="string">'Enable'</span>, <span class="string">'on'</span>);
set(handles.maskThresholdValue,<span class="string">'Enable'</span>, <span class="string">'on'</span>);
set(handles.maskThresholdSlider,<span class="string">'Value'</span>, maskThreshold);
set(handles.maskThresholdValue,<span class="string">'String'</span>, maskThreshold);
set(handles.selectNewAnatomicalRegions, <span class="string">'visible'</span>, <span class="string">'off'</span>);


<span class="keyword">if</span> isempty(handles.scanData.data)
    msgbox([<span class="string">'You must have the functional data loaded before you can load '</span><span class="keyword">...</span>
        <span class="string">'the mask. So first load the functional data and then load the '</span><span class="keyword">...</span>
        <span class="string">'mask data. Only then you will be able to see the mask overlayed '</span> <span class="keyword">...</span>
        <span class="string">'over your functional data. If you only want to view the mask data '</span><span class="keyword">...</span>
        <span class="string">'then load it as if it was a functional data. In that case, '</span> <span class="keyword">...</span>
        <span class="string">'just go to the File &gt; Import Data &gt; Functional ...'</span><span class="keyword">...</span>
        <span class="string">'and load it like you would do a regular functional scan. '</span><span class="keyword">...</span>
        <span class="string">'Pheew !!! That was a big warning.'</span>],<span class="keyword">...</span>
        <span class="string">'No functional data found'</span>, <span class="string">'warn'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
[maskData, maskHeader]      = readMaskAnalyze(1);
<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
maskData(find(maskData== 0))= NaN;

<span class="comment">% prepare mask in all three views</span>
mask                        = prepareMask(maskData, handles.m);
handles.maskData.data       = mask;
<span class="comment">% handles.maskData.header     = maskHeader;</span>
<span class="comment">% handles.maskm               = maskm;</span>
guidata(hObject, handles);

<span class="comment">% invoke overlay mask button</span>
set(handles.overlayMask, <span class="string">'Value'</span>, 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Mask loaded.'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> Untitled_5_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to Untitled_5 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>



<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> askAQuestion_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to askAQuestion (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
sendEmail();

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> reportABug_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to reportABug (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
sendEmail();

<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> aboutAnalyze4D_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to aboutAnalyze4D (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> stats_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to stats (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> matlabMatRoi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to matlabMatRoi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> nifti3dRoi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to nifti3dRoi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> analyzeRoi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to analyzeRoi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMatabMatRoi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMatabMatRoi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveNifti3dRoi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveNifti3dRoi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveAnalyzeRoi_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveAnalyzeRoi (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> statistics_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to statistics (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="keyword">global</span> mask maskThreshold;
<span class="comment">% ROI stats</span>
numRoiVoxels = 0;
<span class="keyword">try</span>
    numRoiVoxels = numel(find(handles.roi.roiData.imgSag));
<span class="keyword">end</span>
<span class="keyword">try</span>
    numRoiVoxels = numel(find(handles.roi.roiData.imgCor));
<span class="keyword">end</span>
<span class="keyword">try</span>
    numRoiVoxels = numel(find(handles.roi.roiData.imgAxial));
<span class="keyword">end</span>

dispString1 = strcat(<span class="string">'Number of voxels in ROI:'</span>,{<span class="string">'            '</span>}, num2str(numRoiVoxels));

<span class="comment">% Mask stats</span>
numMaskedVoxels = 0;
<span class="keyword">try</span>
    numMaskedVoxels = numel(find(mask.maskSagittal/max(max(mask.maskSagittal)) &gt; maskThreshold));
<span class="keyword">end</span>
<span class="keyword">try</span>
    numMaskedVoxels =     numel(find(mask.maskAxial/max(max(mask.maskAxial)) &gt; maskThreshold));
<span class="keyword">end</span>
<span class="keyword">try</span>
    numMaskedVoxels =     numel(find(mask.maskCoronal/max(max(mask.maskCoronal)) &gt; maskThreshold));
<span class="keyword">end</span>

<span class="keyword">if</span> get(handles.overlayMask,<span class="string">'Value'</span>)
dispString2 = strcat(<span class="string">'Number of voxels in Mask:'</span>,{<span class="string">'         '</span>}, num2str(numMaskedVoxels));
<span class="keyword">else</span>
dispString2 = strcat(<span class="string">'Number of voxels in Mask:'</span>,{<span class="string">'         '</span>}, num2str(numMaskedVoxels),{<span class="string">' '</span>},<span class="string">'(Hidden- Enable Overlay Mask to see the masked voxels)'</span>);

<span class="keyword">end</span>

fullString = [dispString1;dispString2];
statistics(fullString);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> checkForUpdates_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to checkForUpdates (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> requestAFeature_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to requestAFeature (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> importReadyMadeAalMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to importReadyMadeAalMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> maskThreshold;

path = mfilename(<span class="string">'fullpath'</span>);
path = path(1:end-numel(<span class="string">'\functions\workHorse\dfmri.m'</span>)+2);
pathToAALToolbox = fullfile(path, <span class="string">'toolboxes'</span>, <span class="string">'3aal_for_spm8'</span>);

        [maskData, maskHeader]      = readMaskNifti3d(1);
<span class="comment">% end</span>

<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
maskData(find(maskData== 0))= NaN;

<span class="comment">% prepare mask in all three views</span>
mask                        = prepareMask(maskData, handles.m);
handles.aalMask             = mask;
guidata(hObject, handles);
<span class="comment">% Apply region selection</span>
<span class="comment">%prompt the user to slect the regions</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Please select anatomical regions to mask.'</span>);
regions = selectAnatomicalRegions();
numRegions = numel(regions);
mask.maskAxial = handles.aalMask.maskAxial;
mask.maskSagittal = handles.aalMask.maskSagittal;
mask.maskCoronal = handles.aalMask.maskCoronal;
idxMaskAxial = [];
idxMaskSagittal = [];
idxMaskCoronal = [];
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Masking selected anatomical regions....'</span>);
<span class="comment">% read all the user selected regions and make a mask</span>
<span class="keyword">for</span> i = 1 : numRegions
        idxAxial = find(mask.maskAxial == regions(i));
        idxSagittal = find(mask.maskSagittal == regions(i));
        idxCoronal = find(mask.maskCoronal == regions(i));
        idxMaskAxial = [idxMaskAxial;  idxAxial];
        idxMaskSagittal = [idxMaskSagittal;  idxSagittal];
        idxMaskCoronal = [idxMaskCoronal;  idxCoronal];
<span class="keyword">end</span>

maskAxial       = single(nan(size(mask.maskAxial)));
maskSagittal    = single(nan(size(mask.maskSagittal)));
maskCoronal     = single(nan(size(mask.maskCoronal)));

maskAxial(idxMaskAxial)         = mask.maskAxial(idxMaskAxial);
maskSagittal(idxMaskSagittal)   = mask.maskSagittal(idxMaskSagittal);
maskCoronal(idxMaskCoronal)     = mask.maskCoronal(idxMaskCoronal) ;

mask.maskAxial      = maskAxial;
mask.maskSagittal   = maskSagittal;
mask.maskCoronal    = maskCoronal;

<span class="comment">% set the controls, disable the threshold slider</span>
maskThreshold                   = 0.0;
set(handles.maskThresholdSlider,<span class="string">'Value'</span>, 0);
set(handles.maskThresholdSlider,<span class="string">'Enable'</span>, <span class="string">'inactive'</span>);
set(handles.maskThresholdValue,<span class="string">'String'</span>, 0);
set(handles.maskThresholdValue,<span class="string">'Enable'</span>, <span class="string">'inactive'</span>);
set(handles.selectNewAnatomicalRegions, <span class="string">'visible'</span>, <span class="string">'on'</span>);

handles.maskData.data   = mask;
guidata(hObject, handles);

<span class="comment">% invoke overlay mask button</span>
set(handles.overlayMask, <span class="string">'Value'</span>, 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: AAL mask overlayed onto the functional'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> aalMaskSlowMethod_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to aalMaskSlowMethod (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> maskThreshold;

<span class="keyword">if</span> isempty(handles.scanData.data)
    msgbox([<span class="string">'You must have the functional data loaded before you can load '</span><span class="keyword">...</span>
        <span class="string">'the mask. So first load the functional data and then load the '</span><span class="keyword">...</span>
        <span class="string">'mask data. Only then you will be able to see the mask overlayed '</span> <span class="keyword">...</span>
        <span class="string">'over your functional data. If you only want to view the mask data '</span><span class="keyword">...</span>
        <span class="string">'then load it as if it was a functional data. In that case, '</span> <span class="keyword">...</span>
        <span class="string">'just go to the File &gt; Import Data &gt; Functional ...'</span><span class="keyword">...</span>
        <span class="string">'and load it like you would do a regular functional scan. '</span><span class="keyword">...</span>
        <span class="string">'Pheew !!! That was a big warning.'</span>],<span class="keyword">...</span>
        <span class="string">'No functional data found'</span>, <span class="string">'warn'</span>);
    <span class="keyword">return</span>;
<span class="keyword">end</span>
path = mfilename(<span class="string">'fullpath'</span>);
path = path(1:end-numel(<span class="string">'\functions\workHorse\dfmri.m'</span>)+2);
pathToAALToolbox = fullfile(path, <span class="string">'toolboxes'</span>, <span class="string">'3aal_for_spm8'</span>);

pathstr = realignAalMaskSlowMethod(pathToAALToolbox); pause(0.5);
[maskData, maskHeader]      = readAALMaskNifti3d(pathToAALToolbox, <span class="string">'wwROI_MNI_V4.nii'</span>);
<span class="comment">% end</span>

<span class="comment">% format the data in mosaic and get the slice labels and separators</span>
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
maskData(find(maskData== 0))= NaN;
<span class="comment">% prepare mask in all three views</span>
mask                        = prepareMask(maskData, handles.m);
handles.aalMask             = mask;
guidata(hObject, handles);
<span class="comment">% Apply region selection</span>
<span class="comment">%prompt the user to slect the regions</span>
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Please select anatomical regions to mask.'</span>);
regions = selectAnatomicalRegions();
numRegions = numel(regions);
mask.maskAxial = handles.aalMask.maskAxial;
mask.maskSagittal = handles.aalMask.maskSagittal;
mask.maskCoronal = handles.aalMask.maskCoronal;
idxMaskAxial = [];
idxMaskSagittal = [];
idxMaskCoronal = [];
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Masking selected anatomical regions....'</span>);
<span class="comment">% read all the user selected regions and make a mask</span>
<span class="keyword">for</span> i = 1 : numRegions
        idxAxial = find(mask.maskAxial == regions(i));
        idxSagittal = find(mask.maskSagittal == regions(i));
        idxCoronal = find(mask.maskCoronal == regions(i));
        idxMaskAxial = [idxMaskAxial;  idxAxial];
        idxMaskSagittal = [idxMaskSagittal;  idxSagittal];
        idxMaskCoronal = [idxMaskCoronal;  idxCoronal];
<span class="keyword">end</span>

maskAxial       = single(nan(size(mask.maskAxial)));
maskSagittal    = single(nan(size(mask.maskSagittal)));
maskCoronal     = single(nan(size(mask.maskCoronal)));

maskAxial(idxMaskAxial)         = mask.maskAxial(idxMaskAxial);
maskSagittal(idxMaskSagittal)   = mask.maskSagittal(idxMaskSagittal);
maskCoronal(idxMaskCoronal)     = mask.maskCoronal(idxMaskCoronal) ;

mask.maskAxial      = maskAxial;
mask.maskSagittal   = maskSagittal;
mask.maskCoronal    = maskCoronal;

<span class="comment">% set the controls, disable the threshold slider</span>
maskThreshold                   = 0.0;
set(handles.maskThresholdSlider,<span class="string">'Value'</span>, 0);
set(handles.maskThresholdSlider,<span class="string">'Enable'</span>, <span class="string">'inactive'</span>);
set(handles.maskThresholdValue,<span class="string">'String'</span>, 0);
set(handles.maskThresholdValue,<span class="string">'Enable'</span>, <span class="string">'inactive'</span>);
set(handles.selectNewAnatomicalRegions, <span class="string">'visible'</span>, <span class="string">'on'</span>);

handles.maskData.data   = mask;
guidata(hObject, handles);

<span class="comment">% invoke overlay mask button</span>
set(handles.overlayMask, <span class="string">'Value'</span>, 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: AAL mask overlayed onto the functional'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> convertDicomsToNIFTI3d_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to convertDicomsToNIFTI3d (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> convertDicomsIMAToNIFTI3d_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to convertDicomsIMAToNIFTI3d (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveTimeCourseFigure_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveTimeCourseFigure (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
h = figure;
set(h, <span class="string">'Name'</span>, <span class="string">'Time Course Figure'</span>);
set(h, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
<span class="comment">% copy axes into the new figure</span>
newax = copyobj(handles.plotAxes,h);
legendHandle = findobj(handles.figure1, <span class="string">'tag'</span>,<span class="string">'legend'</span>);
newax = copyobj(legendHandle,h);

arg = {h;<span class="string">'Time Course Figure'</span>};
saveFig(arg);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMosaicFigure_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMosaicFigure (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% create a new figure for saving and printing</span>
set(handles.mosaicAxes, <span class="keyword">...</span>
  <span class="string">'Box'</span>         , <span class="string">'off'</span>     , <span class="keyword">...</span>
  <span class="string">'TickDir'</span>     , <span class="string">'out'</span>     , <span class="keyword">...</span>
  <span class="string">'TickLength'</span>  , [.00 .00] , <span class="keyword">...</span>
  <span class="string">'XMinorTick'</span>  , <span class="string">'off'</span>      , <span class="keyword">...</span>
  <span class="string">'YMinorTick'</span>  , <span class="string">'off'</span>      , <span class="keyword">...</span>
  <span class="string">'YGrid'</span>       , <span class="string">'off'</span>      , <span class="keyword">...</span>
  <span class="string">'XColor'</span>      , [.3 .3 .3], <span class="keyword">...</span>
  <span class="string">'YColor'</span>      , [.3 .3 .3], <span class="keyword">...</span>
  <span class="string">'LineWidth'</span>   , 1         );
axis(handles.mosaicAxes,<span class="string">'off'</span>); <span class="comment">% so that axis is not printed</span>
<span class="comment">% axis image;</span>
h = figure;
set(h, <span class="string">'Name'</span>, <span class="string">'Mosaic Figure'</span>);

set(h, <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);
<span class="comment">% copy axes into the new figure</span>
newax = copyobj(handles.mosaicAxes,h);
axis(newax,<span class="string">'image'</span>); <span class="comment">% so that axis is not printed</span>

arg = {h;<span class="string">'Mosaic Figure'</span>};
saveFig(arg);
set(handles.mosaicAxes, <span class="keyword">...</span>
  <span class="string">'XColor'</span>      , [0 0 0], <span class="keyword">...</span>
  <span class="string">'YColor'</span>      , [0 0 0], <span class="keyword">...</span>
  <span class="string">'LineWidth'</span>   , 1         );
axis(handles.mosaicAxes,<span class="string">'on'</span>);
<span class="comment">% axis square;</span>
<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveMosaicFigure_ButtonDownFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveMosaicFigure (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="keyword">function</span> todo

<span class="comment">% TODO</span>
<span class="comment">% what if user load multiple masks, currently we dont handle it</span>
<span class="comment">% AAL mask coregisters only to NIFTI reference scan-- add support for other</span>
<span class="comment">% formats as well</span>
<span class="comment">% the export figure for time course does not import legends</span>
<span class="comment">% the export figure crashes if the interactive zzoom is on.</span>
<span class="comment">% in plot zoom is on and you try to chnage mask color, the mosaic is drawn</span>
<span class="comment">% on the plot axes</span>

<span class="comment">% if you add a new roi, a new condition gets added chaging the color of the</span>
<span class="comment">% design matrix</span>

<span class="comment">% the autoscaling of plot axis does not work if the new roi is out of the</span>
<span class="comment">% previous axes limits</span>

<span class="comment">% the linecmeu- the plot color and line thickneess changes everytime a new</span>
<span class="comment">% roi is added</span>

<span class="comment">% add the read header function ffrom working filedtrip[</span>
<span class="keyword">function</span> [x y] = getAxesLimits(axesHandle)
x = get(axesHandle, <span class="string">'XLim'</span>);
y = get(axesHandle, <span class="string">'YLim'</span>);

<span class="keyword">function</span> setAxesLimits(axesHandle, x, y)
set(axesHandle, <span class="string">'XLim'</span>, x);
set(axesHandle, <span class="string">'YLim'</span>, y);


<span class="comment">% --- Executes on button press in checkbox17.</span>
<span class="keyword">function</span> checkbox17_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to checkbox17 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of checkbox17</span>


<span class="comment">% --- Executes on button press in trueColor.</span>
<span class="keyword">function</span> trueColor_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to trueColor (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="keyword">global</span> maskThreshold;

<span class="keyword">if</span> get(handles.trueColor, <span class="string">'Value'</span>)
    tic
    <span class="comment">% turn the trueColor buttons on</span>
    <span class="keyword">if</span> strcmp(get(handles.colormapTrueColorsStaticText, <span class="string">'visible'</span>), <span class="string">'off'</span>)
        set(handles.colormapTrueColorsStaticText, <span class="string">'visible'</span>, <span class="string">'on'</span>);
        set(handles.colormapTrueColors, <span class="string">'visible'</span>, <span class="string">'on'</span>);
        set(handles.customizeMaskColor, <span class="string">'visible'</span>, <span class="string">'off'</span>);
        set(handles.maskColorBox, <span class="string">'visible'</span>, <span class="string">'off'</span>);
    <span class="keyword">end</span>

    <span class="comment">% turn off the mask overlay</span>
    set(handles.overlayMask, <span class="string">'Value'</span>, 0);
    guidata(hObject, handles);
    hObject = handles.overlayMask;
    dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
    set(handles.overlayMask, <span class="string">'Value'</span>, 1); <span class="comment">% jsut show that overlaying is on</span>

    <span class="comment">% find index</span>
    idxAxial        = find(~isnan(handles.maskData.data.maskAxial));
    idxSagittal     = find(~isnan(handles.maskData.data.maskSagittal));
    idxCoronal      = find(~isnan(handles.maskData.data.maskCoronal));

    <span class="comment">% Find voxel values</span>
    maskVoxelValuesAxial    = handles.maskData.data.maskAxial(idxAxial);
    maskVoxelValuesSagittal = handles.maskData.data.maskSagittal(idxSagittal);
    maskVoxelValuesCoronal  = handles.maskData.data.maskCoronal(idxCoronal);

    <span class="comment">%find x y coords</span>
    [axialY axialX]             = find(~isnan(handles.maskData.data.maskAxial));
    [sagittalY sagittalX]       = find(~isnan(handles.maskData.data.maskSagittal));
    [coronalY  coronalX]        = find(~isnan(handles.maskData.data.maskCoronal));

    <span class="comment">%map colorn</span>
    minValue = min(maskVoxelValuesAxial);
    maxValue = max(maskVoxelValuesAxial);
    numSteps = 256;<span class="comment">% chnage it to 256</span>
    chosenMap   = handles.mask.chosenTruecolorColormap;
    <span class="keyword">if</span> strcmp(chosenMap,<span class="string">'None'</span>)
        <span class="keyword">return</span>;
    <span class="keyword">elseif</span> strcmp(chosenMap,<span class="string">'Hot'</span>)
        cm = hot(numSteps);
    <span class="keyword">elseif</span> strcmp(chosenMap,<span class="string">'Fire'</span>)
        cm = fire(numSteps);
    <span class="keyword">elseif</span> strcmp(chosenMap,<span class="string">'Jet'</span>)
        cm = jet(numSteps);
    <span class="keyword">elseif</span> strcmp(chosenMap,<span class="string">'Bone'</span>)
        cm = bone(numSteps);
    <span class="keyword">elseif</span> strcmp(chosenMap,<span class="string">'Winter'</span>)
        cm = winter(numSteps);
    <span class="keyword">elseif</span> strcmp(chosenMap,<span class="string">'Cool'</span>)
        cm = cool(numSteps);
    <span class="keyword">elseif</span> strcmp(chosenMap,<span class="string">'Maximally Distinct'</span>)
    <span class="keyword">else</span>
        cm = hot(numSteps);
    <span class="keyword">end</span>
    range = linspace(minValue, maxValue, numSteps);


    prompt = <span class="string">'define name'</span>
dlg_title = <span class="string">'Input file name'</span>;
num_lines = 1;
def = {<span class="string">'01'</span>};
answer = inputdlg(prompt,dlg_title,num_lines,def);
save(fullfile(pathstr,strcat(<span class="string">'ROIClusters_'</span>, answer{1,1}, <span class="string">'.mat'</span>)), <span class="string">'ROIClusters'</span>);




    maxSagittal = max(max(handles.maskData.data.maskSagittal));
    maxCoronal = max(max(handles.maskData.data.maskCoronal));
    maxAxial = max(max(handles.maskData.data.maskAxial));

    trueColorHandleFull = [];
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Calculating true color for the mask....please be patient!'</span>);
    pause(0.1);
    toc
    tic
    <span class="keyword">for</span> i = 1 : numel(idxAxial)
        <span class="keyword">if</span> handles.displayProperties.view == 1
            <span class="keyword">if</span>  handles.maskData.data.maskSagittal(idxSagittal(i))/maxSagittal &lt; maskThreshold
                <span class="keyword">continue</span>;
            <span class="keyword">else</span>
                maskVoxelValueSagittal = handles.maskData.data.maskSagittal(idxSagittal(i));
                [r,c,V] = findnearest(maskVoxelValueSagittal,range,-1);
                trueColorHandle =  colorpixel(sagittalX(i),sagittalY(i),cm(c,:));
                trueColorHandleFull = [trueColorHandleFull trueColorHandle];
            <span class="keyword">end</span>
        <span class="keyword">elseif</span> handles.displayProperties.view == 2
            <span class="keyword">if</span>  handles.maskData.data.maskCoronal(idxCoronal(i))/maxCoronal &lt; maskThreshold
                <span class="keyword">continue</span>;
            <span class="keyword">else</span>
                maskVoxelValueCoronal = handles.maskData.data.maskCoronal(idxCoronal(i));
                [r,c,V] = findnearest(maskVoxelValueCoronal,range,-1);
                trueColorHandle =  colorpixel(coronalX(i),coronalY(i),cm(c,:));
                trueColorHandleFull = [trueColorHandleFull trueColorHandle];
            <span class="keyword">end</span>
        <span class="keyword">elseif</span> handles.displayProperties.view == 3
            <span class="keyword">if</span>  handles.maskData.data.maskAxial(idxAxial(i))/maxAxial &lt; maskThreshold
                <span class="keyword">continue</span>;
            <span class="keyword">else</span>
                maskVoxelValueAxial = handles.maskData.data.maskAxial(idxAxial(i));
                [r,c,V] = findnearest(maskVoxelValueAxial,range,-1);
                trueColorHandle =  colorpixel(axialX(i),axialY(i),cm(c,:));
                trueColorHandleFull = [trueColorHandleFull trueColorHandle];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        handles.trueColorHandleFull = trueColorHandleFull; <span class="comment">%save the handles</span>
        guidata(hObject,handles);
    <span class="keyword">end</span>
    set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Mask has been colored to true colors!'</span>);
    toc
<span class="keyword">else</span> <span class="comment">%clear all the handles</span>
    <span class="keyword">for</span> i = 1 : numel(handles.trueColorHandleFull)
        delete(handles.trueColorHandleFull(i));
    <span class="keyword">end</span>
    set(handles.colormapTrueColorsStaticText, <span class="string">'visible'</span>, <span class="string">'off'</span>);
    set(handles.colormapTrueColors, <span class="string">'visible'</span>, <span class="string">'off'</span>);
    set(handles.customizeMaskColor, <span class="string">'visible'</span>, <span class="string">'on'</span>);
    set(handles.maskColorBox, <span class="string">'visible'</span>, <span class="string">'on'</span>);
    clear <span class="string">handles.trueColorHandleFull</span>;
    guidata(hObject,handles);

        <span class="comment">% turn on the mask overlay</span>
    set(handles.overlayMask, <span class="string">'Value'</span>, 1);
    guidata(hObject, handles);
    hObject = handles.overlayMask;
    dfmri(<span class="string">'overlayMask_Callback'</span>,hObject,eventdata,guidata(hObject));
<span class="keyword">end</span>
<span class="comment">% Hint: get(hObject,'Value') returns toggle state of trueColor</span>


<span class="comment">% --- Executes on selection change in colormapTrueColors.</span>
<span class="keyword">function</span> colormapTrueColors_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to colormapTrueColors (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: contents = cellstr(get(hObject,'String')) returns colormapTrueColors contents as cell array</span>
<span class="comment">%        contents{get(hObject,'Value')} returns selected item from colormapTrueColors</span>

<span class="comment">% first delete the handles to previous colormaped pixels</span>
    <span class="keyword">for</span> i = 1 : numel(handles.trueColorHandleFull)
        delete(handles.trueColorHandleFull(i));
    <span class="keyword">end</span>
    guidata(hObject,handles);


contents = cellstr(get(hObject,<span class="string">'String'</span>));
handles.mask.chosenTruecolorColormap = contents{get(hObject,<span class="string">'Value'</span>)};
guidata(hObject,handles);
<span class="comment">% invoke trueMaskcolor</span>
hObjectCall = handles.trueColor;
dfmri(<span class="string">'trueColor_Callback'</span>,hObjectCall,eventdata,guidata(hObjectCall));
set(handles.statusString, <span class="string">'String'</span>, <span class="string">'Status: Colormap for the mask changed!'</span>);

<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> colormapTrueColors_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to colormapTrueColors (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: popupmenu controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> saveAALMask_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to saveAALMask (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
path = mfilename(<span class="string">'fullpath'</span>);
path = path(1:end-numel(<span class="string">'\functions\workHorse\dfmri.m'</span>)+2);
pathToAALMaskSlowMethod = fullfile(path, <span class="string">'toolboxes'</span>, <span class="string">'3aal_for_spm8'</span>,<span class="string">'wwROI_MNI_V4.nii'</span>);
pathToAALLabelsSlowMethod = fullfile(path, <span class="string">'toolboxes'</span>, <span class="string">'3aal_for_spm8'</span>,<span class="string">'labels.mat'</span>);

X       = load_untouch_nii(pathToAALMaskSlowMethod);
aalMask = reshape(X.img, [], 1);
path = pickDirUsingJFileChooser();
prompt = {<span class="string">'Enter file name:'</span>};
dlg_title = <span class="string">'Input file name'</span>;
num_lines = 1;
def = {<span class="string">'aalMask'</span>};
answer = inputdlg(prompt,dlg_title,num_lines,def);
copyfile(pathToAALMaskSlowMethod,path);
copyfile(pathToAALLabelsSlowMethod,path);
copyfile(pathToAALMaskSlowMethod, fullfile(path, strcat(answer{1,1},<span class="string">'.nii'</span>)),<span class="string">'f'</span>);
delete(fullfile(path, <span class="string">'wwROI_MNI_V4.nii'</span>));
save(fullfile(path, strcat(answer{1,1},<span class="string">'.mat'</span>)), <span class="string">'aalMask'</span>);


<span class="comment">% --------------------------------------------------------------------</span>
<span class="keyword">function</span> analyzeToNifti_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to analyzeToNifti (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
</pre><img vspace="5" hspace="5" src="dfmri_01.png" alt=""> <p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
function varargout = dfmri(varargin)
% DFMRI MATLAB code for dfmri.fig
%      DFMRI, by itself, creates a new DFMRI or raises the existing
%      singleton*.
%
%      H = DFMRI returns the handle to a new DFMRI or the handle to
%      the existing singleton*.
%
%      DFMRI('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in DFMRI.M with the given input arguments.
%
%      DFMRI('Property','Value',...) creates a new DFMRI or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before dfmri_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to dfmri_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help dfmri

% Last Modified by GUIDE v2.5 16-Jun-2012 09:33:37
% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @dfmri_OpeningFcn, ...
                   'gui_OutputFcn',  @dfmri_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% REPLACE_WITH_DASH_DASH- Executes just before dfmri is made visible.
function dfmri_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to dfmri (see VARARGIN)
% Choose default command line output for dfmri
% global currentlyOpen;
handles.vararginBackup = varargin;
handles.hObjectBackup = hObject;
handles.eventdataBackup = eventdata;
handles.handlesBackup = handles;

set(handles.goAbortRoiSelection,'Visible', 'off');

set(handles. figure1, 'Name', 'Analyze4D');
handles.output = hObject;
% add defaults at start%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
handles.scanData.data                           = [];
handles.scanData.header                         = [];
handles.displayProperties.view                  = 1;
handles.displayProperties.mosaicZoomOn          = 0;
handles.displayProperties.startPoint            = 1;
handles.displayProperties.endPoint              = 1;
handles.displayProperties.brightness            = 1000;
handles.displayProperties.contrast              = 0;
handles.displayProperties.mosaicColormap        = gray;
handles.displayProperties.gridColor             = [1 1 1]*1;
handles.displayProperties.tileLabelColor        = [1 1 1]*0.9;
handles.displayProperties.gridOn                = 1;
handles.displayProperties.tileLabelOn           = 1;
handles.displayProperties.interScanPause        = 0.001;
handles.designMatrix.onsets                     = [];
handles.designMatrix.durations                  = [];
handles.designMatrix.offset                     = 0;
handles.designMatrix.colormap                   = jet;
handles.designMatrix.conditionCount             = 0;
handles.designMatrix.minY                       = -1;
handles.designMatrix.maxY                       = 1;
handles.mosaicHandle                            = [];
handles.plotHandle                              = [];
handles.toolBoxOpenAlready                      = 1;
handles.roi.roiColor                            = [1 1 1];
handles.roi.roiData                             = []; % contains mask
handles.roi.roiHandle                           = [];
handles.roi.roiHandle.pAxial                    = [];
handles.roi.roiHandle.pCor                      = [];
handles.roi.roiHandle.pSag                      = [];
handles.roi.roiData.imgSag= [];
handles.roi.roiData.imgCor= [];
handles.roi.roiData.imgAxial= [];
handles.roi.roiMaskSag                          = [];
handles.roi.roiMaskCor                          = [];
handles.roi.roiMaskAxial                        = [];
handles.roi.plotDataMean                        = [];
handles.roi.plotData                            = [];
handles.roi.plotDataMeanDetrended               = [];
handles.roi.plotDataDetrended                   = [];
handles.roi.maxYDetrended                       = [];
handles.roi.minYDetrended                       = [];
handles.roi.maxY                                = [];
handles.roi.minY                                = [];
handles.img2Coords.axial                        = [];
handles.img2Coords.sagittal                     = [];
handles.img2Coords.coronal                      = [];
handles.maskData.data                           = [];
handles.motionRegressors                        = [];
handles.aalMask                                 = []; %contains the entire aal Mask without any thresholding
handles.aalMask.isActive                        = 0; % a flag to indicate if the AAL mask is active
handles.pauseButtonPressed                      = 0;
handles.mask.chosenTruecolorColormap            = 'None';
global lineWidth lineColor;
lineColor                                       = [1 1 1];
lineWidth                                       = 1.0;

axes(handles.mosaicAxes);
% cla(handles.mosaicAxes);
axes(handles.plotAxes);
% cla(handles.plotAxes);
% plot(1:10,zeros(1,10));
% Define Globals pertaining to mosaic movie panel
global currentScan pauseData reset interScanPause playData firstScanLastScanOn;
playData                                       = 0;
currentScan                                    = 0;
reset                                          = 0;
pauseData                                      = 0;
interScanPause                                 = 0.00001;
firstScanLastScanOn                            = 0;
% Define Globals pertaining to mosaic display properties panel
global tileLabelOn gridOn mosaicColormap brightness contrast brightnessContrastChanging;
tileLabelOn                                    = 1;
gridOn                                         = 1;
mosaicColormap                                 = jet;
brightness                                     = 1000;
contrast                                       = 0;
brightnessContrastChanging                     = 0;
global xLimits yLimits
xLimits = [0 0];
yLimits = [0 0];

global viewSwitching;
viewSwitching = [];

global showSubtractionPlots;
showSubtractionPlots                            = 0;

global overlayMask maskThreshold maskColor showMaskedVoxelsOnly;
maskThreshold                                   = 0.5;
maskColor                                       = [1 1 1];
showMaskedVoxelsOnly                            = 0;
overlayMask                                     = 0;

%for Clickables legend
global plotAxesCl;
plotAxesCl = handles.plotAxes;

global specialData; % special data like tmaps and cmaps for which CLim should be set to auto
specialData                                    = 0;

global sliceLabelColor mosaicGridColor;
sliceLabelColor                                = [1 1 1];
mosaicGridColor                                = [1 1 1];

% disable the visibity of certain items
set(handles.selectNewAnatomicalRegions, 'visible', 'off');
set(handles.showMaskedVoxelsOnly, 'Enable', 'inactive');
set(handles.colormapTrueColorsStaticText, 'visible', 'off');
set(handles.colormapTrueColors, 'visible', 'off');
set(handles.trueColor, 'Enable', 'inactive', 'ForegroundColor', [1 1 1]*0.7);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Update handles structure
guidata(hObject, handles);

% change the software icon
warning('off','MATLAB:HandleGraphics:ObsoletedProperty:JavaFrame');
jframe=get(handles.figure1,'javaframe');
st = dbstack('-completenames');
path = st.file;
path = path(1:end-28);
jIcon=javax.swing.ImageIcon(fullfile(path,'assets','a4d.png'));
jframe.setFigureIcon(jIcon);

set(handles. statusString, 'String', 'Status: Please load data.....')

% UIWAIT makes dfmri wait for user response (see UIRESUME)
% uiwait(handles.figure1);

% REPLACE_WITH_DASH_DASH- Outputs from this function are returned to the command line.
function varargout = dfmri_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function importData_Callback(hObject, eventdata, handles)
% hObject    handle to importData (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function dondersrtfMRI_Callback(hObject, eventdata, handles)
% hObject    handle to dondersrtfMRI (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function rawDataBuffer_Callback(hObject, eventdata, handles)
% hObject    handle to rawDataBuffer (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function pickMocoSeries_Callback(hObject, eventdata, handles)
% hObject    handle to pickMocoSeries (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
[data, header]              = readFunctionalRealTimeMoco(1);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
% format the data in mosaic and get the slice labels and separators
[data,m]        = prepareMosaicData(data, header);
% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]...
    = mosaic2VoxelsXScansVector(m);
% data is the appended dataset
% m contains the location of annotations
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,...
    handles.mosaicAxes);
% prepare to share the data among gui
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
%update data
guidata(hObject, handles);
set(handles.statusString, 'String', 'Status: Functional data loaded');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function pickPaceSeries_Callback(hObject, eventdata, handles)
% hObject    handle to pickPaceSeries (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
[data, header]              = readFunctionalRealTimePace(1);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
% format the data in mosaic and get the slice labels and separators
[data,m]        = prepareMosaicData(data, header);
% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]...
    = mosaic2VoxelsXScansVector(m)
% data is the appended dataset
% m contains the location of annotations
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,...
    handles.mosaicAxes);
% prepare to share the data among gui
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
%update data
guidata(hObject, handles);
set(handles.statusString, 'String', 'Status: Functional data loaded');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function pickAll_Callback(hObject, eventdata, handles)
% hObject    handle to pickAll (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
[data, header]              = readFunctionalRealTimeUntouchedRaw(1);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
% format the data in mosaic and get the slice labels and separators
[data,m]        = prepareMosaicData(data, header);
% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]...
    = mosaic2VoxelsXScansVector(m)
% data is the appended dataset
% m contains the location of annotations
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,...
    handles.mosaicAxes);
% prepare to share the data among gui
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
%update data
guidata(hObject, handles);
set(handles.statusString, 'String', 'Status: Functional data loaded');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function dicomFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to dicomFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function niftiFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to niftiFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function niftiFunctional3d_Callback(hObject, eventdata, handles)
% hObject    handle to niftiFunctional3d (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% dfmri_OpeningFcn(handles.hObjectBackup, handles.eventdataBackup,...
%     handles.handlesBackup, handles.vararginBackup);
% hObject         = handles.hObjectBackup;
% eventdata       = handles.eventdataBackup;
% handles         = handles.handlesBackup;

[data, header]              = readFunctionalNifti3d([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
% format the data in mosaic and get the slice labels and separators
[data,m]        = prepareMosaicData(data, header);
% data is the appended dataset
% m contains the location of annotations
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,...
    handles.mosaicAxes);
% prepare to share the data among gui
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
%update data
guidata(hObject, handles);
set(handles.statusString, 'String', 'Status: Functional data loaded');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function niftiFunctional4d_Callback(hObject, eventdata, handles)
% hObject    handle to niftiFunctional4d (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
[data, header]              = readFunctionalNifti4d([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
% format the data in mosaic and get the slice labels and separators
[data,m]        = prepareMosaicData(data, header);
% data is the appended dataset
% m contains the location of annotations
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,...
    handles.mosaicAxes);
% prepare to share the data among gui
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
%update data
guidata(hObject, handles);
set(handles.statusString, 'String', 'Status: Functional data loaded');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function imaFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to imaFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Read the data
[data, header]              = readFunctionalIma([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
% format the data in mosaic and get the slice labels and separators
[data,m]        = prepareMosaicData(data, header);
% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]...
    = mosaic2VoxelsXScansVector(m)
% data is the appended dataset
% m contains the location of annotations
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,...
    handles.mosaicAxes);
% prepare to share the data among gui
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
%update data
guidata(hObject, handles);
set(handles.statusString, 'String', 'Status: Functional data loaded');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function dcmFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to dcmFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.statusString, 'String', 'Status: Functional data loaded');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function dicFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to dicFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.statusString, 'String', 'Status: Functional data loaded');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function analyzeFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to analyzeFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
[data, header]              = readFunctionalAnalyze([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
% format the data in mosaic and get the slice labels and separators
[data,m]        = prepareMosaicData(data, header);
% data is the appended dataset
% m contains the location of annotations
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,...
    handles.mosaicAxes);
% prepare to share the data among gui
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
%update data
guidata(hObject, handles);
set(handles.statusString, 'String', 'Status: Functional data loaded');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function brainVoyagerFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to brainVoyagerFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.statusString, 'String', 'Status: Functional data loaded');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function afniFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to afniFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.statusString, 'String', 'Status: Functional data loaded');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function mincFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to mincFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.statusString, 'String', 'Status: Functional data loaded');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function Functional_Callback(hObject, eventdata, handles)
% hObject    handle to Functional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global specialData;
specialData                                    = 0; % tmaps/ beta maps



% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function anatomical_Callback(hObject, eventdata, handles)
% hObject    handle to anatomical (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function maltabMatFunctional_Callback(hObject, eventdata, handles)
% hObject    handle to maltabMatFunctional (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
[data, header]              = readFunctionalMatlab([]);
intializeBrigtnessContrast(handles,eventdata,hObject,data);
% format the data in mosaic and get the slice labels and separators
[data,m]        = prepareMosaicData(data, header);
% data is the appended dataset
% m contains the location of annotations
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,...
    handles.mosaicAxes);
% prepare to share the data among gui
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
%update data
guidata(hObject, handles);
set(handles.statusString, 'String', 'Status: Functional data loaded');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function file_Callback(hObject, eventdata, handles)
% hObject    handle to file (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function dicomAnatomical_Callback(hObject, eventdata, handles)
% hObject    handle to dicomAnatomical (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function niftiAnatomical3d_Callback(hObject, eventdata, handles)
% hObject    handle to niftiAnatomical3d (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function analyzeAnatomical_Callback(hObject, eventdata, handles)
% hObject    handle to analyzeAnatomical (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function afniAnatomical_Callback(hObject, eventdata, handles)
% hObject    handle to afniAnatomical (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function brainvoyagerAnatomical_Callback(hObject, eventdata, handles)
% hObject    handle to brainvoyagerAnatomical (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function imaAnatomical_Callback(hObject, eventdata, handles)
% hObject    handle to imaAnatomical (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function dcmAnatomical_Callback(hObject, eventdata, handles)
% hObject    handle to dcmAnatomical (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function dicAnatomical_Callback(hObject, eventdata, handles)
% hObject    handle to dicAnatomical (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function mask_Callback(hObject, eventdata, handles)
% hObject    handle to mask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function importMask_Callback(hObject, eventdata, handles)
% hObject    handle to importMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function niftiMask3d_Callback(hObject, eventdata, handles)
% hObject    handle to niftiMask3d (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global maskThreshold;
maskThreshold                   = 0.5;
set(handles.maskThresholdSlider,'Enable', 'on');
set(handles.maskThresholdValue,'Enable', 'on');
set(handles.maskThresholdSlider,'Value', maskThreshold);
set(handles.maskThresholdValue,'String', maskThreshold);
set(handles.selectNewAnatomicalRegions, 'visible', 'off');


if isempty(handles.scanData.data) 
    msgbox(['You must have the functional data loaded before you can load '...
        'the mask. So first load the functional data and then load the '...
        'mask data. Only then you will be able to see the mask overlayed ' ...
        'over your functional data. If you only want to view the mask data '...
        'then load it as if it was a functional data. In that case, ' ...
        'just go to the File > Import Data > Functional ...'...
        'and load it like you would do a regular functional scan. '...
        'Pheew !!! That was a big warning.'],...
        'No functional data found', 'warn');
    return;
end
[maskData, maskHeader]      = readMaskNifti3d([]);
% format the data in mosaic and get the slice labels and separators
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
% prepare mask in all three views
maskData(find(maskData== 0))= NaN;
mask                        = prepareMask(maskData, handles.m);
handles.maskData.data       = mask;
% handles.maskData.header     = maskHeader;
% handles.maskm               = maskm;
guidata(hObject, handles);

% invoke overlay mask button
set(handles.overlayMask, 'Value', 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
set(handles.statusString, 'String', 'Status: Mask loaded.');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function matlabMatMask_Callback(hObject, eventdata, handles)
% hObject    handle to matlabMatMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global mask maskThreshold;
[a,b,mask,maskThreshold] = readMaskMatlab(1);
if isempty(mask) % if user has loaded a custom mask that he made himself then..
    maskData = a;
    maskHeader = b;
    [maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
    maskData(find(maskData== 0))= NaN;

    % prepare mask in all three views
    mask                        = prepareMask(maskData, maskm);
    handles.maskData.data       = mask;
    maskThreshold               = 0.5;    
    guidata(hObject, handles);
    
    % invoke overlay mask button
    set(handles.overlayMask, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.overlayMask;
    dfmri('overlayMask_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    set(handles.statusString, 'String', 'Status: Mask loaded.');
    
else
    handles.maskData.data.maskAxial       = mask.maskAxial ;
    handles.maskData.data.maskSagittal       = mask.maskSagittal ;
    handles.maskData.data.maskCoronal       = mask.maskCoronal ;
    
    % call overlay mask
    set(handles.overlayMask, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.overlayMask;
    dfmri('overlayMask_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    
    % call slider threshold
    set(handles.maskThresholdSlider, 'Value', maskThreshold);
    guidata(hObject, handles);
    hObjectCall = handles.maskThresholdSlider;
    dfmri('maskThresholdSlider_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    set(handles.statusString, 'String', 'Status: Mask succesfully imported and applied.');
end

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function afniMask_Callback(hObject, eventdata, handles)
% hObject    handle to afniMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.statusString, 'String', 'Status: Mask loaded.');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function brainVoyagerMask_Callback(hObject, eventdata, handles)
% hObject    handle to brainVoyagerMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.statusString, 'String', 'Status: Mask loaded.');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function exit_Callback(hObject, eventdata, handles)
% hObject    handle to exit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveDataMat_Callback(hObject, eventdata, handles)
% hObject    handle to saveDataMat (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

d.header = handles.scanData.header;
numSlices = double(d.header.numSlices);
xRes      = double(d.header.xRes);
yRes      = double(d.header.yRes);
ending    = numSlices*xRes*yRes;
%discard the zero padding
d.data = handles.scanData.data(1 : ending, :);
% desquarify
if exist('handles.scanData.header.squarified','var')
    if handles.scanData.header.squarified
    d.data = desquarify(handles.scanData.header, d.data);
    end
end
[FileName,PathName,FilterIndex] = uiputfile('*.mat');
set(handles.statusString, 'String', 'Status: Started saving masked ......Please be patient !!!!');


% Construct a questdlg with three options
choice = questdlg(['Do you want to save the header information as well ',...
    'alongwith the data? By saving header information, it will be easier '...
    'for you to load the mask again in Analyze4D.'], ...
    'Save options', ...
    'Yes, save the header information too (Recommended)',...
    'No, just save the scan data. Don''t save the header information',...
    'Yes, save the header information too (Recommended)');
% Handle response
switch choice
    case 'Yes, save the header information too (Recommended)'
        save(fullfile(PathName,FileName),'d');
    case 'No, just save the scan data. Don''t save the header information'
        data = d.data;
        save(fullfile(PathName,FileName),'data'); 
end



% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function print_Callback(hObject, eventdata, handles)
% hObject    handle to print (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMatlabMatDataMasked_Callback(hObject, eventdata, handles)
% hObject    handle to saveMatlabMatDataMasked (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global mask;
if isempty(mask)
    msgbox('You must import a mask before you can save the functional data under the mask.', 'No mask found !', 'warn', 'modal');
    return;
end
set(handles.statusString, 'String', 'Status: ');

% if show maked voxels only is off, then turn it on to get the desired data
% and turn it off later
showMaskedVoxelsOnlyStatus = get(handles.showMaskedVoxelsOnly, 'Value');
if showMaskedVoxelsOnlyStatus == 0
    set(handles.showMaskedVoxelsOnly, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.showMaskedVoxelsOnly;
    dfmri('showMaskedVoxelsOnly_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end
% convert the mask in the current views in binary
if  handles.displayProperties.view == 1
    binaryMask = mask.imgMaskedVoxelsOnlySagittal;
elseif  handles.displayProperties.view == 2
    binaryMask = mask.imgMaskedVoxelsOnlyCoronal;    
else  % handles.displayProperties.view == 3
    binaryMask = mask.imgMaskedVoxelsOnlyAxial;    
end
    binaryMask(find(binaryMask)) = 1;
% pick the ind of the masked voxels
[handles.saveMaskedData.coordsSag handles.saveMaskedData.coordsCor handles.saveMaskedData.coordsAxial] = ...
    mosaic2VoxelsXScansVector(handles.m);
if  handles.displayProperties.view == 1
    idx = handles.saveMaskedData.coordsSag(find(binaryMask));
elseif  handles.displayProperties.view == 2
    idx = handles.saveMaskedData.coordsCor(find(binaryMask));    
else  % handles.displayProperties.view == 3
    idx = handles.saveMaskedData.coordsAxial(find(binaryMask));    
end
% choose time courses of the masked voxels, set the rest to zero
type = class(handles.scanData.data);
if strcmp(type,'uint16')
    d.data = uint16(zeros(size(handles.scanData.data)));
else
    d.data = single(zeros(size(handles.scanData.data)));
end
d.data(idx,:) = handles.scanData.data(idx,:);
d.header = handles.scanData.header;

%first discard the zero padded slices in the z-direction
d.data = d.data(1 : d.header.numSlices * d.header.xRes * d.header.yRes, :);
if handles.scanData.header.squarified
    d.data = desquarify(handles.scanData.header, d.data);
end

[FileName,PathName,FilterIndex] = uiputfile('*.mat');
set(handles.statusString, 'String', 'Status: Started saving masked data......Please be patient !!!!');
save(fullfile(PathName,FileName),'d');

% return the show masked voxels only to its previous position
if showMaskedVoxelsOnlyStatus == 0
    set(handles.showMaskedVoxelsOnly, 'Value', 0);
    guidata(hObject, handles);
    hObjectCall = handles.showMaskedVoxelsOnly;
    dfmri('showMaskedVoxelsOnly_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end
set(handles.statusString, 'String', 'Status: Masked Functional Data has been successfully saved. !!!!');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function roi_Callback(hObject, eventdata, handles)
% hObject    handle to roi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveroi_Callback(hObject, eventdata, handles)
% hObject    handle to saveroi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function importRoi_Callback(hObject, eventdata, handles)
% hObject    handle to importRoi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function Movie_Callback(hObject, eventdata, handles)
% hObject    handle to Movie (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function makeMosaicMovie_Callback(hObject, eventdata, handles)
% hObject    handle to makeMosaicMovie (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function markers_Callback(hObject, eventdata, handles)
% hObject    handle to markers (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function loadMarkers_Callback(hObject, eventdata, handles)
% hObject    handle to loadMarkers (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMarkers_Callback(hObject, eventdata, handles)
% hObject    handle to saveMarkers (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMarkersToTextFile_Callback(hObject, eventdata, handles)
% hObject    handle to saveMarkersToTextFile (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMarkersToMatlabMatFile_Callback(hObject, eventdata, handles)
% hObject    handle to saveMarkersToMatlabMatFile (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function markersFromTextFile_Callback(hObject, eventdata, handles)
% hObject    handle to markersFromTextFile (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function markersFromMatlabMat_Callback(hObject, eventdata, handles)
% hObject    handle to markersFromMatlabMat (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function Untitled_1_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function loadMotionRegressors_Callback(hObject, eventdata, handles)
% hObject    handle to loadMotionRegressors (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% reads one motion regressor file
handles.motionRegressors = readSPMStyledMotionRegressors(1);
guidata(hObject,handles);

% plot motion regressors
set(handles.plotMotionRegressors, 'Value', 1);
guidata(hObject, handles);
hObject = handles.plotMotionRegressors;
dfmri('plotMotionRegressors_Callback',hObject,eventdata,guidata(hObject));
set(handles.statusString, 'String', 'Status: Motion regressors loaded.');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function Untitled_2_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function detrendCurrentData_Callback(hObject, eventdata, handles)
% hObject    handle to detrendCurrentData (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveDetrendedData_Callback(hObject, eventdata, handles)
% hObject    handle to saveDetrendedData (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on slider movement.
function slider1_Callback(hObject, eventdata, handles)
% hObject    handle to slider1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'Value') returns position of slider
%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function slider1_CreateFcn(hObject, eventdata, handles)
% hObject    handle to slider1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end


% REPLACE_WITH_DASH_DASH- Executes on slider movement.
function contrastSlider_Callback(hObject, eventdata, handles)
% hObject    handle to contrastSlider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global contrast playData currentScan brightnessContrastChanging firstScanLastScanOn showSubtractionPlots;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
contrast = get(hObject, 'Value');
brightnessContrastChanging = 1;
if contrast == get(handles.contrastSlider,'Min');
    set(handles.contrastSlider,'Min', get(handles.contrastSlider,'Min')-500); % double the limit if that doesnot help
%     msgbox('doubled the limmit');
end

set(handles.contrastValue,'String', num2str(contrast));
if playData == 0 | ~firstScanLastScanOn;
    if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
        currentScan = 1;
    end
    if showSubtractionPlots
        handles.displayProperties. startPoint = currentScan-1;
        handles.displayProperties. endPoint = currentScan ;
    else
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    end
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
end
% overlay ROI
refreshROIOverlay(handles)

brightnessContrastChanging = 0;
% hack to turn on the zoom functionality after this button is pressed
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr the view changes
interactivemouse off;
interactivemouse on;
end
% Hints: get(hObject,'Value') returns position of slider
%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function contrastSlider_CreateFcn(hObject, eventdata, handles)
% hObject    handle to contrastSlider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end



function contrastValue_Callback(hObject, eventdata, handles)
% hObject    handle to contrastValue (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global contrast currentScan playData;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
try
    contrastValueFromUser = str2double(get(hObject,'String'));
    contrast = contrastValueFromUser;
    if playData == 0;
        if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
            currentScan = 1;
        end
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
catch
    msgbox('Please enter a number');
end
% Hints: get(hObject,'String') returns contents of contrastValue as text
%        str2double(get(hObject,'String')) returns contents of contrastValue as a double


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function contrastValue_CreateFcn(hObject, eventdata, handles)
% hObject    handle to contrastValue (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on slider movement.
function brightnessSlider_Callback(hObject, eventdata, handles)
% hObject    handle to brightnessSlider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global brightness playData currentScan brightnessContrastChanging firstScanLastScanOn showSubtractionPlots;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');

brightnessContrastChanging = 1; % prevents the axis reset when brightness is changed
brightness = get(hObject,'Value');
if brightness == get(handles.brightnessSlider,'Max');
    set(handles.brightnessSlider,'Max', get(handles.brightnessSlider,'Max')+2000); % double the limit if that doesnot help
%     msgbox('doubled the limmit');
end
set(handles.brightnessValue,'String', num2str(brightness));
if playData == 0 | ~firstScanLastScanOn 
    if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
        currentScan = 1;
    end
    if showSubtractionPlots
        handles.displayProperties. startPoint = currentScan-1;
        handles.displayProperties. endPoint = currentScan ;
    else
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    end
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
end
refreshROIOverlay(handles);
brightnessContrastChanging = 0;
% hack to turn on the zoom functionality after this button is pressed
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr the view changes
interactivemouse off;
interactivemouse on;
end

% Hints: get(hObject,'Value') returns position of slider
%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function brightnessSlider_CreateFcn(hObject, eventdata, handles)
% hObject    handle to brightnessSlider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end



function brightnessValue_Callback(hObject, eventdata, handles)
% hObject    handle to brightnessValue (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global brightness playData currentScan;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
try
brightnessValueFromUser = str2double(get(hObject,'String'));
brightness = brightnessValueFromUser;
if playData == 0;
    if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
        currentScan = 1;
    end
    handles.displayProperties. startPoint = currentScan;
    handles.displayProperties. endPoint = currentScan;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
end
catch
    msgbox('Please enter a number');
end
% Hints: get(hObject,'String') returns contents of brightnessValue as text
%        str2double(get(hObject,'String')) returns contents of brightnessValue as a double


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function brightnessValue_CreateFcn(hObject, eventdata, handles)
% hObject    handle to brightnessValue (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in showMosaicGrid.
function showMosaicGrid_Callback(hObject, eventdata, handles)
% hObject    handle to showMosaicGrid (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global gridOn currentScan playData;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
if get(hObject,'Value') == 1
    gridOn = 1;
    if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
        currentScan = 1;
    end
    if playData == 0; %if data is not playing then show the current scan only with toggle slice labels
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
    set(handles.statusString, 'String', 'Status: Mosiac grid is now ON');
else
    gridOn = 0;
    if playData == 0;
        if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
            currentScan = 1;
        end
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
    set(handles.statusString, 'String', 'Status: Mosiac grid is now OFF');
end
refreshROIOverlay(handles);

% invoke trueMaskcolor
if get(handles.overlayMask,'Value') && get(handles.trueColor,'Value')
    set(handles.trueColor, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.trueColor;
    dfmri('trueColor_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end

% hack to turn on the zoom functionality after this button is pressed
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end
guidata(hObject,handles);


% REPLACE_WITH_DASH_DASH- Executes on button press in pushbutton1.
function pushbutton1_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in customizeMosaicGridColor.
function customizeMosaicGridColor_Callback(hObject, eventdata, handles)
% hObject    handle to customizeMosaicGridColor (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global mosaicGridColor currentScan playData;
mosaicGridColor = uicolorpicker;
set(handles.mosaicGridColorBox,'BackgroundColor',mosaicGridColor);
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
if get(hObject,'Value') == 1
    gridOn = 1;
    if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
        currentScan = 1;
    end
    if playData == 0; %if data is not playing then show the current scan only with toggle slice labels
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
else
    gridOn = 0;
    if playData == 0;
        if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
            currentScan = 1;
        end
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
end
refreshROIOverlay(handles);
% hack to turn on the zoom functionality after this button is pressed
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end
guidata(hObject,handles);



% REPLACE_WITH_DASH_DASH- Executes on button press in showSliceLabels.
function showSliceLabels_Callback(hObject, eventdata, handles)
% hObject    handle to showSliceLabels (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of showSliceLabels
global tileLabelOn currentScan playData;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
if get(hObject,'Value') == 1
    tileLabelOn = 1;
    if playData == 0; %if data is not playing then show the current scan only with toggle slice labels
        if currentScan == 0 % handles the case when reset has been set and the currentScan is set to zero
            currentScan = 1;
        end
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
        set(handles.statusString, 'String', 'Status: Slice numbers are now visible on each slice');
else
    tileLabelOn = 0;
    if playData == 0;
        if currentScan == 0
            currentScan = 1;
        end
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
    set(handles.statusString, 'String', 'Status: Slice numbering has been disabled');
end
refreshROIOverlay(handles);

% invoke trueMaskcolor
if get(handles.overlayMask,'Value') && get(handles.trueColor,'Value')
    set(handles.trueColor, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.trueColor;
    dfmri('trueColor_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end

% hack to turn on the zoom functionality after this button is pressed
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end

guidata(hObject,handles);

% REPLACE_WITH_DASH_DASH- Executes on button press in customizeSliceLabelColor.
function customizeSliceLabelColor_Callback(hObject, eventdata, handles)
% hObject    handle to customizeSliceLabelColor (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global sliceLabelColor currentScan playData;
sliceLabelColor = uicolorpicker;
set(handles.sliceLabelColorBox,'BackgroundColor',sliceLabelColor);
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
if get(hObject,'Value') == 1
    gridOn = 1;
    if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
        currentScan = 1;
    end
    if playData == 0; %if data is not playing then show the current scan only with toggle slice labels
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
else
    gridOn = 0;
    if playData == 0;
        if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
            currentScan = 1;
        end
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
end
refreshROIOverlay(handles);
% hack to turn on the zoom functionality after this button is pressed
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end
guidata(hObject,handles);

% REPLACE_WITH_DASH_DASH- Executes on button press in captureRestorePoint.
function captureRestorePoint_Callback(hObject, eventdata, handles)
% hObject    handle to captureRestorePoint (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in pushbutton5.
function pushbutton5_Callback(hObject, eventdata, handles)
% hObject    handle to pushbutton5 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in loadRestorePointMosaic.
function loadRestorePointMosaic_Callback(hObject, eventdata, handles)
% hObject    handle to loadRestorePointMosaic (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
interactivemouse restore;

if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end


% REPLACE_WITH_DASH_DASH- Executes on button press in captureRestorePointPlot.
function captureRestorePointPlot_Callback(hObject, eventdata, handles)
% hObject    handle to captureRestorePointPlot (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global axesNumber;
axesNumber = 1;
interactivemouse reset;
% REPLACE_WITH_DASH_DASH- Executes on button press in turnOnZoomAndPanMosaic.
function turnOnZoomAndPanMosaic_Callback(hObject, eventdata, handles)
% hObject    handle to turnOnZoomAndPanMosaic (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% AXES(handles.mosaicHandle);
% interactivemouse(handles.mosaicHandle);
% set the current axes as the mosiac axes
global xLimits yLimits;
if (get(hObject,'Value') == get(hObject,'Max'))
    % if no data is present then do not let user toggle the button
    if isempty(handles.scanData.data)
        msgbox('Nothing to zoom into Your highness!!. Please first load any data by going to the File menu.','Warning','warn','modal');
        set(handles.turnOnZoomAndPanMosaic, 'Value', 0);
        return;
    end
    % Turn off plot axes
    set(handles.turnOnZoomAndPanPlot, 'Value', 0);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri('turnOnZoomAndPanPlot_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    
    % turn on mosaic axes
    set(handles.plotAxes, 'HandleVisibility' , 'off');
    set(handles.mosaicAxes, 'HandleVisibility' , 'on');
    guidata(hObject,handles);
    interactivemouse on ;
    handles.displayProperties.mosaicZoomOn = 1; % a hack to Keep interactivemouse on whenevr the view changes  

else
    % Checkbox is unchecked-take appropriate action
    set(handles.mosaicAxes, 'HandleVisibility' , 'on'); % restore the other axes
    set(handles.plotAxes, 'HandleVisibility' , 'on'); % restore the other axes
    guidata(hObject,handles);
    try
        interactivemouse off ;
    catch
    end
    handles.displayProperties.mosaicZoomOn          = 0; % a hack to Keep interactivemouse on whenevr the view changes
    set(handles.plotAxes, 'HandleVisibility' , 'off'); % restore the other axes
    set(handles.mosaicAxes, 'HandleVisibility' , 'off'); % restore the other axes
end
% Hint: get(hObject,'Value') returns toggle state of turnOnZoomAndPanMosaic
guidata(hObject,handles);

% REPLACE_WITH_DASH_DASH- Executes on button press in turnOnZoomAndPanPlot.
function turnOnZoomAndPanPlot_Callback(hObject, eventdata, handles)
% hObject    handle to turnOnZoomAndPanPlot (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global xLimits yLimits;

if (get(hObject,'Value') == get(hObject,'Max'))
    % if no data is present then do not let user toggle the button
    if isempty(handles.motionRegressors) & isempty(handles.roi.plotData)
        msgbox('Nothing to zoom into Your highness!!. Please select an ROI in the Spatio-Temporal Analysis panel or Load SPM motion regressors. ','Warning','warn','modal');
        set(handles.turnOnZoomAndPanPlot, 'Value', 0);
        return;
    end
    % Turn off plot axes
    set(handles.turnOnZoomAndPanMosaic, 'Value', 0);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanMosaic;
    dfmri('turnOnZoomAndPanMosaic_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    
    % turn on mosaic axes
    set(handles.mosaicAxes, 'HandleVisibility' , 'off');
    set(handles.plotAxes, 'HandleVisibility' , 'on');
    guidata(hObject,handles);
    interactivemouse on ;
    handles.displayProperties.plotZoomOn = 1; % a hack to Keep interactivemouse on whenevr the view changes  

else
    % Checkbox is unchecked-take appropriate action
    set(handles.plotAxes, 'HandleVisibility' , 'on'); % restore the other axes
    set(handles.mosaicAxes, 'HandleVisibility' , 'on'); % restore the other axes
    guidata(hObject,handles);
    try
        interactivemouse off ;
    catch
    end
    handles.displayProperties.plotZoomOn          = 0; % a hack to Keep interactivemouse on whenevr the view changes
    set(handles.mosaicAxes, 'HandleVisibility' , 'off'); % restore the other axes
    set(handles.plotAxes, 'HandleVisibility' , 'off'); % restore the other axes
end
% Hint: get(hObject,'Value') returns toggle state of turnOnZoomAndPanMosaic
guidata(hObject,handles);


% REPLACE_WITH_DASH_DASH- Executes on button press in loadRestorePointPlot.
function loadRestorePointPlot_Callback(hObject, eventdata, handles)
% hObject    handle to loadRestorePointPlot (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global axesNumber;
axesNumber = 1;
interactivemouse restore;

% REPLACE_WITH_DASH_DASH- Executes on button press in play.
function play_Callback(hObject, eventdata, handles)
% hObject    handle to play (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global currentScan playData pauseData xLimits yLimits firstScanLastScanOn;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
% Play the data from start it the all the scans have been played and the
% play button is pressed again
firstScanLastScanOn = 0;
if currentScan == handles.scanData.header.numScans;
    currentScan = 0;
end
% otherwise proceed as normal
originalColor = [0.3490    0.2000    0.3294]; %get(hObject, 'BackgroundColor');
playData                                = 1;
set(hObject,'BackgroundColor', [0.5137    0.3804    0.4824]);
handles.displayProperties.startPoint    = currentScan + 1;
currentScan = currentScan + 1;
handles.displayProperties.endPoint      = handles.scanData.header.numScans;
guidata(hObject,handles);
set(handles.statusString, 'String', 'Status: Playing data..... Press Pause to stop playing.');
[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
    handles.displayProperties, handles.mosaicAxes);
playData                                = 0;
set(hObject, 'BackgroundColor', originalColor);
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr the view changes
    try
        interactivemouse off;
    catch
    end
    interactivemouse on;
end
set(handles.statusString, 'String', 'Status: Done.' );
refreshROIOverlay(handles);

% REPLACE_WITH_DASH_DASH- Executes on button press in pause.
function pause_Callback(hObject, eventdata, handles)
% hObject    handle to pause (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global pauseData playData;
if playData % if something is playing then pause it
    set(handles.plotAxes, 'HandleVisibility' , 'off');
    set(handles.mosaicAxes, 'HandleVisibility' , 'on');
    pauseData = 1;
    playData  = 0;
    if handles.displayProperties.mosaicZoomOn
        handles.displayProperties.mosaicZoomOn
        try
            interactivemouse off;
        catch
        end
        interactivemouse on;
    end
    guidata(hObject,handles)
else
    set(handles.statusString, 'String', 'Status: Nothing to pause.');  
    return;
end
refreshROIOverlay(handles);

% REPLACE_WITH_DASH_DASH- Executes on button press in reset.
function reset_Callback(hObject, eventdata, handles)
% hObject    handle to reset (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global currentScan playData;
currentScan                             = 0;
playData                                = 0; % pauseData if already running play
handles.displayProperties.startPoint    = currentScan + 1;
handles.displayProperties.endPoint      = handles.displayProperties.startPoint;
guidata(hObject,handles);
[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
    handles.displayProperties, handles.mosaicAxes);
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end
set(handles.statusString, 'String', 'Status: Resetted to Volume 1.');  
refreshROIOverlay(handles);

% REPLACE_WITH_DASH_DASH- Executes on button press in firstScanLastScanLoop.
function firstScanLastScanLoop_Callback(hObject, eventdata, handles)
global firstScanLastScanOn currentScan playData;
if ~isempty(handles.scanData.data)
    button_state = get(hObject,'Value');
    originalColor = [0.3490    0.2000    0.3294];
    
    while button_state == get(hObject,'Max')
        set(handles.statusString, 'String', 'Status: Playing the data in first Scan-last Scan loop.');
        set(hObject,'BackgroundColor',[0.5137    0.3804    0.4824] );
        % Toggle button is pressed-take appropriate action
        firstScanLastScanOn = 1;
        playData             = 1;
        firstScanLastScanData = handles.scanData.data(:,[1 end]);
        currentScan = 0;
        handles.displayProperties.startPoint    = currentScan + 1;
        handles.displayProperties.endPoint      = currentScan + 2;
        [mosaicHandle]  = mosaicLoop(firstScanLastScanData, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
        currentScan = 0;
        button_state = get(hObject,'Value');
    end
    set(hObject,'BackgroundColor',originalColor);
    firstScanLastScanOn = 0;
    guidata(hObject,handles);
    set(handles.statusString, 'String', 'Status: Stopped first Scan-last Scan loop.');
    
    % hack to turn on the zoom functionality after this button is pressed
    if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
        try
            interactivemouse off;
        catch
        end
        interactivemouse on;
    end
    refreshROIOverlay(handles);
else %if scanData is emtpy, then retun
    set(handles.firstScanLastScanLoop, 'Value', 0);
    set(handles.statusString, 'String', 'Status: You must load at least two functional scans first for this option to work.');
    return;
end

% REPLACE_WITH_DASH_DASH- Executes on selection change in interescanPauseIntervalPopupMenu.
function interescanPauseIntervalPopupMenu_Callback(hObject, eventdata, handles)
% hObject    handle to interescanPauseIntervalPopupMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% global interScanPause;
% contents            = cellstr(get(hObject,'String')) ;
% contents{get(hObject,'Value')}
% interScanPause      = contents;
% % hack to turn on the zoom functionality after this button is pressed
% if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
%     try
%     interactivemouse off;
%     catch
%     end
%     interactivemouse on;
% end
% Hints: contents = cellstr(get(hObject,'String')) returns interescanPauseIntervalPopupMenu contents as cell array
%        contents{get(hObject,'Value')} returns selected item from interescanPauseIntervalPopupMenu


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function interescanPauseIntervalPopupMenu_CreateFcn(hObject, eventdata, handles)
% hObject    handle to interescanPauseIntervalPopupMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in overlayMask.
function overlayMask_Callback(hObject, eventdata, handles)
% hObject    handle to overlayMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global overlayMask mask currentScan showSubtractionPlots maskThreshold showMaskedVoxelsOnly;

if isempty(handles.scanData.data) & get(hObject, 'Value')
    msgbox(['You must have functional data loaded before you can overlay '...
        'mask over it. So first load the functional data and then load the '...
        'mask data. Only then you will be able to see the mask overlayed ' ...
        'over your functional data.'], 'No functional data found', 'warn');
    set(handles.overlayMask,'Value',0);
    return;
end

if get(hObject, 'Value') == 1

    % turn the trueColor buttons on
    set(handles.trueColor, 'Enable', 'on', 'ForegroundColor', [1 1 1]);
    
    if isempty(handles.maskData.data)
        msgbox(['No mask found. Please go the the Mask menu and load the mask ' ...
            'data. The mask should be in the same space as the data ' ...
            'itself. This means that if you have created Gray, White or CSF '...
            'masks, then you need to reslice these masks to your functional '...
            'data and then load them.'], 'Error', 'warn');
        set(handles.overlayMask, 'Value', 0);
        return;
    else
        mask = handles.maskData.data;
    end
    overlayMask = 1;
    set(handles.showMaskedVoxelsOnly, 'Enable', 'on');
    set(handles.showMaskedVoxelsOnly, 'ForegroundColor', [1 1 1]);

    set(handles.maskThresholdValue, 'String' , num2str(maskThreshold));
    if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
        currentScan = 1;
    end
    if showSubtractionPlots
%         msgbox('turn off subtraction plots')
        set(handles.showSubtractionPlots, 'Value', 0);
        hObjectCall = handles.showSubtractionPlots;
        dfmri('showSubtractionPlots_Callback',hObjectCall,eventdata,guidata(hObjectCall))
    else
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    end
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
%     if get(handles.trueColor, 'Value') % if true colors is on then
%         % invoke trueMaskcolor
%         set(handles.trueColor, 'Value', 1);
%         hObjectCall = handles.trueColor;
%         dfmri('trueColor_Callback',hObjectCall,eventdata,guidata(hObjectCall));
%     end
else
    overlayMask = 0;
    showMaskedVoxelsOnly = 0;
    mask = handles.maskData.data;
    % turn off trueColor button 
    set(handles.trueColor, 'Enable', 'on','Value',1, 'ForegroundColor', [1 1 1]);

    % disable control
    set(handles.showMaskedVoxelsOnly, 'ForegroundColor', [1 1 1]*0.7);
    set(handles.showMaskedVoxelsOnly, 'Value', 0);
    set(handles.showMaskedVoxelsOnly, 'Enable', 'inactive');
    
    if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
        currentScan = 1;
    end
    if showSubtractionPlots
        %msgbox('turn off subtraction plots');
        set(handles.showSubtractionPlots, 'Value', 0);
        hObjectCall = handles.showSubtractionPlots;
        dfmri('showSubtractionPlots_Callback',hObjectCall,eventdata,guidata(hObjectCall));
%         set(handles.showSubtractionPlots, 'Value', 0);
    else
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    end

    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
end


% overlay ROI
if ~isempty(handles.roi.roiData)
    if handles.displayProperties.view == 1
        [posX posY] = find(handles.roi.roiData.imgSag);
        pSag = colorpixel(posY,posX,handles.roi.roiColor);
    elseif handles.displayProperties.view == 2
        [posX posY] = find(handles.roi.roiData.imgCor);
        pCor = colorpixel(posY,posX,handles.roi.roiColor);
    else
        [posX posY] = find(handles.roi.roiData.imgAxial);
        pAxial = colorpixel(posY,posX,handles.roi.roiColor);
    end
end

if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
        interactivemouse off;
    catch
    end
    interactivemouse on;
end

% REPLACE_WITH_DASH_DASH- Executes on slider movement.
function maskThresholdSlider_Callback(hObject, eventdata, handles)
% hObject    handle to maskThresholdSlider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'Value') returns position of slider
%        get(hObject,'Min') and get(hObject,'Max') to determine range of slider
global mask currentScan showSubtractionPlots maskThreshold;
if get(handles.overlayMask, 'Value') == 1    
    % if there is ROI data then clear it when the slider is moved 
    if ~isempty(handles.roi.roiData)
        Object = handles.clearAllRois;
        dfmri('clearAllRois_Callback',Object,eventdata,guidata(Object));
    end
    
    maskThreshold = get(hObject,'Value') ;
    set(handles.maskThresholdValue, 'String' , num2str(maskThreshold));
    mask = handles.maskData.data;
    if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
        currentScan = 1;
    end
    if showSubtractionPlots
        msgbox('turn off subtraction plots')
    else
        handles.displayProperties. startPoint = currentScan;
        handles.displayProperties. endPoint = currentScan;
    end
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
    % invoke trueMaskcolor
    if get(handles.trueColor, 'Value')
        hObjectCall = handles.trueColor;
        dfmri('trueColor_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    end
%  refreshROIOverlay(handles);   
    if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
        try
            interactivemouse off;
        catch
        end
        interactivemouse on;
    end    
end



% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function maskThresholdSlider_CreateFcn(hObject, eventdata, handles)
% hObject    handle to maskThresholdSlider (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: slider controls usually have a light gray background.
if isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor',[.9 .9 .9]);
end


% REPLACE_WITH_DASH_DASH- Executes on button press in customizeMaskColor.
function customizeMaskColor_Callback(hObject, eventdata, handles)
% hObject    handle to customizeMaskColor (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


global maskColor;
maskColor = uicolorpicker;
set(handles.maskColorBox, 'BackgroundColor', maskColor);
dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
guidata(hObject,handles);

% REPLACE_WITH_DASH_DASH- Executes on button press in showMaskedVoxelsOnly.
function showMaskedVoxelsOnly_Callback(hObject, eventdata, handles)
% hObject    handle to showMaskedVoxelsOnly (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global showMaskedVoxelsOnly;

if get(hObject,'Value') == 1
%     if get(handles.overlayMask,'Value') == 1
%         set(handles.showMaskedVoxelsOnly, 'Enable', 'off');
%         return;
%     end
    showMaskedVoxelsOnly = 1;
    dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
    set(handles.customizeMaskColor, 'Enable','inactive');
else
    showMaskedVoxelsOnly = 0;
    hObject = handles.overlayMask;
    dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
    set(handles.customizeMaskColor, 'Enable','on');

end
[x y] = getAxesLimits(handles.mosaicAxes);
setAxesLimits(handles.mosaicAxes, x, y);
% Hint: get(hObject,'Value') returns toggle state of showMaskedVoxelsOnly


% REPLACE_WITH_DASH_DASH- Executes on button press in selectVovelsInARectangularRoi.
function selectVovelsInARectangularRoi_Callback(hObject, eventdata, handles)
% hObject    handle to selectVovelsInARectangularRoi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in selectOneVoxelAtATime.
function selectOneVoxelAtATime_Callback(hObject, eventdata, handles)
% hObject    handle to selectOneVoxelAtATime (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in checkbox8.
function checkbox8_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox8 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox8


% REPLACE_WITH_DASH_DASH- Executes on selection change in listbox3.
function listbox3_Callback(hObject, eventdata, handles)
% hObject    handle to listbox3 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = cellstr(get(hObject,'String')) returns listbox3 contents as cell array
%        contents{get(hObject,'Value')} returns selected item from listbox3


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function listbox3_CreateFcn(hObject, eventdata, handles)
% hObject    handle to listbox3 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in radiobutton3.
function radiobutton3_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton3 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton3


% REPLACE_WITH_DASH_DASH- Executes on button press in radiobutton4.
function radiobutton4_Callback(hObject, eventdata, handles)
% hObject    handle to radiobutton4 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of radiobutton4


% REPLACE_WITH_DASH_DASH- Executes on selection change in nVoxels.
function nVoxels_Callback(hObject, eventdata, handles)
% hObject    handle to nVoxels (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = cellstr(get(hObject,'String')) returns nVoxels contents as cell array
%        contents{get(hObject,'Value')} returns selected item from nVoxels


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function nVoxels_CreateFcn(hObject, eventdata, handles)
% hObject    handle to nVoxels (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in colorizeRoiVoxels.
function colorizeRoiVoxels_Callback(hObject, eventdata, handles)
% hObject    handle to colorizeRoiVoxels (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Hint: get(hObject,'Value') returns toggle state of colorizeRoiVoxels


% REPLACE_WITH_DASH_DASH- Executes on button press in clearAllRois.
function clearAllRois_Callback(hObject, eventdata, handles)
% hObject    handle to clearAllRois (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global currentScan showSubtractionPlots xLimits yLimits;
handles.roi.roiHandle                           = [];
handles.roi.roiHandle.pSag                      = [];
handles.roi.roiHandle.pCor                      = [];
handles.roi.roiHandle.pAxial                    = [];
handles.roi.roiData.imgSag                      = [];
handles.roi.roiData.imgCor                      = [];
handles.roi.roiData.imgAxial                    = [];
handles.roi.roiMaskSag                         = [];
handles.roi.roiMaskCor                         = [];
handles.roi.roiMaskAxial                         = [];
handles.img2Coords.sagittal                     = [];
handles.img2Coords.coronal                      = [];
handles.img2Coords.axial                        = [];
handles.roi.plotDataMean                        = [];
handles.roi.plotData                            = [];
handles.roi.maxY                                = [];
handles.roi.minY                                = [];
handles.roi.roiData                             = [];
handles.roi.plotDataMeanDetrended               = [];
handles.roi.plotDataDetrended                   = [];
handles.roi.maxYDetrended                       = [];
handles.roi.minYDetrended                       = [];
guidata(hObject, handles);

if get(handles.turnOnZoomAndPanPlot,'Value')
    set(handles.turnOnZoomAndPanPlot, 'Value', 0);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri('turnOnZoomAndPanPlot_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end

if currentScan == 0 % handle the situation when reset has been pressed and the currentScan =0
    currentScan = 1;
end
if showSubtractionPlots
    msgbox('turn off subtraction plots')
else
    handles.displayProperties. startPoint = currentScan;
    handles.displayProperties. endPoint = currentScan;
end


% Clear the mosaic
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');


%get the axis state
xLimits = get(handles.mosaicAxes,'XLim'); % this prevent the zoom state of plot to be copied to the zoom state of mosiac
yLimits = get(handles.mosaicAxes,'YLim');

[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
    handles.displayProperties, handles.mosaicAxes);

% Clear the plot axes with previously plotted ROI time series
set(handles.plotAxes, 'HandleVisibility' , 'on');
set(handles.mosaicAxes, 'HandleVisibility' , 'off');
cla(handles.plotAxes);

set(handles.plotAxes, 'XLim', [0,1]);% prevent loss of display the user has cleared all th roi and proceeds to select a new one
set(handles.plotAxes, 'YLim', [0,1]);

% restore the control to mosaic
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');

if get(handles.trueColor,'Value')
    % invoke trueMaskcolor
    hObjectCall = handles.trueColor;
    dfmri('trueColor_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    set(handles.statusString, 'String', 'Status: Colormap for the mask changed!');
end

if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
        interactivemouse off;
    catch
    end
    interactivemouse on;
end

set(handles.statusString,'String','Status: All ROIs cleared.');
guidata(hObject, handles);

% REPLACE_WITH_DASH_DASH- Executes on button press in plotMotionRegressors.
function plotMotionRegressors_Callback(hObject, eventdata, handles)
% hObject    handle to plotMotionRegressors (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
if isempty(handles.motionRegressors) & get(handles.plotMotionRegressors, 'Value')
    set(handles.plotMotionRegressors, 'Value',0);
    msgbox('You have not loaded any motions regressors. Please go to the Motion Regressors menu and load the motion regressors.','Are you kidding me !!!', 'warn');
    return;
end
set(handles.plotAxes, 'HandleVisibility' , 'on'); % so that plot is in the plot axes
set(handles.mosaicAxes, 'HandleVisibility' , 'off');

if get(hObject,'Value')
    time        = handles.motionRegressors.time;
    x           = handles.motionRegressors.x;
    y           = handles.motionRegressors.y;
    z           = handles.motionRegressors.z;
    yaw         = handles.motionRegressors.yaw;
    pitch       =  handles.motionRegressors.pitch;
    roll        = handles.motionRegressors.roll;
    h = plot(handles.plotAxes, time,x, time,y, time,z, time,yaw,...
        time,pitch, time,roll,'LineSmoothing','on');
    %     draggable(h);
    set(handles.plotAxes,'Color',[0 0 0]); % change the plot background to black
    set(handles.plotAxes,'XLim',[1 numel(time)+ floor(numel(time)/6.5)]); % change the plot background to black
    set(h,'uicontextmenu',linecmenu);
    clickableLegend(handles.plotAxes, {'X Translation','Y Translation','Z Translation','Yaw','Pitch', 'Roll'}, 'Location', 'east');
else
%     cla(handles.plotAxes);
    delete(allchild(handles.plotAxes))
end
set(handles.plotAxes, 'HandleVisibility' , 'off'); % so that plot is in the plot axes
set(handles.mosaicAxes, 'HandleVisibility' , 'on');

% REPLACE_WITH_DASH_DASH- Executes on button press in showSubtractionPlots.
function showSubtractionPlots_Callback(hObject, eventdata, handles)
% hObject    handle to showSubtractionPlots (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global playData firstScanLastScanOn currentScan  brightnessContrastChanging;
global showSubtractionPlots;
if (isempty(handles.scanData.data))
    if get(handles.showSubtractionPlots, 'Value')
        msgbox(['A Subtraction Plot is the difference image of two consecutive '...
            'functional scans and is used to assess how much motion occured between '...
            'two consecutive scans. Therefore, it is necessary to have functional data '...
            'available for this option to work. So please first load your functional '...
            'scans by going to File > Import Data > Functional. Once you have done '...
            'that, you can activate this option.'], 'No functional data found', 'warn');
     set(handles.showSubtractionPlots, 'Value', 0);
     guidata(hObject,handles);
    end
    return;
end

if get(hObject,'Value')
    showSubtractionPlots                            = 1;
    firstScanLastScanOn                             = 1;
    brightnessContrastChanging                      = 1;
    tmp = currentScan;
    
    if ~playData & firstScanLastScanOn
        if currentScan==0
            currentScan = currentScan +2;
        end
        handles.displayProperties. startPoint = currentScan-1;
        handles.displayProperties. endPoint = currentScan;
        [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
            handles.displayProperties, handles.mosaicAxes);
    end
    
    firstScanLastScanOn                             = 0;
    brightnessContrastChanging                      = 0;
    currentScan                                     = tmp;
else
    showSubtractionPlots                            = 0;
    tmp = currentScan;
    % restore the normal plot if the button is unpressed
    if currentScan == handles.scanData.header.numScans
        currentScan = currentScan -1;
    end
    handles.displayProperties. startPoint = currentScan+1;
    handles.displayProperties. endPoint = currentScan+1 ;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
    currentScan = tmp;    
end
% restore the interactivemouse
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end

% Hint: get(hObject,'Value') returns toggle state of showSubtractionPlots


% REPLACE_WITH_DASH_DASH- Executes on button press in Abort.
function Abort_Callback(hObject, eventdata, handles)
% hObject    handle to Abort (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in captureRestorePointMosaic.
function captureRestorePointMosaic_Callback(hObject, eventdata, handles)
% hObject    handle to captureRestorePointMosaic (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global axesNumber;
axesNumber = 2;
interactivemouse reset;

% REPLACE_WITH_DASH_DASH- Executes on button press in detrendBeforeDisplaying.
function detrendBeforeDisplaying_Callback(hObject, eventdata, handles)
% hObject    handle to detrendBeforeDisplaying (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% Temporal filtering (niak_brick_time_filter)
% get the user setting for line thickness and width
global lineWidth lineColor;
if ~isempty(findobj(handles.plotAxes, 'Type', 'Line'))
lineColor = get(findobj(handles.plotAxes, 'Type', 'Line'),'Color');
lineWidth = get(findobj(handles.plotAxes, 'Type', 'Line'),'LineWidth');
end

if get(hObject,'Value') == 1
    if isempty(handles.roi.plotData)
        return;
    end
    set(handles.statusString, 'String', 'Status: Busy detrending the data...');
    disp('Runing Temporal High Pass Filtering.......................');
    opt.hp = 0.01; % Apply a high-pass filter at cut-off frequency 0.01Hz (slow time drifts)
    opt.lp = Inf;  % Do not apply low-pass filter. Low-pass filter induce a big loss in degrees of freedom without sgnificantly improving the SNR.
    if isempty(handles.scanData.header.TR) % if no TR info exist then explicitly get it from the user
        prompt = {'Please specify TR in seconds'};
        dlg_title = 'TR';
        num_lines = 1;
        def = {'1.5'};
        opt.tr = str2double(inputdlg(prompt,dlg_title,num_lines,def));
        handles.scanData.header.TR = opt.tr;
    else
        opt.tr                      = handles.scanData.header.TR;
    end
    [plotDataDetrended,extras]      = niak_filter_tseries(double(handles.roi.plotData'),opt);
    plotDataDetrended               = plotDataDetrended';
    plotDataMeanDetrended           = mean(plotDataDetrended,1);
    
    plot(handles.plotAxes, 1:numel(plotDataMeanDetrended), plotDataMeanDetrended,'LineSmoothing','on', 'LineWidth', lineWidth,'Color', lineColor);
    set(handles.plotAxes,'Color',[0 0 0]); % change the plot background to black
  
    handles.roi.plotDataMeanDetrended   = plotDataMeanDetrended;
    handles.roi.plotDataDetrended       = plotDataDetrended;
    handles.roi.maxYDetrended           = max(plotDataMeanDetrended);
    handles.roi.minYDetrended           = min(plotDataMeanDetrended);
    set(handles.plotAxes,'yLim',...
        [handles.roi.minYDetrended handles.roi.maxYDetrended ]); % chngle the y axis limit
    set(handles.plotAxes,'xLim', [1 numel(plotDataMeanDetrended)]); 
    set(handles.statusString, 'String', 'Status: Detrending Done.');
    guidata(hObject,handles);
else
    if ~isempty(handles.roi.plotDataMean)
        plot(handles.plotAxes, 1:numel(handles.roi.plotDataMean),  handles.roi.plotDataMean,'LineSmoothing','on', 'LineWidth', lineWidth,'Color', lineColor);
        set(handles.plotAxes,'Color',[0 0 0]); % change the plot background to black
        set(handles.plotAxes,'yLim',...
            [handles.roi.minY handles.roi.maxY]);
        set(handles.plotAxes,'xLim', [1 numel(handles.roi.plotDataMean)]);         
    end
end

% if the user already input a design matrix, then plot it
if handles.designMatrix.conditionCount   ~= 0
    set(handles.okDesignMatrix, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.okDesignMatrix;
    dfmri('okDesignMatrix_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end

% Hint: get(hObject,'Value') returns toggle state of detrendBeforeDisplaying


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function preprocessedDataBuffer_Callback(hObject, eventdata, handles)
% hObject    handle to preprocessedDataBuffer (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

[data, header]              = readFunctionalRealTimeUntouchedPreproc(1);
data = data * 100;
intializeBrigtnessContrast(handles,eventdata,hObject,data);
% format the data in mosaic and get the slice labels and separators
[data,m]        = prepareMosaicData(data, header);
% Make Mosaic to Scans Mosaic2VoxelsXScansVector vecotr
[handles.scanData.imgSag handles.scanData.imgCor handles.scanData.imgAxial]...
    = mosaic2VoxelsXScansVector(m)
% data is the appended dataset
% m contains the location of annotations
[mosaicHandle]  = mosaicLoop(data, m, handles.displayProperties,...
    handles.mosaicAxes);
% prepare to share the data among gui
handles.scanData.data       = data;
handles.scanData.header     = header;
handles.m                   = m;
handles.mosaicHandle        = mosaicHandle;
%update data
guidata(hObject, handles);

% REPLACE_WITH_DASH_DASH- Executes on selection change in mosaicColormap.
function mosaicColormap_Callback(hObject, eventdata, handles)
% hObject    handle to mosaicColormap (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = cellstr(get(hObject,'String')) returns mosaicColormap contents as cell array
%        contents{get(hObject,'Value')} returns selected item from mosaicColormap

global currentScan mosaicColormap;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
numCbrewerColors = 8;
contents = cellstr(get(hObject,'String'))
cm = contents{get(hObject,'Value')};
tmp = cm;
if strcmp(cm,'IsoL')
    cm = pmkmp(256, 'isol');  
elseif strcmp(cm,'CubicL')
    cm = pmkmp(256);          
elseif strcmp(cm,'Fire')
    cm = fire;          
elseif strcmp(cm, 'Maximally Distinct')
    cm = distinguishable_colors(numCbrewerColors);
elseif strcmp(cm, 'Color Brewer Set1')
    cm = cbrewer('qual', 'Set1', numCbrewerColors);
elseif strcmp(cm, 'Color Brewer Set2')
    cm = cbrewer('qual', 'Set2', numCbrewerColors);    
elseif strcmp(cm, 'Color Brewer Set3')
    cm = cbrewer('qual', 'Set3', numCbrewerColors);    
elseif strcmp(cm, 'Color Brewer Paired')
    cm = cbrewer('qual', 'Paired',numCbrewerColors);    
elseif strcmp(cm, 'Color Brewer Accent')
    cm = cbrewer('qual', 'Accent',numCbrewerColors);
elseif strcmp(cm, 'Color Brewer Dark')
    cm = cbrewer('qual', 'Dark2',numCbrewerColors);
elseif strcmp(cm, 'Color Brewer Pastel')
    cm = cbrewer('qual', 'Pastel2',numCbrewerColors);
end
handles.displayProperties.mosaicColormap = cm;
mosaicColormap = cm;
if handles.scanData.header.numScans == 1
    handles.displayProperties.startPoint = 1;
    handles.displayProperties.endPoint = 1;
elseif currentScan == handles.scanData.header.numScans
    handles.displayProperties.startPoint = currentScan;
    handles.displayProperties.endPoint = currentScan;
else
    handles.displayProperties.startPoint = currentScan+1;
    handles.displayProperties.endPoint = currentScan+1;
end
[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
    handles.displayProperties, handles.mosaicAxes);
guidata(hObject,handles);
% overlay ROI
refreshROIOverlay(handles);

% invoke trueMaskcolor
if get(handles.overlayMask,'Value') && get(handles.trueColor,'Value')
    set(handles.trueColor, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.trueColor;
    dfmri('trueColor_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end

% hack to turn on the zoom functionality after this button is pressed
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr the view changes
interactivemouse off;
interactivemouse on;
end
set(handles.statusString, 'String', strcat('Status: Slice color map changed to', {' '''}, tmp,{''''}));

% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function mosaicColormap_CreateFcn(hObject, eventdata, handles)
% hObject    handle to mosaicColormap (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in resetViewMosaic.
function resetViewMosaic_Callback(hObject, eventdata, handles)
% hObject    handle to resetViewMosaic (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global viewSwitching;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
if handles.displayProperties.view == 3 %just a hack to prevent the axes going beserk on pressing the reset button when the view is axial
viewSwitching = 1;
[mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
else
axes(handles.mosaicAxes);
interactivemouse RESTORE_ORIG;
end

if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end

% REPLACE_WITH_DASH_DASH- Executes on button press in ResetViewPlot.
function ResetViewPlot_Callback(hObject, eventdata, handles)
% hObject    handle to ResetViewPlot (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global axesNumber;
axesNumber = 1;
% axes(handles.mosaicAxes);
interactivemouse restore_orig;


% REPLACE_WITH_DASH_DASH- Executes on selection change in popupmenu4.
function popupmenu4_Callback(hObject, eventdata, handles)
% hObject    handle to popupmenu4 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = cellstr(get(hObject,'String')) returns popupmenu4 contents as cell array
%        contents{get(hObject,'Value')} returns selected item from popupmenu4


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function popupmenu4_CreateFcn(hObject, eventdata, handles)
% hObject    handle to popupmenu4 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on selection change in view.
function view_Callback(hObject, eventdata, handles)
% hObject    handle to view (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = cellstr(get(hObject,'String')) returns view contents as cell array
%        contents{get(hObject,'Value')} returns selected item from view
global viewSwitching mask;

contents = cellstr(get(hObject,'String'));
if strcmp(contents{get(hObject,'Value')}, 'Sagittal')
    handles.displayProperties.view = 1;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
elseif strcmp(contents{get(hObject,'Value')}, 'Coronal')
    handles.displayProperties.view = 2;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
elseif strcmp(contents{get(hObject,'Value')}, 'Axial')
    handles.displayProperties.view = 3;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
elseif strcmp(contents{get(hObject,'Value')}, 'Flattened 4D (Scans x Voxels)')
    handles.displayProperties.view = 4;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
elseif strcmp(contents{get(hObject,'Value')}, '3D Orthogonal')
    handles.displayProperties.view = 5;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
else
    handles.displayProperties.view = 6;
    viewSwitching = 1;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties,handles.mosaicAxes);
end
guidata(hObject,handles);

% if masked voxels only then 
if get(handles.showMaskedVoxelsOnly, 'Value') == 1
    try
        handles.roi.roiData.imgSag = mask.imgMaskedVoxelsOnlySagittal & handles.roi.roiData.imgSag;
    catch
    end
    try
        handles.roi.roiData.imgCor = mask.imgMaskedVoxelsOnlyCoronal & handles.roi.roiData.imgCor;
    catch
    end
    try
        handles.roi.roiData.imgAxial = mask.imgMaskedVoxelsOnlyAxial & handles.roi.roiData.imgAxial;
    catch
    end
end

% update ROI Data if view switchsa
% if ~isempty(handles.roi.roiData.imgSag) | ~isempty(handles.roi.roiData.imgCor) | ~isempty(handles.roi.roiData.imgAxial)
% colorize ROI
try
    if handles.displayProperties.view == 1
        [posX posY] = find(handles.roi.roiData.imgSag);
        pSag = colorpixel(posY,posX,handles.roi.roiColor);
    elseif handles.displayProperties.view == 2
        [posX posY] = find(handles.roi.roiData.imgCor);
        pCor = colorpixel(posY,posX,handles.roi.roiColor);
    else
        [posX posY] = find(handles.roi.roiData.imgAxial);
        pAxial = colorpixel(posY,posX,handles.roi.roiColor);
    end
catch
end
      if get(handles.trueColor, 'Value') % if true colors is on then
        % invoke trueMaskcolor
        set(handles.trueColor, 'Value', 1);
        hObjectCall = handles.trueColor;
        dfmri('trueColor_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    end  
%     if handles.displayProperties.view == 1
%         if isempty(handles.roi.roiHandle.pSag)
%             handles.roi.roiHandle.pSag = pSag;
%         else
%             handles.roi.roiHandle.pSag = [handles.roi.roiHandle.pSag; reshape(pSag,[],1)];
%         end
%     elseif handles.displayProperties.view == 1
%         if isempty(handles.roi.roiHandle.pCor)
%             handles.roi.roiHandle.pCor = pCor;
%         else
%             handles.roi.roiHandle.pCor = [handles.roi.roiHandle.pCor; reshape(pCor,[],1)];
%         end
%     elseif handles.displayProperties.view == 1
%         if isempty(handles.roi.roiHandle.pAxial)
%             handles.roi.roiHandle.pAxial = pAxial;
%         else
%             handles.roi.roiHandle.pAxial = [handles.roi.roiHandle.pAxial; reshape(pAxial,[],1)];
%         end
%     end
    guidata(hObject,handles);
% end


% hack to turn on the zoom functionality after this button is pressed
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr the view changes
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end

% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function view_CreateFcn(hObject, eventdata, handles)
% hObject    handle to view (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on selection change in roiVoxelsSelection.
function roiVoxelsSelection_Callback(hObject, eventdata, handles)
% hObject    handle to roiVoxelsSelection (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% make on the mosiac axes visible so that the use can select the voxels in
% the mosaic
global mask lineWidth lineColor;
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');

voxelSelectionMethod = 0; 
contents = cellstr(get(hObject,'String'))
method = contents{get(hObject,'Value')}
set( handles.figure1, 'Pointer', 'crosshair' );
if strcmp(method, 'Rectangular')
    set(handles.statusString, 'String', 'Status: Drag a rectangle by clicking the left mouse button, dragging and then releasing the mouse button');
    k = waitforbuttonpress;
    point1 = get(gca,'CurrentPoint');    % button down detected
    set(handles.statusString, 'String', 'Status: Release the left mouse button to end ROI selection.');
    finalRect = rbbox;                   % return figure units
    point2 = get(gca,'CurrentPoint');    % button up detected

    point1 = point1(1,1:2);              % extract x and y
    point2 = point2(1,1:2);
    p1 = min(point1,point2);             % calculate locations
    offset = abs(point1-point2);         % and dimensions
    x = [p1(1) p1(1)+offset(1) p1(1)+offset(1) p1(1) p1(1)]- 0.5; % -0.5 for imagesc start point
    y = [p1(2) p1(2) p1(2)+offset(2) p1(2)+offset(2) p1(2)]- 0.5;
    x = round(x); y = round(y);
    set(handles.statusString, 'String', 'Status: Done');
elseif strcmp(method, 'Polygon')
    set(handles.statusString, 'String', 'Status: Press left mouse button for every edge of the polygon. Press right mouse button to finish the Polygon');
    [x,y] = GETLINE('closed');
    set(handles.statusString, 'String', 'Status: Done')

    x = round(x-0.5); y = round(y-0.5);
else 
    x = [], y =[];
    while ~(strcmp(get(handles.figure1,'SelectionType'), 'alt'))
        set(handles.statusString, 'String', 'Status: Press left mouse button to select a voxel. Press right mouse button to end the selection');
        [x, y] = getpts(handles.mosaicAxes)
    end
    voxelSelectionMethod = 3; 
    set(handles.statusString, 'String', 'Status: Done');
end

set( handles.figure1, 'Pointer', 'arrow' );

%%% plot ROI
if handles.displayProperties.view == 1 | handles.displayProperties.view == 2
    siz = [handles.m.mosaic^2*sqrt(handles.m.xyRes) handles.m.xyRes*sqrt(handles.m.xyRes)];
else
    siz = [handles.m.xyRes*handles.m.mosaic handles.m.xyRes*handles.m.mosaic];
end

% make binary mask
if voxelSelectionMethod == 3;
    posX = round(y(1:end-1)); % ignore the last sample corresponding to the selection END click
    posY = round(x(1:end-1));
    roiMask = logical(zeros(siz(1),siz(2)));
    for j = 1: numel(posX)
        roiMask(posX(j), posY(j)) = 1;
    end    
else
    roiMask = poly2mask(x,y,siz(1),siz(2)); 
end


% OR the masks if there are more than one of them
if  handles.displayProperties.view == 1
    if isempty(handles.roi.roiMaskSag)
        handles.roi.roiMaskSag = roiMask;
    else
        handles.roi.roiMaskSag = handles.roi.roiMaskSag | roiMask;
    end
elseif  handles.displayProperties.view == 2
    if isempty(handles.roi.roiMaskCor)
        handles.roi.roiMaskCor = roiMask;
    else
        handles.roi.roiMaskCor = handles.roi.roiMaskCor | roiMask;        
    end
elseif  handles.displayProperties.view == 3
    if isempty(handles.roi.roiMaskAxial)
        handles.roi.roiMaskAxial = roiMask;
    else
        handles.roi.roiMaskAxial = handles.roi.roiMaskAxial | roiMask;        
    end
end



% convert the mask in all three viewss
[handles.img2Coords.roiMaskSagittal handles.img2Coords.roiMaskCoronal handles.img2Coords.roiMaskAxial] = ...
    mosaic2VoxelsXScansVector(handles.m);
if  handles.displayProperties.view == 1
    roiPositionInData = handles.img2Coords.roiMaskSagittal(find(handles.roi.roiMaskSag));
    
elseif  handles.displayProperties.view == 2
    roiPositionInData = handles.img2Coords.roiMaskCoronal(find(handles.roi.roiMaskCor));
    
else  % handles.displayProperties.view == 3
    roiPositionInData = handles.img2Coords.roiMaskAxial(find(handles.roi.roiMaskAxial));
    
end
numVoxelsIncludingPadding   = (handles.m.xyRes)^2 * (handles.m.mosaic)^2;
ind                         = uint32(zeros(1,numVoxelsIncludingPadding));
ind(roiPositionInData)= 1;
[handles.roi.roiData.imgSag handles.roi.roiData.imgCor handles.roi.roiData.imgAxial] =...
    roiMosaic2VoxelsXScansVector(handles.m, ind);
%update
handles.roi.roiMaskSag = handles.roi.roiData.imgSag;
handles.roi.roiMaskCor = handles.roi.roiData.imgCor;
handles.roi.roiMaskAxial = handles.roi.roiData.imgAxial;

%Or the ROI and anatomical masks
if get(handles.showMaskedVoxelsOnly, 'Value') == 1
    try
        handles.roi.roiData.imgSag = mask.imgMaskedVoxelsOnlySagittal & handles.roi.roiData.imgSag;
    catch
    end
    try
        handles.roi.roiData.imgCor = mask.imgMaskedVoxelsOnlyCoronal & handles.roi.roiData.imgCor;
    catch
    end
    try
        handles.roi.roiData.imgAxial = mask.imgMaskedVoxelsOnlyAxial & handles.roi.roiData.imgAxial;
    catch
    end    
end

% colorize ROI
if handles.displayProperties.view == 1
    [posX posY] = find(handles.roi.roiData.imgSag);
    pSag = colorpixel(posY,posX,handles.roi.roiColor);
elseif handles.displayProperties.view == 2
    [posX posY] = find(handles.roi.roiData.imgCor);
    pCor = colorpixel(posY,posX,handles.roi.roiColor);
else
    [posX posY] = find(handles.roi.roiData.imgAxial);
    pAxial = colorpixel(posY,posX,handles.roi.roiColor);
end


if handles.displayProperties.view == 1
    if isempty(handles.roi.roiHandle.pSag)
        handles.roi.roiHandle.pSag = pSag;
    else
        handles.roi.roiHandle.pSag = [handles.roi.roiHandle.pSag; reshape(pSag,[],1)];
    end
elseif handles.displayProperties.view == 1
    if isempty(handles.roi.roiHandle.pCor)
        handles.roi.roiHandle.pCor = pCor;
    else
        handles.roi.roiHandle.pCor = [handles.roi.roiHandle.pCor; reshape(pCor,[],1)];
    end
elseif handles.displayProperties.view == 1
    if isempty(handles.roi.roiHandle.pAxial)
        handles.roi.roiHandle.pAxial = pAxial;
    else
        handles.roi.roiHandle.pAxial = [handles.roi.roiHandle.pAxial; reshape(pAxial,[],1)];
    end
end
        
guidata(hObject,handles);

%% Call plot 
[handles.img2Coords.sagittal handles.img2Coords.coronal handles.img2Coords.axial] = ...
    mosaic2VoxelsXScansVector(handles.m);

if handles.displayProperties.view == 1
   plotData = handles.scanData.data(handles.img2Coords.sagittal(find(handles.roi.roiData.imgSag)), :); 
   voxelLocation = handles.img2Coords.sagittal(find(handles.roi.roiData.imgSag))
elseif handles.displayProperties.view == 2
   plotData = handles.scanData.data(handles.img2Coords.coronal(find(handles.roi.roiData.imgCor)), :);    
else
   plotData = handles.scanData.data(handles.img2Coords.axial(find(handles.roi.roiData.imgAxial)), :);   
end

plotDataMean = mean(plotData,1);
set(handles.plotAxes, 'HandleVisibility' , 'on'); % so that plot is in the plot axes
set(handles.mosaicAxes, 'HandleVisibility' , 'off');

handles.roi.plotDataMean    = plotDataMean;
handles.roi.plotData        = plotData;
handles.roi.maxY        	= max(plotDataMean);
handles.roi.minY            = min(plotDataMean);

xLimitPlot = get(handles.plotAxes, 'XLim'); % get the limits beofre
yLimitPlot = get(handles.plotAxes, 'YLim');

% get the user setting for line thickness and width
if ~isempty(findobj(handles.plotAxes, 'Type', 'Line'))
lineColor = get(findobj(handles.plotAxes, 'Type', 'Line'),'Color');
lineWidth = get(findobj(handles.plotAxes, 'Type', 'Line'),'LineWidth');
end

if ~get(handles.detrendBeforeDisplaying, 'Value') %if the Detrend option is not on then display undetrended data
    h = plot(handles.plotAxes, 1:numel(plotDataMean), plotDataMean,'LineSmoothing','on', 'LineWidth', lineWidth,'Color', lineColor);
    set(handles.plotAxes,'Color',[0 0 0]); % change the plot background to black
    set(h,'uicontextmenu',linecmenu);
    if handles.roi.maxY ~= 0 & handles.roi.minY ~= 0 % avoid error when data is zero
        try
            set(handles.plotAxes,'yLim', [handles.roi.minY handles.roi.maxY]); % change the plot background to black
        catch end
    end
    set(handles.plotAxes,'xLim', [1 numel(plotDataMean)]); % change the plot background to black
else % else display detrended data
    disp('Runing Temporal High Pass Filtering.......................');
    opt.hp = 0.01; % Apply a high-pass filter at cut-off frequency 0.01Hz (slow time drifts)
    opt.lp = Inf;  % Do not apply low-pass filter. Low-pass filter induce a big loss in degrees of freedom without sgnificantly improving the SNR.
    if isempty(handles.scanData.header.TR) % if no TR info exist then explicitly get it from the user
        prompt = {'Please specify TR in seconds'};
        dlg_title = 'TR';
        num_lines = 1;
        def = {'1.5'};
        opt.tr = str2double(inputdlg(prompt,dlg_title,num_lines,def));
        handles.scanData.header.TR = opt.tr;
    else
        opt.tr                      = handles.scanData.header.TR;
    end
    [plotDataDetrended,extras]      = niak_filter_tseries(double(plotData'),opt);
    plotDataDetrended               = plotDataDetrended';
    plotDataMeanDetrended           = mean(plotDataDetrended,1);
    
    plot(handles.plotAxes, 1:numel(plotDataMeanDetrended), plotDataMeanDetrended,'LineSmoothing','on', 'LineWidth', lineWidth,'Color', lineColor);
    set(handles.plotAxes,'Color',[0 0 0]); % change the plot background to black
    
    handles.roi.plotDataMeanDetrended   = plotDataMeanDetrended;
    handles.roi.plotDataDetrended       = plotDataDetrended;
    handles.roi.maxYDetrended           = max(plotDataMeanDetrended);
    handles.roi.minYDetrended           = min(plotDataMeanDetrended);
    set(handles.plotAxes,'yLim',...
        [handles.roi.minYDetrended handles.roi.maxYDetrended ]); % chngle the y axis limit
    set(handles.plotAxes,'xLim', [1 numel(plotDataMeanDetrended)]);
end

set(handles.plotAxes, 'HandleVisibility' , 'off'); % so that control falls back to the mosiac axes
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
guidata(hObject,handles);

% if the user already input a design matrix, then plot it
if handles.designMatrix.conditionCount   ~= 0
    set(handles.okDesignMatrix, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.okDesignMatrix;
    dfmri('okDesignMatrix_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end

if ~(xLimitPlot(1) == 0 && xLimitPlot(2) == 1)% & ~yLimitPlot == [0 1] %only do it after the zoom has been done
set(handles.plotAxes, 'XLim',xLimitPlot); % get the limits beofre
set(handles.plotAxes, 'YLim',yLimitPlot);
end

% enable the Go again button
set(handles.goAbortRoiSelection,'String', 'Go Again');
set(handles.goAbortRoiSelection,'Visible', 'on');

set(handles.statusString, 'String','Status: Added a new ROI');

function roiVoxelsSelection_CreateFcn(hObject, eventdata, handles)
% hObject    handle to roiVoxelsSelection (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in displayDualCursors.
function displayDualCursors_Callback(hObject, eventdata, handles)
% hObject    handle to displayDualCursors (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% if no data exists then return
if  isempty(handles.roi.plotData) & isempty(handles.motionRegressors)
    set(handles.displayDualCursors, 'Value', 0);
    msgbox('No data exists to be measured with the dual cursor. First plot the time course of an ROI and then choose this option.', 'OOPS','warn','modal');
    return;
end
set(handles.plotAxes, 'HandleVisibility' , 'on');
set(handles.mosaicAxes, 'HandleVisibility' , 'off');
if get(hObject,'Value') == 1
   dualcursor on;
   [x1x2] = dualcursor(handles.plotAxes);
   dualcursor([4 8],[.05 1.05; .25 1.05],'gs');

else
    dualcursor off;
end
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
guidata(hObject, handles);
% Hint: get(hObject,'Value') returns toggle state of displayDualCursors

% REPLACE_WITH_DASH_DASH- Executes on button press in plotStandardDeviation.
function plotStandardDeviation_Callback(hObject, eventdata, handles)
% hObject    handle to plotStandardDeviation (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of plotStandardDeviation



function zLocation_Callback(hObject, eventdata, handles)
% hObject    handle to zLocation (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of zLocation as text
%        str2double(get(hObject,'String')) returns contents of zLocation as a double


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function zLocation_CreateFcn(hObject, eventdata, handles)
% hObject    handle to zLocation (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function yLocation_Callback(hObject, eventdata, handles)
% hObject    handle to yLocation (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of yLocation as text
%        str2double(get(hObject,'String')) returns contents of yLocation as a double


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function yLocation_CreateFcn(hObject, eventdata, handles)
% hObject    handle to yLocation (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function xLocation_Callback(hObject, eventdata, handles)
% hObject    handle to xLocation (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of xLocation as text
%        str2double(get(hObject,'String')) returns contents of xLocation as a double


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function xLocation_CreateFcn(hObject, eventdata, handles)
% hObject    handle to xLocation (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in deleteLastCondition.
function deleteLastCondition_Callback(hObject, eventdata, handles)
% hObject    handle to deleteLastCondition (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.plotAxes, 'HandleVisibility' , 'on');
set(handles.mosaicAxes, 'HandleVisibility' , 'off');

if handles.designMatrix.conditionCount == 0
    msgbox('Your highness! There is nothing left to delete. You will crash me if you continue like this.','Warning', 'warn');
    return
end
[x y] = getAxesLimits(handles.plotAxes);

if get(handles.plotMotionRegressors, 'Value') % if motion regressors is on then plot the design matrix over motion regressors
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,...
        handles.designMatrix.onsets,handles.designMatrix.durations,...
        handles.designMatrix.offset, 0, 1, 0,...
        minY, maxY,...
        handles.designMatrix.colormap, handles.plotAxes,...
        []);
    hold on; % holds the design matrix plot to overlay additional information over it
    % call plot motion regressor again to overlay the motion regressor over
    % the design matrix
    set(handles.plotMotionRegressors, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri('plotMotionRegressors_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    hold off;
else
    if handles.designMatrix.conditionCount >= 1
        if get(handles.detrendBeforeDisplaying, 'Value') == 0 % then plot non- detreded data
            makeDesignMatrixBars(handles.scanData.header.numScans,...
                handles.designMatrix.onsets,handles.designMatrix.durations,...
                handles.designMatrix.offset, 0, 1, 0,...
                handles.roi.minY, handles.roi.maxY,...
                handles.designMatrix.colormap, handles.plotAxes,...
                handles.roi.plotData);
        else % otherwise plot detrended data
            makeDesignMatrixBars(handles.scanData.header.numScans,...
                handles.designMatrix.onsets,handles.designMatrix.durations,...
                handles.designMatrix.offset, 0, 1, 0,...
                handles.roi.minYDetrended, handles.roi.maxYDetrended,...
                handles.designMatrix.colormap, handles.plotAxes,...
                handles.roi.plotDataDetrended);
        end
    end
end
% update the data structure as well
handles.designMatrix.onsets(end) = [];
handles.designMatrix.durations(end) = [];
% decrement the condition counter as well
handles.designMatrix.conditionCount = handles.designMatrix.conditionCount -1;
guidata(hObject,handles);
% if zoom is on, keep it on
if get(handles.turnOnZoomAndPanPlot,'Value') == 1
    set(handles.turnOnZoomAndPanPlot, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri('turnOnZoomAndPanPlot_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
set(handles.statusString, 'String', strcat('Status: ',...
    ' Deleted the last condition. You have a total of ',{' '},...
    num2str(handles.designMatrix.conditionCount), ' condition(s) remaining'));

setAxesLimits(handles.plotAxes, x, y);

% REPLACE_WITH_DASH_DASH- Executes on button press in deleteAllConditions.
function deleteAllConditions_Callback(hObject, eventdata, handles)
% hObject    handle to deleteAllConditions (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.plotAxes, 'HandleVisibility' , 'on');
set(handles.mosaicAxes, 'HandleVisibility' , 'off');
[x y] = getAxesLimits(handles.plotAxes);
if get(handles.plotMotionRegressors, 'Value') % if motion regressors is on then plot the design matrix over motion regressors
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,...
        handles.designMatrix.onsets,handles.designMatrix.durations,...
        handles.designMatrix.offset, 0, 0, 1,...
        minY, maxY,...
        handles.designMatrix.colormap, handles.plotAxes,...
        []);
    hold on; % holds the design matrix plot to overlay additional information over it
    % call plot motion regressor again to overlay the motion regressor over
    % the design matrix
    set(handles.plotMotionRegressors, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri('plotMotionRegressors_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    hold off;
else
    if get(handles.detrendBeforeDisplaying, 'Value') == 0 % then plot non- detreded data
        makeDesignMatrixBars(handles.scanData.header.numScans,...
            handles.designMatrix.onsets,handles.designMatrix.durations,...
            handles.designMatrix.offset, 0, 0, 1,...
            handles.roi.minY, handles.roi.maxY,...
            handles.designMatrix.colormap, handles.plotAxes,...
            handles.roi.plotData);
    else % otherwise plot detrended data
        makeDesignMatrixBars(handles.scanData.header.numScans,...
            handles.designMatrix.onsets,handles.designMatrix.durations,...
            handles.designMatrix.offset, 0, 0, 1,...
            handles.roi.minYDetrended, handles.roi.maxYDetrended,...
            handles.designMatrix.colormap, handles.plotAxes,...
            handles.roi.plotDataDetrended);
    end
end
% update the data structure as well
    handles.designMatrix.onsets         = [];
    handles.designMatrix.durations      = [];
    handles.designMatrix.conditionCount     = 0;
guidata(hObject,handles);
% if zoom is on, keep it on
if get(handles.turnOnZoomAndPanPlot,'Value') == 1
    set(handles.turnOnZoomAndPanPlot, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri('turnOnZoomAndPanPlot_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
set(handles.statusString, 'String', strcat('Status: ',...
    ' Deleted all conditions. You have 0 conditions currently defined.'));
setAxesLimits(handles.plotAxes, x, y);

% REPLACE_WITH_DASH_DASH- Executes on button press in addANewCondition.
function addANewCondition_Callback(hObject, eventdata, handles)
% hObject    handle to addANewCondition (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in okDesignMatrix.
function okDesignMatrix_Callback(hObject, eventdata, handles)
% hObject    handle to okDesignMatrix (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global lineWidth lineColor;
[x y] = getAxesLimits(handles.plotAxes);
set(handles.plotAxes, 'HandleVisibility' , 'on');
set(handles.mosaicAxes, 'HandleVisibility' , 'off');
onsets      = get(handles.specifyOnsets2,'String');
onsets      = eval(onsets);
durations   = get(handles.specifyDuration,'String');
durations   = eval(durations);

if handles.designMatrix.conditionCount >= 1 % prevents adding a new condition every time an ROI is added: reffresh
    if ~(isequal(onsets,handles.designMatrix.onsets{1,end}) && isequal(durations,handles.designMatrix.durations{1,end}))
        handles.designMatrix.conditionCount     =...
            handles.designMatrix.conditionCount + 1;
        guidata(hObject,handles);
        handles.designMatrix.onsets{1,handles.designMatrix.conditionCount}= onsets;
        handles.designMatrix.durations{1,handles.designMatrix.conditionCount}= durations;
    end
else
    handles.designMatrix.conditionCount     =...
        handles.designMatrix.conditionCount + 1;
    guidata(hObject,handles);
    handles.designMatrix.onsets{1,handles.designMatrix.conditionCount}= onsets;
    handles.designMatrix.durations{1,handles.designMatrix.conditionCount}= durations;
end
guidata(hObject,handles);
% function makeDesignMatrixBars(numScans, onsets, durations, offset, okAddACondition, deleteLastCondition, deleteAllConditions, minY, maxY, colormap,axesHandle)
% handles.designMatrix.maxY = handles.roi.maxY;
% handles.designMatrix.minY = handles.roi.minY;
if get(handles.plotMotionRegressors, 'Value') % if motion regressors is on then plot the design matrix over motion regressors
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,...
        handles.designMatrix.onsets,handles.designMatrix.durations,...
        handles.designMatrix.offset, 1, 0, 0,...
        minY, maxY,...
        handles.designMatrix.colormap, handles.plotAxes,...
        []);
    hold on; % holds the design matrix plot to overlay additional information over it   
    % call plot motion regressor again to overlay the motion regressor over
    % the design matrix
    set(handles.plotMotionRegressors, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri('plotMotionRegressors_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    hold off;
else
% plot design matrix over time courses
    if get(handles.detrendBeforeDisplaying, 'Value') == 0 % then plot non- detreded data
        makeDesignMatrixBars(handles.scanData.header.numScans,...
            handles.designMatrix.onsets,handles.designMatrix.durations,...
            handles.designMatrix.offset, 1, 0, 0,...
            handles.roi.minY, handles.roi.maxY,...
            handles.designMatrix.colormap, handles.plotAxes,...
            handles.roi.plotData);
    else % otherwise plot detrended data
        makeDesignMatrixBars(handles.scanData.header.numScans,...
            handles.designMatrix.onsets,handles.designMatrix.durations,...
            handles.designMatrix.offset, 1, 0, 0,...
            handles.roi.minYDetrended, handles.roi.maxYDetrended,...
            handles.designMatrix.colormap, handles.plotAxes,...
            handles.roi.plotDataDetrended);
    end
end
guidata(hObject, handles);
% if zoom is on, keep it on
if get(handles.turnOnZoomAndPanPlot,'Value') == 1
    set(handles.turnOnZoomAndPanPlot, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri('turnOnZoomAndPanPlot_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
set(handles.statusString, 'String', strcat('Status: ',...
    ' Added a new condition. You currently have a total of ',{' '},...
    num2str(handles.designMatrix.conditionCount), ' condition(s) defined.'));

setAxesLimits(handles.plotAxes, x,y);



% REPLACE_WITH_DASH_DASH- Executes on selection change in listbox5.
function listbox5_Callback(hObject, eventdata, handles)
% hObject    handle to listbox5 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = cellstr(get(hObject,'String')) returns listbox5 contents as cell array
%        contents{get(hObject,'Value')} returns selected item from listbox5


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function listbox5_CreateFcn(hObject, eventdata, handles)
% hObject    handle to listbox5 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on key press with focus on listbox5 and none of its controls.
function listbox5_KeyPressFcn(hObject, eventdata, handles)
% hObject    handle to listbox5 (see GCBO)
% eventdata  structure with the following fields (see UICONTROL)
%	Key: name of the key that was pressed, in lower case
%	Character: character interpretation of the key(s) that was pressed
%	Modifier: name(s) of the modifier key(s) (i.e., control, shift) pressed
% handles    structure with handles and user data (see GUIDATA)



function goToScanNumber_Callback(hObject, eventdata, handles)
% hObject    handle to goToScanNumber (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of goToScanNumber as text
%        str2double(get(hObject,'String')) returns contents of goToScanNumber as a double



% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function goToScanNumber_CreateFcn(hObject, eventdata, handles)
% hObject    handle to goToScanNumber (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in jumpToScan.
function jumpToScan_Callback(hObject, eventdata, handles)
% hObject    handle to jumpToScan (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global currentScan;
stringEntered = eval(get(handles.goToScanNumber, 'String'));
 handles.displayProperties.startPoint = stringEntered;
  handles.displayProperties.endPoint = stringEntered;
    [mosaicHandle]  = mosaicLoop(handles.scanData.data, handles.m,...
        handles.displayProperties, handles.mosaicAxes);
 currentScan =   stringEntered; 

 % hack to turn on the zoom functionality after this button is pressed
if handles.displayProperties.mosaicZoomOn % a hack to Keep interactivemouse on whenevr a button is pressed
    try
    interactivemouse off;
    catch
    end
    interactivemouse on;
end
guidata(hObject,handles);
 
function offset_Callback(hObject, eventdata, handles)
% hObject    handle to offset (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function offset_CreateFcn(hObject, eventdata, handles)
% hObject    handle to offset (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in addOffset.
function addOffset_Callback(hObject, eventdata, handles)
% hObject    handle to addOffset (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.plotAxes, 'HandleVisibility' , 'on');
set(handles.mosaicAxes, 'HandleVisibility' , 'off');
[x y] = getAxesLimits(handles.plotAxes);
offset      = get(handles.offset,'String');
offset      = eval(offset);
handles.designMatrix.offset = offset;
guidata(hObject, handles);
if get(handles.plotMotionRegressors, 'Value') % if motion regressors is on then plot the design matrix over motion regressors
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,...
        handles.designMatrix.onsets,handles.designMatrix.durations,...
        handles.designMatrix.offset, 0, 0, 0,...
        minY, maxY,...
        handles.designMatrix.colormap, handles.plotAxes,...
        []);
    hold on; % holds the design matrix plot to overlay additional information over it
    % call plot motion regressor again to overlay the motion regressor over
    % the design matrix
    set(handles.plotMotionRegressors, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri('plotMotionRegressors_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    hold off;
else
if get(handles.detrendBeforeDisplaying, 'Value') == 0 % then plot non- detreded data
    makeDesignMatrixBars(handles.scanData.header.numScans,...
        handles.designMatrix.onsets,handles.designMatrix.durations,...
        handles.designMatrix.offset, 0, 0, 0,...
        handles.roi.minY, handles.roi.maxY,...
        handles.designMatrix.colormap, handles.plotAxes,...
        handles.roi.plotData);
else % otherwise plot detrended data
    makeDesignMatrixBars(handles.scanData.header.numScans,...
        handles.designMatrix.onsets,handles.designMatrix.durations,...
        handles.designMatrix.offset, 0, 0, 0,...
        handles.roi.minYDetrended, handles.roi.maxYDetrended,...
        handles.designMatrix.colormap, handles.plotAxes,...
        handles.roi.plotDataDetrended);
end
end
% if zoom is on, keep it on
if get(handles.turnOnZoomAndPanPlot,'Value') == 1
    set(handles.turnOnZoomAndPanPlot, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri('turnOnZoomAndPanPlot_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
guidata(hObject,handles);
set(handles.statusString, 'String', strcat('Status: ',...
    ' Shifted ', {' '},...
    num2str(handles.designMatrix.conditionCount), {' '},...
    'condition(s) by an offset of',{' '},...
    num2str(offset)));

setAxesLimits(handles.plotAxes, x, y);

function specifyOnsets2_Callback(hObject, eventdata, handles)
% hObject    handle to specifyOnsets2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% s = get(hObject,'String');
% eval(s)
% handles.designMatirx.onsets{end+1} = eval(s);
% % Hints: get(hObject,'String') returns contents of specifyOnsets2 as text
% %        str2double(get(hObject,'String')) returns contents of specifyOnsets2 as a double
% guidata(hObject,handles);

% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function specifyOnsets2_CreateFcn(hObject, eventdata, handles)
% hObject    handle to specifyOnsets2 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function designMatrix_Callback(hObject, eventdata, handles)
% hObject    handle to designMatrix (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function Untitled_4_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_4 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveDesignMatrix_Callback(hObject, eventdata, handles)
% hObject    handle to saveDesignMatrix (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in goToCursorLocation.
function goToCursorLocation_Callback(hObject, eventdata, handles)
% hObject    handle to goToCursorLocation (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in helpButton.
function helpButton_Callback(hObject, eventdata, handles)
% hObject    handle to helpButton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of helpButton


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function help_Callback(hObject, eventdata, handles)
% hObject    handle to help (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function tutorial_Callback(hObject, eventdata, handles)
% hObject    handle to tutorial (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function displayHelpWhenIClickAnyting_Callback(hObject, eventdata, handles)
% hObject    handle to displayHelpWhenIClickAnyting (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function detailedDocumentation_Callback(hObject, eventdata, handles)
% hObject    handle to detailedDocumentation (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- If Enable == 'on', executes on mouse press in 5 pixel border.
% REPLACE_WITH_DASH_DASH- Otherwise, executes on mouse press in 5 pixel border or over turnOnZoomAndPanMosaic.
function turnOnZoomAndPanMosaic_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to turnOnZoomAndPanMosaic (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASH- Executes on button press in cap.
function cap_Callback(hObject, eventdata, handles)
% hObject    handle to cap (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global axesNumber;
axesNumber = 2;
interactivemouse reset;


% REPLACE_WITH_DASH_DASH- Executes on selection change in designMatrixColormap.
function designMatrixColormap_Callback(hObject, eventdata, handles)
% hObject    handle to designMatrixColormap (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles.plotAxes, 'HandleVisibility' , 'on');
set(handles.mosaicAxes, 'HandleVisibility' , 'off');
[x y] = getAxesLimits(handles.plotAxes);

contents = cellstr(get(hObject,'String'));
cm = contents{get(hObject,'Value')};
handles.designMatrix.colormap = cm;
guidata(hObject,handles);
% function makeDesignMatrixBars(numScans, onsets, durations, offset, okAddACondition, deleteLastCondition, deleteAllConditions, minY, maxY, colormap,axesHandle)
% makeDesignMatrixBars(handles.scanData.header.numScans,...
%     handles.designMatrix.onsets,handles.designMatrix.durations,...
%     handles.designMatrix.offset, 0, 0, 0,...
%     handles.roi.minY, handles.roi.maxY,...
%     handles.designMatrix.colormap, handles.plotAxes, handles.roi.plotData);
if get(handles.plotMotionRegressors, 'Value') % if motion regressors is on then plot the design matrix over motion regressors
    numScans    = numel(handles.motionRegressors.time);
    x           = [max(handles.motionRegressors.x) min(handles.motionRegressors.x)];
    y           = [max(handles.motionRegressors.y) min(handles.motionRegressors.y)];
    z           = [max(handles.motionRegressors.z) min(handles.motionRegressors.z)];
    maxY        = max([x y z]);
    minY        = min([x y z]);
    makeDesignMatrixBars(numScans,...
        handles.designMatrix.onsets,handles.designMatrix.durations,...
        handles.designMatrix.offset, 0, 0, 0,...
        minY, maxY,...
        handles.designMatrix.colormap, handles.plotAxes,...
        []);
    hold on; % holds the design matrix plot to overlay additional information over it
    % call plot motion regressor again to overlay the motion regressor over
    % the design matrix
    set(handles.plotMotionRegressors, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.plotMotionRegressors;
    dfmri('plotMotionRegressors_Callback',hObjectCall,eventdata,guidata(hObjectCall));
    hold off;
else
if get(handles.detrendBeforeDisplaying, 'Value') == 0 % then plot non- detreded data
    makeDesignMatrixBars(handles.scanData.header.numScans,...
        handles.designMatrix.onsets,handles.designMatrix.durations,...
        handles.designMatrix.offset, 0, 0, 0,...
        handles.roi.minY, handles.roi.maxY,...
        handles.designMatrix.colormap, handles.plotAxes,...
        handles.roi.plotData);
else % otherwise plot detrended data
    makeDesignMatrixBars(handles.scanData.header.numScans,...
        handles.designMatrix.onsets,handles.designMatrix.durations,...
        handles.designMatrix.offset, 0, 0, 0,...
        handles.roi.minYDetrended, handles.roi.maxYDetrended,...
        handles.designMatrix.colormap, handles.plotAxes,...
        handles.roi.plotDataDetrended);
end
end
% if zoom is on, keep it on
if get(handles.turnOnZoomAndPanPlot,'Value') == 1
    set(handles.turnOnZoomAndPanPlot, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.turnOnZoomAndPanPlot;
    dfmri('turnOnZoomAndPanPlot_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end
set(handles.plotAxes, 'HandleVisibility' , 'off');
set(handles.mosaicAxes, 'HandleVisibility' , 'on');
set(handles.statusString, 'String',...
    strcat('Status: Design matrix color map changed to', {' '''}, handles.designMatrix.colormap,{''''}));
setAxesLimits(handles.plotAxes, x, y);

% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function designMatrixColormap_CreateFcn(hObject, eventdata, handles)
% hObject    handle to designMatrixColormap (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on mouse press over axes background.
function mosaicAxes_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to mosaicAxes (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% if plot zoom is on, turn it off

%      import java.awt.*;
%      import java.awt.event.*;
%      rob=Robot;
%      rob.mousePress(InputEvent.BUTTON1_MASK);
%      rob.mouseRelease(InputEvent.BUTTON1_MASK);
% interactivemouse on;

%     set(handles.plotAxes, 'HandleVisibility' , 'off');
%     set(handles.mosaicAxes, 'HandleVisibility' , 'on');
%     guidata(hObject,handles);
%     interactivemouse on ;
%     handles.displayProperties.mosaicZoomOn = 1; % a hack to Keep interactivemouse on whenevr the view changes  

% if get(handles.turnOnZoomAndPanPlot,'Value') == 1
%     set(handles.turnOnZoomAndPanPlot, 'Value', 0);
%     guidata(hObject, handles);
%     hObjectCall = handles.turnOnZoomAndPanPlot;
%     dfmri('turnOnZoomAndPanPlot_Callback',hObjectCall,eventdata,guidata(hObjectCall));
% end
% if plot mosaic is off, turn it on
% if get(handles.turnOnZoomAndPanMosaic,'Value') == 0
%     set(handles.turnOnZoomAndPanMosaic, 'Value', 1);
%     guidata(hObject, handles);
%     hObjectCall = handles.turnOnZoomAndPanMosaic;
%     dfmri('turnOnZoomAndPanMosaic_Callback',hObjectCall,eventdata,guidata(hObjectCall));
% end
% interactivemouse off;

function maskThresholdValue_Callback(hObject, eventdata, handles)
% hObject    handle to maskThresholdValue (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of maskThresholdValue as text
%        str2double(get(hObject,'String')) returns contents of maskThresholdValue as a double
global maskThreshold;
valueEntered = str2double(get(hObject,'String'));
maskThreshold = valueEntered;
hObject = handles.overlayMask;
dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function maskThresholdValue_CreateFcn(hObject, eventdata, handles)
% hObject    handle to maskThresholdValue (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in goAbortRoiSelection.
function goAbortRoiSelection_Callback(hObject, eventdata, handles)
% hObject    handle to goAbortRoiSelection (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
selectionMethod = get(handles.roiVoxelsSelection,'Value');
if selectionMethod == 1
    roiVoxelsSelection = 'Rectangular';
elseif selectionMethod == 2
    roiVoxelsSelection = 'Polygon';
else
    roiVoxelsSelection = 'One Voxel at a time';
end

% Turn off plot axes
set(handles.roiVoxelsSelection, 'Value', selectionMethod);
guidata(hObject, handles);
hObjectCall = handles.roiVoxelsSelection;
dfmri('roiVoxelsSelection_Callback',hObjectCall,eventdata,guidata(hObjectCall));

% REPLACE_WITH_DASH_DASH- Executes on button press in customizeRoiColor.
function customizeRoiColor_Callback(hObject, eventdata, handles)
% hObject    handle to customizeRoiColor (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
set(handles. statusString, 'String', 'Status: Please pick a color for the ROI.');
roiColor = uicolorpicker;
handles.roi.roiColor = roiColor;

    if handles.displayProperties.view == 1
        [posX posY] = find(handles.roi.roiData.imgSag);
        pSag = colorpixel(posY,posX,handles.roi.roiColor);
    elseif handles.displayProperties.view == 2
        [posX posY] = find(handles.roi.roiData.imgCor);
        pCor = colorpixel(posY,posX,handles.roi.roiColor);
    else
        [posX posY] = find(handles.roi.roiData.imgAxial);
        pAxial = colorpixel(posY,posX,handles.roi.roiColor);
    end
set(handles.roiColorBox, 'BackgroundColor',handles.roi.roiColor);

% if handles.displayProperties.view == 1
%     set(handles.roi.roiHandle.pSag, 'FaceColor', roiColor);
% elseif handles.displayProperties.view == 2
%     set(handles.roi.roiHandle.pCor, 'FaceColor', roiColor);
% else
%     set(handles.roi.roiHandle.pAxial, 'FaceColor', roiColor);
% end

guidata(hObject,handles);
set(handles. statusString, 'String', 'Status: ROI color changed.');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function specialMasks_Callback(hObject, eventdata, handles)
% hObject    handle to specialMasks (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function aalMask_Callback(hObject, eventdata, handles)
% hObject    handle to aalMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global maskThreshold;

if isempty(handles.scanData.data) 
    msgbox(['You must have the functional data loaded before you can load '...
        'the mask. So first load the functional data and then load the '...
        'mask data. Only then you will be able to see the mask overlayed ' ...
        'over your functional data. If you only want to view the mask data '...
        'then load it as if it was a functional data. In that case, ' ...
        'just go to the File > Import Data > Functional ...'...
        'and load it like you would do a regular functional scan. '...
        'Pheew !!! That was a big warning.'],...
        'No functional data found', 'warn');
    return;
end
path = mfilename('fullpath');
path = path(1:end-numel('\functions\workHorse\dfmri.m')+2);
pathToAALToolbox = fullfile(path, 'toolboxes', '3aal_for_spm8');
% % Construct a questdlg to ascertain if the data is in MNI space
% choice = questdlg('Is your functional data in MNI sapce?', ...
%     'Functional Data''s space', ...
%     'Yes','No','No');
% % Handle response
% switch choice
%     case 'Yes'
%         [maskData, maskHeader]      = readAALMaskNifti3d(pathToAALToolbox, 'ROI_MNI_V4.nii');
%         
%     case 'No'
set(handles.statusString, 'String', 'Status: Coregistering AAL mask to the functional data. This may take a while...Please be patient');
        coregisterAALMaskToFunctionalData(pathToAALToolbox); pause(0.5);
        [maskData, maskHeader]      = readAALMaskNifti3d(pathToAALToolbox, 'rROI_MNI_V4.nii');        
% end

% format the data in mosaic and get the slice labels and separators
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
maskData(find(maskData== 0))= NaN;
% prepare mask in all three views
mask                        = prepareMask(maskData, handles.m);
handles.aalMask             = mask;
guidata(hObject, handles);
% Apply region selection
%prompt the user to slect the regions
set(handles.statusString, 'String', 'Status: Please select anatomical regions to mask.');
regions = selectAnatomicalRegions();
numRegions = numel(regions);
mask.maskAxial = handles.aalMask.maskAxial;
mask.maskSagittal = handles.aalMask.maskSagittal;
mask.maskCoronal = handles.aalMask.maskCoronal;
idxMaskAxial = [];
idxMaskSagittal = [];
idxMaskCoronal = [];
set(handles.statusString, 'String', 'Status: Masking selected anatomical regions....');
% read all the user selected regions and make a mask
for i = 1 : numRegions
        idxAxial = find(mask.maskAxial == regions(i));
        idxSagittal = find(mask.maskSagittal == regions(i));
        idxCoronal = find(mask.maskCoronal == regions(i));
        idxMaskAxial = [idxMaskAxial;  idxAxial];
        idxMaskSagittal = [idxMaskSagittal;  idxSagittal];
        idxMaskCoronal = [idxMaskCoronal;  idxCoronal];
end

maskAxial       = single(nan(size(mask.maskAxial)));
maskSagittal    = single(nan(size(mask.maskSagittal)));
maskCoronal     = single(nan(size(mask.maskCoronal)));

maskAxial(idxMaskAxial)         = mask.maskAxial(idxMaskAxial);
maskSagittal(idxMaskSagittal)   = mask.maskSagittal(idxMaskSagittal);
maskCoronal(idxMaskCoronal)     = mask.maskCoronal(idxMaskCoronal) ;

mask.maskAxial      = maskAxial;
mask.maskSagittal   = maskSagittal;
mask.maskCoronal    = maskCoronal;

% set the controls, disable the threshold slider
maskThreshold                   = 0.0;
set(handles.maskThresholdSlider,'Value', 0);
set(handles.maskThresholdSlider,'Enable', 'inactive');
set(handles.maskThresholdValue,'String', 0);
set(handles.maskThresholdValue,'Enable', 'inactive');
set(handles.selectNewAnatomicalRegions, 'visible', 'on');

handles.maskData.data   = mask;
guidata(hObject, handles);

% invoke overlay mask button
set(handles.overlayMask, 'Value', 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
set(handles.statusString, 'String', 'Status: AAL mask overlayed onto the functional');

% REPLACE_WITH_DASH_DASH- Executes on button press in selectNewAnatomicalRegions.
function selectNewAnatomicalRegions_Callback(hObject, eventdata, handles)
% hObject    handle to selectNewAnatomicalRegions (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

regions = selectAnatomicalRegions();
numRegions = numel(regions);
mask.maskAxial = handles.aalMask.maskAxial;
mask.maskSagittal = handles.aalMask.maskSagittal;
mask.maskCoronal = handles.aalMask.maskCoronal;
idxMaskAxial = [];
idxMaskSagittal = [];
idxMaskCoronal = [];
% read all the user selected regions and make a mask
for i = 1 : numRegions
        idxAxial = find(mask.maskAxial == regions(i));
        idxSagittal = find(mask.maskSagittal == regions(i));
        idxCoronal = find(mask.maskCoronal == regions(i));
        idxMaskAxial = [idxMaskAxial;  idxAxial];
        idxMaskSagittal = [idxMaskSagittal;  idxSagittal];
        idxMaskCoronal = [idxMaskCoronal;  idxCoronal];
end

maskAxial       = single(nan(size(mask.maskAxial)));
maskSagittal    = single(nan(size(mask.maskSagittal)));
maskCoronal     = single(nan(size(mask.maskCoronal)));

maskAxial(idxMaskAxial)         = mask.maskAxial(idxMaskAxial);
maskSagittal(idxMaskSagittal)   = mask.maskSagittal(idxMaskSagittal);
maskCoronal(idxMaskCoronal)     = mask.maskCoronal(idxMaskCoronal) ;

mask.maskAxial      = maskAxial;
mask.maskSagittal   = maskSagittal;
mask.maskCoronal    = maskCoronal;

handles.maskData.data   = mask;
guidata(hObject, handles);

% invoke overlay mask button
set(handles.overlayMask, 'Value', 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));


function intializeBrigtnessContrast(handles,eventdata,hObject,data)
global brightness contrast;
% get brightness contrast value so that the image is always visible
 
brightness = max(max(data));
contrast   = min(min(data));

set(handles.contrastSlider, 'Min', contrast - 100);
set(handles.contrastSlider, 'Max', brightness-1);
set(handles.brightnessSlider, 'Min', brightness);
set(handles.brightnessSlider, 'Max', brightness + 1000);
set(handles.brightnessSlider, 'Value', brightness);
set(handles.contrastSlider, 'Value', contrast);
set(handles.brightnessValue, 'String', num2str(brightness));
set(handles.contrastValue, 'String', num2str(contrast));
guidata(hObject,handles);


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function Maps_Callback(hObject, eventdata, handles)
% hObject    handle to Maps (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global specialData;
specialData                                    = 1;

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function tmap_Callback(hObject, eventdata, handles)
% hObject    handle to tmap (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function tmapNifti3D_Callback(hObject, eventdata, handles)
% hObject    handle to tmapNifti3D (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
niftiFunctional3d_Callback(hObject, eventdata, handles)

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function tmapAnalyze_Callback(hObject, eventdata, handles)
% hObject    handle to tmapAnalyze (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
analyzeFunctional_Callback(hObject, eventdata, handles)

function refreshROIOverlay(handles)
% overlay ROI
if ~isempty(handles.roi.roiData)
    if handles.displayProperties.view == 1
        [posX posY] = find(handles.roi.roiData.imgSag);
        pSag = colorpixel(posY,posX,handles.roi.roiColor);
    elseif handles.displayProperties.view == 2
        [posX posY] = find(handles.roi.roiData.imgCor);
        pCor = colorpixel(posY,posX,handles.roi.roiColor);
    else
        [posX posY] = find(handles.roi.roiData.imgAxial);
        pAxial = colorpixel(posY,posX,handles.roi.roiColor);
    end
end



% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMask_Callback(hObject, eventdata, handles)
% hObject    handle to saveMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMaskedFunctionalData_Callback(hObject, eventdata, handles)
% hObject    handle to saveMaskedFunctionalData (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveNifti3dDataMasked_Callback(hObject, eventdata, handles)
% hObject    handle to saveNifti3dDataMasked (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveAnalyzeDataMasked_Callback(hObject, eventdata, handles)
% hObject    handle to saveAnalyzeDataMasked (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMatlabMatMask_Callback(hObject, eventdata, handles)
% hObject    handle to saveMatlabMatMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global mask maskThreshold;
if isempty(mask)
    msgbox('You must import a mask before you can save it', 'No mask found !', 'warn', 'modal');
    return;
end
set(handles.statusString, 'String', 'Status: ');

% if show maked voxels only is off, then turn it on to get the desired data
% and turn it off later
showMaskedVoxelsOnlyStatus = get(handles.showMaskedVoxelsOnly, 'Value');
if showMaskedVoxelsOnlyStatus == 0
    set(handles.showMaskedVoxelsOnly, 'Value', 1);
    guidata(hObject, handles);
    hObjectCall = handles.showMaskedVoxelsOnly;
    dfmri('showMaskedVoxelsOnly_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end

% convert the mask in the current views in binary
if  handles.displayProperties.view == 1
    binaryMask = mask.imgMaskedVoxelsOnlySagittal;
elseif  handles.displayProperties.view == 2
    binaryMask = mask.imgMaskedVoxelsOnlyCoronal;    
else  % handles.displayProperties.view == 3
    binaryMask = mask.imgMaskedVoxelsOnlyAxial;    
end
    binaryMask(find(binaryMask)) = 1;
    
% pick the ind of the masked voxels
[handles.saveMaskedData.coordsSag handles.saveMaskedData.coordsCor handles.saveMaskedData.coordsAxial] = ...
    mosaic2VoxelsXScansVector(handles.m);
if  handles.displayProperties.view == 1
    idx = handles.saveMaskedData.coordsSag(find(binaryMask));
elseif  handles.displayProperties.view == 2
    idx = handles.saveMaskedData.coordsCor(find(binaryMask));    
else  % handles.displayProperties.view == 3
    idx = handles.saveMaskedData.coordsAxial(find(binaryMask));    
end

% choose masked voxels, set the rest to zero
d.data = single(zeros(numel(binaryMask),1));
d.data(idx,:) = 1;
d.header = handles.scanData.header; 
%discard the zero padding
d.data = d.data(1 : d.header.numSlices * d.header.xRes * d.header.yRes ,:);
% desquarify
if exist('handles.scanData.header.squarified','var')
    if handles.scanData.header.squarified
    d.data = desquarify(handles.scanData.header, d.data);
    end
end
[FileName,PathName,FilterIndex] = uiputfile('*.mat');
set(handles.statusString, 'String', 'Status: Started saving masked ......Please be patient !!!!');


d.mask              = mask;
d.maskThreshold     = maskThreshold;
d.binary_mask       = d.data;  % this is the data user can use later on


% Construct a questdlg with three options
choice = questdlg(['Do you want to save the header information as well ',...
    'alongwith the binary mask? By saving header information, it will be easier '...
    'for you to load the mask again in Analyze4D.'], ...
    'Save options', ...
    'Yes, save the header information too (Recommended)',...
    'No, just save the binary mask. Don''t save the header information',...
    'Yes, save the header information too (Recommended)');
% Handle response
switch choice
    case 'Yes, save the header information too (Recommended)'
        save(fullfile(PathName,FileName),'d');
    case 'No, just save the binary mask. Don''t save the header information'
        binary_mask = d.binary_mask;
        save(fullfile(PathName,FileName),'binary_mask'); 
end


% return the show masked voxels only to its previous position
if showMaskedVoxelsOnlyStatus == 0
    set(handles.showMaskedVoxelsOnly, 'Value', 0);
    guidata(hObject, handles);
    hObjectCall = handles.showMaskedVoxelsOnly;
    dfmri('showMaskedVoxelsOnly_Callback',hObjectCall,eventdata,guidata(hObjectCall));
end
set(handles.statusString, 'String', 'Status: The current mask has been successfully saved. !!!!');

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveNifti3DMask_Callback(hObject, eventdata, handles)
% hObject    handle to saveNifti3DMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveAnalyzeMask_Callback(hObject, eventdata, handles)
% hObject    handle to saveAnalyzeMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function analyzeMask_Callback(hObject, eventdata, handles)
% hObject    handle to analyzeMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global maskThreshold;
maskThreshold                   = 0.5;
set(handles.maskThresholdSlider,'Enable', 'on');
set(handles.maskThresholdValue,'Enable', 'on');
set(handles.maskThresholdSlider,'Value', maskThreshold);
set(handles.maskThresholdValue,'String', maskThreshold);
set(handles.selectNewAnatomicalRegions, 'visible', 'off');


if isempty(handles.scanData.data) 
    msgbox(['You must have the functional data loaded before you can load '...
        'the mask. So first load the functional data and then load the '...
        'mask data. Only then you will be able to see the mask overlayed ' ...
        'over your functional data. If you only want to view the mask data '...
        'then load it as if it was a functional data. In that case, ' ...
        'just go to the File > Import Data > Functional ...'...
        'and load it like you would do a regular functional scan. '...
        'Pheew !!! That was a big warning.'],...
        'No functional data found', 'warn');
    return;
end
[maskData, maskHeader]      = readMaskAnalyze(1);
% format the data in mosaic and get the slice labels and separators
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
maskData(find(maskData== 0))= NaN;

% prepare mask in all three views
mask                        = prepareMask(maskData, handles.m);
handles.maskData.data       = mask;
% handles.maskData.header     = maskHeader;
% handles.maskm               = maskm;
guidata(hObject, handles);

% invoke overlay mask button
set(handles.overlayMask, 'Value', 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
set(handles.statusString, 'String', 'Status: Mask loaded.');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function Untitled_5_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_5 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function askAQuestion_Callback(hObject, eventdata, handles)
% hObject    handle to askAQuestion (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
sendEmail();

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function reportABug_Callback(hObject, eventdata, handles)
% hObject    handle to reportABug (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
sendEmail();

% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function aboutAnalyze4D_Callback(hObject, eventdata, handles)
% hObject    handle to aboutAnalyze4D (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function stats_Callback(hObject, eventdata, handles)
% hObject    handle to stats (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function matlabMatRoi_Callback(hObject, eventdata, handles)
% hObject    handle to matlabMatRoi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function nifti3dRoi_Callback(hObject, eventdata, handles)
% hObject    handle to nifti3dRoi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function analyzeRoi_Callback(hObject, eventdata, handles)
% hObject    handle to analyzeRoi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMatabMatRoi_Callback(hObject, eventdata, handles)
% hObject    handle to saveMatabMatRoi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveNifti3dRoi_Callback(hObject, eventdata, handles)
% hObject    handle to saveNifti3dRoi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveAnalyzeRoi_Callback(hObject, eventdata, handles)
% hObject    handle to saveAnalyzeRoi (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function statistics_Callback(hObject, eventdata, handles)
% hObject    handle to statistics (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

global mask maskThreshold;
% ROI stats
numRoiVoxels = 0;
try
    numRoiVoxels = numel(find(handles.roi.roiData.imgSag));
end
try
    numRoiVoxels = numel(find(handles.roi.roiData.imgCor));
end
try
    numRoiVoxels = numel(find(handles.roi.roiData.imgAxial));
end

dispString1 = strcat('Number of voxels in ROI:',{'            '}, num2str(numRoiVoxels));

% Mask stats
numMaskedVoxels = 0;
try
    numMaskedVoxels = numel(find(mask.maskSagittal/max(max(mask.maskSagittal)) > maskThreshold));
end
try
    numMaskedVoxels =     numel(find(mask.maskAxial/max(max(mask.maskAxial)) > maskThreshold));
end
try
    numMaskedVoxels =     numel(find(mask.maskCoronal/max(max(mask.maskCoronal)) > maskThreshold));
end

if get(handles.overlayMask,'Value')
dispString2 = strcat('Number of voxels in Mask:',{'         '}, num2str(numMaskedVoxels));
else
dispString2 = strcat('Number of voxels in Mask:',{'         '}, num2str(numMaskedVoxels),{' '},'(Hidden- Enable Overlay Mask to see the masked voxels)');

end

fullString = [dispString1;dispString2];
statistics(fullString);


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function checkForUpdates_Callback(hObject, eventdata, handles)
% hObject    handle to checkForUpdates (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function requestAFeature_Callback(hObject, eventdata, handles)
% hObject    handle to requestAFeature (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function importReadyMadeAalMask_Callback(hObject, eventdata, handles)
% hObject    handle to importReadyMadeAalMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global maskThreshold;

path = mfilename('fullpath');
path = path(1:end-numel('\functions\workHorse\dfmri.m')+2);
pathToAALToolbox = fullfile(path, 'toolboxes', '3aal_for_spm8');

        [maskData, maskHeader]      = readMaskNifti3d(1);        
% end

% format the data in mosaic and get the slice labels and separators
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
maskData(find(maskData== 0))= NaN;

% prepare mask in all three views
mask                        = prepareMask(maskData, handles.m);
handles.aalMask             = mask;
guidata(hObject, handles);
% Apply region selection
%prompt the user to slect the regions
set(handles.statusString, 'String', 'Status: Please select anatomical regions to mask.');
regions = selectAnatomicalRegions();
numRegions = numel(regions);
mask.maskAxial = handles.aalMask.maskAxial;
mask.maskSagittal = handles.aalMask.maskSagittal;
mask.maskCoronal = handles.aalMask.maskCoronal;
idxMaskAxial = [];
idxMaskSagittal = [];
idxMaskCoronal = [];
set(handles.statusString, 'String', 'Status: Masking selected anatomical regions....');
% read all the user selected regions and make a mask
for i = 1 : numRegions
        idxAxial = find(mask.maskAxial == regions(i));
        idxSagittal = find(mask.maskSagittal == regions(i));
        idxCoronal = find(mask.maskCoronal == regions(i));
        idxMaskAxial = [idxMaskAxial;  idxAxial];
        idxMaskSagittal = [idxMaskSagittal;  idxSagittal];
        idxMaskCoronal = [idxMaskCoronal;  idxCoronal];
end

maskAxial       = single(nan(size(mask.maskAxial)));
maskSagittal    = single(nan(size(mask.maskSagittal)));
maskCoronal     = single(nan(size(mask.maskCoronal)));

maskAxial(idxMaskAxial)         = mask.maskAxial(idxMaskAxial);
maskSagittal(idxMaskSagittal)   = mask.maskSagittal(idxMaskSagittal);
maskCoronal(idxMaskCoronal)     = mask.maskCoronal(idxMaskCoronal) ;

mask.maskAxial      = maskAxial;
mask.maskSagittal   = maskSagittal;
mask.maskCoronal    = maskCoronal;

% set the controls, disable the threshold slider
maskThreshold                   = 0.0;
set(handles.maskThresholdSlider,'Value', 0);
set(handles.maskThresholdSlider,'Enable', 'inactive');
set(handles.maskThresholdValue,'String', 0);
set(handles.maskThresholdValue,'Enable', 'inactive');
set(handles.selectNewAnatomicalRegions, 'visible', 'on');

handles.maskData.data   = mask;
guidata(hObject, handles);

% invoke overlay mask button
set(handles.overlayMask, 'Value', 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
set(handles.statusString, 'String', 'Status: AAL mask overlayed onto the functional');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function aalMaskSlowMethod_Callback(hObject, eventdata, handles)
% hObject    handle to aalMaskSlowMethod (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global maskThreshold;

if isempty(handles.scanData.data) 
    msgbox(['You must have the functional data loaded before you can load '...
        'the mask. So first load the functional data and then load the '...
        'mask data. Only then you will be able to see the mask overlayed ' ...
        'over your functional data. If you only want to view the mask data '...
        'then load it as if it was a functional data. In that case, ' ...
        'just go to the File > Import Data > Functional ...'...
        'and load it like you would do a regular functional scan. '...
        'Pheew !!! That was a big warning.'],...
        'No functional data found', 'warn');
    return;
end
path = mfilename('fullpath');
path = path(1:end-numel('\functions\workHorse\dfmri.m')+2);
pathToAALToolbox = fullfile(path, 'toolboxes', '3aal_for_spm8');

pathstr = realignAalMaskSlowMethod(pathToAALToolbox); pause(0.5);
[maskData, maskHeader]      = readAALMaskNifti3d(pathToAALToolbox, 'wwROI_MNI_V4.nii');        
% end

% format the data in mosaic and get the slice labels and separators
[maskData,maskm]            = prepareMosaicData(maskData, maskHeader);
maskData(find(maskData== 0))= NaN;
% prepare mask in all three views
mask                        = prepareMask(maskData, handles.m);
handles.aalMask             = mask;
guidata(hObject, handles);
% Apply region selection
%prompt the user to slect the regions
set(handles.statusString, 'String', 'Status: Please select anatomical regions to mask.');
regions = selectAnatomicalRegions();
numRegions = numel(regions);
mask.maskAxial = handles.aalMask.maskAxial;
mask.maskSagittal = handles.aalMask.maskSagittal;
mask.maskCoronal = handles.aalMask.maskCoronal;
idxMaskAxial = [];
idxMaskSagittal = [];
idxMaskCoronal = [];
set(handles.statusString, 'String', 'Status: Masking selected anatomical regions....');
% read all the user selected regions and make a mask
for i = 1 : numRegions
        idxAxial = find(mask.maskAxial == regions(i));
        idxSagittal = find(mask.maskSagittal == regions(i));
        idxCoronal = find(mask.maskCoronal == regions(i));
        idxMaskAxial = [idxMaskAxial;  idxAxial];
        idxMaskSagittal = [idxMaskSagittal;  idxSagittal];
        idxMaskCoronal = [idxMaskCoronal;  idxCoronal];
end

maskAxial       = single(nan(size(mask.maskAxial)));
maskSagittal    = single(nan(size(mask.maskSagittal)));
maskCoronal     = single(nan(size(mask.maskCoronal)));

maskAxial(idxMaskAxial)         = mask.maskAxial(idxMaskAxial);
maskSagittal(idxMaskSagittal)   = mask.maskSagittal(idxMaskSagittal);
maskCoronal(idxMaskCoronal)     = mask.maskCoronal(idxMaskCoronal) ;

mask.maskAxial      = maskAxial;
mask.maskSagittal   = maskSagittal;
mask.maskCoronal    = maskCoronal;

% set the controls, disable the threshold slider
maskThreshold                   = 0.0;
set(handles.maskThresholdSlider,'Value', 0);
set(handles.maskThresholdSlider,'Enable', 'inactive');
set(handles.maskThresholdValue,'String', 0);
set(handles.maskThresholdValue,'Enable', 'inactive');
set(handles.selectNewAnatomicalRegions, 'visible', 'on');

handles.maskData.data   = mask;
guidata(hObject, handles);

% invoke overlay mask button
set(handles.overlayMask, 'Value', 1);
guidata(hObject, handles);
hObject = handles.overlayMask;
dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
set(handles.statusString, 'String', 'Status: AAL mask overlayed onto the functional');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function convertDicomsToNIFTI3d_Callback(hObject, eventdata, handles)
% hObject    handle to convertDicomsToNIFTI3d (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function convertDicomsIMAToNIFTI3d_Callback(hObject, eventdata, handles)
% hObject    handle to convertDicomsIMAToNIFTI3d (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveTimeCourseFigure_Callback(hObject, eventdata, handles)
% hObject    handle to saveTimeCourseFigure (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
h = figure;
set(h, 'Name', 'Time Course Figure');
set(h, 'NumberTitle', 'off');
% copy axes into the new figure
newax = copyobj(handles.plotAxes,h); 
legendHandle = findobj(handles.figure1, 'tag','legend');
newax = copyobj(legendHandle,h);
            
arg = {h;'Time Course Figure'};
saveFig(arg);


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMosaicFigure_Callback(hObject, eventdata, handles)
% hObject    handle to saveMosaicFigure (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% create a new figure for saving and printing
set(handles.mosaicAxes, ...
  'Box'         , 'off'     , ...
  'TickDir'     , 'out'     , ...
  'TickLength'  , [.00 .00] , ...
  'XMinorTick'  , 'off'      , ...
  'YMinorTick'  , 'off'      , ...
  'YGrid'       , 'off'      , ...
  'XColor'      , [.3 .3 .3], ...
  'YColor'      , [.3 .3 .3], ...
  'LineWidth'   , 1         );
axis(handles.mosaicAxes,'off'); % so that axis is not printed
% axis image;
h = figure;
set(h, 'Name', 'Mosaic Figure');

set(h, 'NumberTitle', 'off');
% copy axes into the new figure
newax = copyobj(handles.mosaicAxes,h); 
axis(newax,'image'); % so that axis is not printed

arg = {h;'Mosaic Figure'};
saveFig(arg);
set(handles.mosaicAxes, ...
  'XColor'      , [0 0 0], ...
  'YColor'      , [0 0 0], ...
  'LineWidth'   , 1         );
axis(handles.mosaicAxes,'on');
% axis square;
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveMosaicFigure_ButtonDownFcn(hObject, eventdata, handles)
% hObject    handle to saveMosaicFigure (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

function todo

% TODO
% what if user load multiple masks, currently we dont handle it
% AAL mask coregisters only to NIFTI reference scanREPLACE_WITH_DASH_DASH add support for other
% formats as well
% the export figure for time course does not import legends
% the export figure crashes if the interactive zzoom is on.
% in plot zoom is on and you try to chnage mask color, the mosaic is drawn
% on the plot axes

% if you add a new roi, a new condition gets added chaging the color of the
% design matrix

% the autoscaling of plot axis does not work if the new roi is out of the
% previous axes limits

% the linecmeu- the plot color and line thickneess changes everytime a new
% roi is added

% add the read header function ffrom working filedtrip[
function [x y] = getAxesLimits(axesHandle)
x = get(axesHandle, 'XLim');
y = get(axesHandle, 'YLim');

function setAxesLimits(axesHandle, x, y)
set(axesHandle, 'XLim', x);
set(axesHandle, 'YLim', y);


% REPLACE_WITH_DASH_DASH- Executes on button press in checkbox17.
function checkbox17_Callback(hObject, eventdata, handles)
% hObject    handle to checkbox17 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkbox17


% REPLACE_WITH_DASH_DASH- Executes on button press in trueColor.
function trueColor_Callback(hObject, eventdata, handles)
% hObject    handle to trueColor (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global maskThreshold;

if get(handles.trueColor, 'Value')
    tic
    % turn the trueColor buttons on
    if strcmp(get(handles.colormapTrueColorsStaticText, 'visible'), 'off')
        set(handles.colormapTrueColorsStaticText, 'visible', 'on');
        set(handles.colormapTrueColors, 'visible', 'on');
        set(handles.customizeMaskColor, 'visible', 'off');
        set(handles.maskColorBox, 'visible', 'off');
    end
    
    % turn off the mask overlay
    set(handles.overlayMask, 'Value', 0);
    guidata(hObject, handles);
    hObject = handles.overlayMask;
    dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
    set(handles.overlayMask, 'Value', 1); % jsut show that overlaying is on
    
    % find index
    idxAxial        = find(~isnan(handles.maskData.data.maskAxial));
    idxSagittal     = find(~isnan(handles.maskData.data.maskSagittal));
    idxCoronal      = find(~isnan(handles.maskData.data.maskCoronal));
    
    % Find voxel values 
    maskVoxelValuesAxial    = handles.maskData.data.maskAxial(idxAxial);
    maskVoxelValuesSagittal = handles.maskData.data.maskSagittal(idxSagittal);
    maskVoxelValuesCoronal  = handles.maskData.data.maskCoronal(idxCoronal);
    
    %find x y coords
    [axialY axialX]             = find(~isnan(handles.maskData.data.maskAxial));
    [sagittalY sagittalX]       = find(~isnan(handles.maskData.data.maskSagittal));
    [coronalY  coronalX]        = find(~isnan(handles.maskData.data.maskCoronal));
    
    %map colorn
    minValue = min(maskVoxelValuesAxial);
    maxValue = max(maskVoxelValuesAxial);
    numSteps = 256;% chnage it to 256
    chosenMap   = handles.mask.chosenTruecolorColormap;
    if strcmp(chosenMap,'None')
        return;
    elseif strcmp(chosenMap,'Hot')
        cm = hot(numSteps);
    elseif strcmp(chosenMap,'Fire')
        cm = fire(numSteps);
    elseif strcmp(chosenMap,'Jet')
        cm = jet(numSteps);
    elseif strcmp(chosenMap,'Bone')
        cm = bone(numSteps);
    elseif strcmp(chosenMap,'Winter')
        cm = winter(numSteps);
    elseif strcmp(chosenMap,'Cool')
        cm = cool(numSteps);
    elseif strcmp(chosenMap,'Maximally Distinct')
    else
        cm = hot(numSteps);
    end
    range = linspace(minValue, maxValue, numSteps);
   
    
    prompt = 'define name'
dlg_title = 'Input file name';
num_lines = 1;
def = {'01'};
answer = inputdlg(prompt,dlg_title,num_lines,def);
save(fullfile(pathstr,strcat('ROIClusters_', answer{1,1}, '.mat')), 'ROIClusters');

    
    
    
    maxSagittal = max(max(handles.maskData.data.maskSagittal));
    maxCoronal = max(max(handles.maskData.data.maskCoronal));
    maxAxial = max(max(handles.maskData.data.maskAxial));

    trueColorHandleFull = [];
    set(handles.statusString, 'String', 'Status: Calculating true color for the mask....please be patient!');
    pause(0.1);
    toc
    tic
    for i = 1 : numel(idxAxial)
        if handles.displayProperties.view == 1
            if  handles.maskData.data.maskSagittal(idxSagittal(i))/maxSagittal < maskThreshold
                continue;
            else
                maskVoxelValueSagittal = handles.maskData.data.maskSagittal(idxSagittal(i));
                [r,c,V] = findnearest(maskVoxelValueSagittal,range,-1);
                trueColorHandle =  colorpixel(sagittalX(i),sagittalY(i),cm(c,:));
                trueColorHandleFull = [trueColorHandleFull trueColorHandle];
            end            
        elseif handles.displayProperties.view == 2
            if  handles.maskData.data.maskCoronal(idxCoronal(i))/maxCoronal < maskThreshold
                continue;
            else
                maskVoxelValueCoronal = handles.maskData.data.maskCoronal(idxCoronal(i));
                [r,c,V] = findnearest(maskVoxelValueCoronal,range,-1);
                trueColorHandle =  colorpixel(coronalX(i),coronalY(i),cm(c,:));
                trueColorHandleFull = [trueColorHandleFull trueColorHandle];
            end
        elseif handles.displayProperties.view == 3
            if  handles.maskData.data.maskAxial(idxAxial(i))/maxAxial < maskThreshold
                continue;
            else
                maskVoxelValueAxial = handles.maskData.data.maskAxial(idxAxial(i));
                [r,c,V] = findnearest(maskVoxelValueAxial,range,-1);
                trueColorHandle =  colorpixel(axialX(i),axialY(i),cm(c,:));
                trueColorHandleFull = [trueColorHandleFull trueColorHandle];
            end
        end
        handles.trueColorHandleFull = trueColorHandleFull; %save the handles
        guidata(hObject,handles);
    end
    set(handles.statusString, 'String', 'Status: Mask has been colored to true colors!');
    toc
else %clear all the handles
    for i = 1 : numel(handles.trueColorHandleFull)
        delete(handles.trueColorHandleFull(i));
    end
    set(handles.colormapTrueColorsStaticText, 'visible', 'off');
    set(handles.colormapTrueColors, 'visible', 'off');
    set(handles.customizeMaskColor, 'visible', 'on');
    set(handles.maskColorBox, 'visible', 'on');
    clear handles.trueColorHandleFull;
    guidata(hObject,handles);
    
        % turn on the mask overlay
    set(handles.overlayMask, 'Value', 1);
    guidata(hObject, handles);
    hObject = handles.overlayMask;
    dfmri('overlayMask_Callback',hObject,eventdata,guidata(hObject));
end
% Hint: get(hObject,'Value') returns toggle state of trueColor


% REPLACE_WITH_DASH_DASH- Executes on selection change in colormapTrueColors.
function colormapTrueColors_Callback(hObject, eventdata, handles)
% hObject    handle to colormapTrueColors (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = cellstr(get(hObject,'String')) returns colormapTrueColors contents as cell array
%        contents{get(hObject,'Value')} returns selected item from colormapTrueColors

% first delete the handles to previous colormaped pixels
    for i = 1 : numel(handles.trueColorHandleFull)
        delete(handles.trueColorHandleFull(i));
    end
    guidata(hObject,handles);
    
    
contents = cellstr(get(hObject,'String'));
handles.mask.chosenTruecolorColormap = contents{get(hObject,'Value')};
guidata(hObject,handles);
% invoke trueMaskcolor
hObjectCall = handles.trueColor;
dfmri('trueColor_Callback',hObjectCall,eventdata,guidata(hObjectCall));
set(handles.statusString, 'String', 'Status: Colormap for the mask changed!');

% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function colormapTrueColors_CreateFcn(hObject, eventdata, handles)
% hObject    handle to colormapTrueColors (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: popupmenu controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function saveAALMask_Callback(hObject, eventdata, handles)
% hObject    handle to saveAALMask (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
path = mfilename('fullpath');
path = path(1:end-numel('\functions\workHorse\dfmri.m')+2);
pathToAALMaskSlowMethod = fullfile(path, 'toolboxes', '3aal_for_spm8','wwROI_MNI_V4.nii');
pathToAALLabelsSlowMethod = fullfile(path, 'toolboxes', '3aal_for_spm8','labels.mat');

X       = load_untouch_nii(pathToAALMaskSlowMethod);
aalMask = reshape(X.img, [], 1);
path = pickDirUsingJFileChooser();
prompt = {'Enter file name:'};
dlg_title = 'Input file name';
num_lines = 1;
def = {'aalMask'};
answer = inputdlg(prompt,dlg_title,num_lines,def);
copyfile(pathToAALMaskSlowMethod,path);
copyfile(pathToAALLabelsSlowMethod,path);
copyfile(pathToAALMaskSlowMethod, fullfile(path, strcat(answer{1,1},'.nii')),'f');
delete(fullfile(path, 'wwROI_MNI_V4.nii'));
save(fullfile(path, strcat(answer{1,1},'.mat')), 'aalMask');


% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
function analyzeToNifti_Callback(hObject, eventdata, handles)
% hObject    handle to analyzeToNifti (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

##### SOURCE END #####
--></body></html>